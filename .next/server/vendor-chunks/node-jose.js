"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-jose";
exports.ids = ["vendor-chunks/node-jose"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-cbc-hmac-sha2.js - AES-CBC-HMAC-SHA2 Composited Encryption\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    HMAC = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nfunction checkIv(iv) {\n  if (16 !== iv.length) {\n    throw new Error(\"invalid iv\");\n  }\n}\n\nfunction commonCbcEncryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var cipher = forge.cipher.createCipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      });\n\n      // TODO: chunk data\n      cipher.update(new DataBuffer(pdata));\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var cdata = Buffer.from(cipher.output.bytes(), \"binary\");\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"encrypt\"]);\n    });\n    promise = promise.then(function(key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function(cdata) {\n      cdata = Buffer.from(cdata);\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve(pdata);\n\n    promise = promise.then(function(pdata) {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createCipheriv(name, encKey, iv);\n      var cdata = Buffer.concat([\n        cipher.update(pdata),\n        cipher.final()\n      ]);\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction commonCbcDecryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var cipher = forge.cipher.createDecipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      });\n\n      // TODO: chunk data\n      cipher.update(new DataBuffer(cdata));\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var pdata = Buffer.from(cipher.output.bytes(), \"binary\");\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"decrypt\"]);\n    });\n    promise = promise.then(function(key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function(pdata) {\n      pdata = Buffer.from(pdata);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createDecipheriv(name, encKey, iv);\n      var pdata = Buffer.concat([\n        cipher.update(cdata),\n        cipher.final()\n      ]);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction checkKey(key, size) {\n  if ((size << 1) !== (key.length << 3)) {\n    throw new Error(\"invalid encryption key size\");\n  }\n}\n\nfunction cbcHmacEncryptFN(size) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n  return function(key, pdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    // STEP 1 -- Encrypt\n    var promise = commonEncrypt(eKey, pdata, iv);\n\n    // STEP 2 -- MAC\n    promise = promise.then(function(cdata){\n      var mdata = Buffer.concat([\n        adata,\n        iv,\n        cdata,\n        helpers.int64ToBuffer(adata.length * 8)\n      ]);\n\n      var promise;\n      promise = HMAC[\"HS\" + (size * 2)].sign(iKey, mdata, {\n        length: size\n      });\n      promise = promise.then(function(result) {\n        // TODO: move slice to hmac.js\n        var tag = result.mac.slice(0, size / 8);\n        return {\n          data: cdata,\n          tag: tag\n        };\n      });\n      return promise;\n    });\n\n    return promise;\n  };\n}\n\nfunction cbcHmacDecryptFN(size) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n\n  return function(key, cdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    var promise = Promise.resolve();\n\n    // STEP 1 -- MAC\n    promise = promise.then(function() {\n      var promise;\n      // construct MAC input\n      var mdata = Buffer.concat([\n        adata,\n        iv,\n        cdata,\n        helpers.int64ToBuffer(adata.length * 8)\n      ]);\n      promise = HMAC[\"HS\" + (size * 2)].verify(iKey, mdata, tag, {\n        length: size\n      });\n      promise = promise.then(function() {\n        return cdata;\n      }, function() {\n        // failure -- invalid tag error\n        throw new Error(\"mac check failed\");\n      });\n      return promise;\n    });\n\n    // STEP 2 -- Decrypt\n    promise = promise.then(function(){\n      return commonDecrypt(eKey, cdata, iv);\n    });\n\n    return promise;\n  };\n}\n\nvar EncryptionLabel = Buffer.from(\"Encryption\", \"utf8\");\nvar IntegrityLabel = Buffer.from(\"Integrity\", \"utf8\");\nvar DotLabel = Buffer.from(\".\", \"utf8\");\n\nfunction generateCek(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cekSize = masterSize / 2;\n  var promise = Promise.resolve();\n\n  promise = promise.then(function(){\n    var input = Buffer.concat([\n      helpers.int32ToBuffer(1),\n      masterKey,\n      helpers.int32ToBuffer(cekSize),\n      Buffer.from(alg, \"utf8\"),\n      epu,\n      epv,\n      EncryptionLabel\n    ]);\n\n    return input;\n  });\n\n  promise = promise.then( function(input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function(digest) {\n      return digest.slice(0, cekSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n\n  return promise;\n}\n\nfunction generateCik(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cikSize = masterSize;\n  var promise = Promise.resolve();\n\n  promise = promise.then(function(){\n    var input = Buffer.concat([\n      helpers.int32ToBuffer(1),\n      masterKey,\n      helpers.int32ToBuffer(cikSize),\n      Buffer.from(alg, \"utf8\"),\n      epu,\n      epv,\n      IntegrityLabel\n    ]);\n\n    return input;\n  });\n\n  promise = promise.then( function(input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function(digest) {\n      return digest.slice(0, cikSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n\n  return promise;\n}\n\nfunction concatKdfCbcHmacEncryptFN(size, alg) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n\n  return function(key, pdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        kdata = props.kdata || Buffer.alloc(0);\n\n    // Pre Step 1 -- Generate Keys\n    var promises = [\n      generateCek(key, alg, epu, epv),\n      generateCik(key, alg, epu, epv)\n    ];\n\n    var cek,\n        cik;\n    var promise = Promise.all(promises).then(function(keys) {\n      cek = keys[0];\n      cik = keys[1];\n    });\n\n    // STEP 1 -- Encrypt\n    promise = promise.then(function(){\n      return commonEncrypt(cek, pdata, iv);\n    });\n\n    // STEP 2 -- Mac\n    promise = promise.then(function(cdata){\n      var mdata = Buffer.concat([\n        adata,\n        DotLabel,\n        Buffer.from(kdata),\n        DotLabel,\n        Buffer.from(util.base64url.encode(iv), \"utf8\"),\n        DotLabel,\n        Buffer.from(util.base64url.encode(cdata), \"utf8\")\n      ]);\n      return Promise.all([\n        Promise.resolve(cdata),\n        HMAC[\"HS\" + (size * 2)].sign(cik, mdata, { length: size })\n      ]);\n    });\n    promise = promise.then(function(result){\n      return {\n        data: result[0],\n        tag: result[1].mac\n      };\n    });\n\n    return promise;\n  };\n}\n\nfunction concatKdfCbcHmacDecryptFN(size, alg) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n\n  return function(key, cdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        kdata = props.kdata || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // Pre Step 1 -- Generate Keys\n    var promises = [\n      generateCek(key, alg, epu, epv),\n      generateCik(key, alg, epu, epv)\n    ];\n\n    var cek,\n        cik;\n    var promise = Promise.all(promises).then(function(keys){\n      cek = keys[0];\n      cik = keys[1];\n    });\n\n\n    // STEP 1 -- MAC\n    promise = promise.then(function() {\n      // construct MAC input\n      var mdata = Buffer.concat([\n        adata,\n        DotLabel,\n        Buffer.from(kdata),\n        DotLabel,\n        Buffer.from(util.base64url.encode(iv), \"utf8\"),\n        DotLabel,\n        Buffer.from(util.base64url.encode(cdata), \"utf8\")\n      ]);\n\n      try {\n        return HMAC[\"HS\" + (size * 2)].verify(cik, mdata, tag, {\n          loose: false\n        });\n      } catch (e) {\n        throw new Error(\"mac check failed\");\n      }\n    });\n\n    // STEP 2 -- Decrypt\n    promise = promise.then(function(){\n      return commonDecrypt(cek, cdata, iv);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesCbcHmacSha2 = {};\n[\n  \"A128CBC-HS256\",\n  \"A192CBC-HS384\",\n  \"A256CBC-HS512\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)CBC-HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: cbcHmacEncryptFN(size),\n    decrypt: cbcHmacDecryptFN(size)\n  };\n});\n\n[\n  \"A128CBC+HS256\",\n  \"A192CBC+HS384\",\n  \"A256CBC+HS512\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)CBC\\+HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: concatKdfCbcHmacEncryptFN(size, alg),\n    decrypt: concatKdfCbcHmacDecryptFN(size, alg)\n  };\n});\n\nmodule.exports = aesCbcHmacSha2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1jYmMtaG1hYy1zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsOEVBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFXO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTtBQUM1QixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUF1QjtBQUNoRCxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvYWVzLWNiYy1obWFjLXNoYTIuanM/NTllOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvYWVzLWNiYy1obWFjLXNoYTIuanMgLSBBRVMtQ0JDLUhNQUMtU0hBMiBDb21wb3NpdGVkIEVuY3J5cHRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBITUFDID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKSxcbiAgICBzaGEgPSByZXF1aXJlKFwiLi9zaGEuanNcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBEYXRhQnVmZmVyID0gcmVxdWlyZShcIi4uL3V0aWwvZGF0YWJ1ZmZlci5qc1wiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbmZ1bmN0aW9uIGNoZWNrSXYoaXYpIHtcbiAgaWYgKDE2ICE9PSBpdi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl2XCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1vbkNiY0VuY3J5cHRGTihzaXplKSB7XG4gIC8vICMjIyAnZmFsbGJhY2snIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oZW5jS2V5LCBwZGF0YSwgaXYpIHtcbiAgICB0cnkge1xuICAgICAgY2hlY2tJdihpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKFwiQUVTLUNCQ1wiLCBuZXcgRGF0YUJ1ZmZlcihlbmNLZXkpKTtcbiAgICAgIGNpcGhlci5zdGFydCh7XG4gICAgICAgIGl2OiBuZXcgRGF0YUJ1ZmZlcihpdilcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUT0RPOiBjaHVuayBkYXRhXG4gICAgICBjaXBoZXIudXBkYXRlKG5ldyBEYXRhQnVmZmVyKHBkYXRhKSk7XG4gICAgICBpZiAoIWNpcGhlci5maW5pc2goKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiZW5jcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2RhdGEgPSBCdWZmZXIuZnJvbShjaXBoZXIub3V0cHV0LmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuICAgICAgcmV0dXJuIGNkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICAvLyBUT0RPOiBjYWNoZSBDcnlwdG9LZXkgc29vbmVyXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihlbmNLZXksIHBkYXRhLCBpdikge1xuICAgIHRyeSB7XG4gICAgICBjaGVja0l2KGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFsZyA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGVuY0tleSwgYWxnLCB0cnVlLCBbXCJlbmNyeXB0XCJdKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGFsZyA9IHtcbiAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICAgIGl2OiBpdlxuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5lbmNyeXB0KGFsZywga2V5LCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihjZGF0YSkge1xuICAgICAgY2RhdGEgPSBCdWZmZXIuZnJvbShjZGF0YSk7XG4gICAgICByZXR1cm4gY2RhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgTm9kZUpTIGltcGxlbWVudGF0aW9uXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihlbmNLZXksIHBkYXRhLCBpdikge1xuICAgIHRyeSB7XG4gICAgICBjaGVja0l2KGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHBkYXRhKTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocGRhdGEpIHtcbiAgICAgIHZhciBuYW1lID0gXCJBRVMtXCIgKyBzaXplICsgXCItQ0JDXCI7XG4gICAgICB2YXIgY2lwaGVyID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KG5hbWUsIGVuY0tleSwgaXYpO1xuICAgICAgdmFyIGNkYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGNpcGhlci51cGRhdGUocGRhdGEpLFxuICAgICAgICBjaXBoZXIuZmluYWwoKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gY2RhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGNvbW1vbkNiY0RlY3J5cHRGTihzaXplKSB7XG4gIC8vICMjIyAnZmFsbGJhY2snIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oZW5jS2V5LCBjZGF0YSwgaXYpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY2hlY2tJdihpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoXCJBRVMtQ0JDXCIsIG5ldyBEYXRhQnVmZmVyKGVuY0tleSkpO1xuICAgICAgY2lwaGVyLnN0YXJ0KHtcbiAgICAgICAgaXY6IG5ldyBEYXRhQnVmZmVyKGl2KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE86IGNodW5rIGRhdGFcbiAgICAgIGNpcGhlci51cGRhdGUobmV3IERhdGFCdWZmZXIoY2RhdGEpKTtcbiAgICAgIGlmICghY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJlbmNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwZGF0YSA9IEJ1ZmZlci5mcm9tKGNpcGhlci5vdXRwdXQuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG4gICAgICByZXR1cm4gcGRhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIC8vIFRPRE86IGNhY2hlIENyeXB0b0tleSBzb29uZXJcbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGVuY0tleSwgY2RhdGEsIGl2KSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrSXYoaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWxnID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jS2V5LCBhbGcsIHRydWUsIFtcImRlY3J5cHRcIl0pO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgYWxnID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIixcbiAgICAgICAgaXY6IGl2XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmRlY3J5cHQoYWxnLCBrZXksIGNkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHBkYXRhKSB7XG4gICAgICBwZGF0YSA9IEJ1ZmZlci5mcm9tKHBkYXRhKTtcbiAgICAgIHJldHVybiBwZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBOb2RlSlMgaW1wbGVtZW50YXRpb25cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGVuY0tleSwgY2RhdGEsIGl2KSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrSXYoaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSA9IFwiQUVTLVwiICsgc2l6ZSArIFwiLUNCQ1wiO1xuICAgICAgdmFyIGNpcGhlciA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVEZWNpcGhlcml2KG5hbWUsIGVuY0tleSwgaXYpO1xuICAgICAgdmFyIHBkYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGNpcGhlci51cGRhdGUoY2RhdGEpLFxuICAgICAgICBjaXBoZXIuZmluYWwoKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4gcGRhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5KGtleSwgc2l6ZSkge1xuICBpZiAoKHNpemUgPDwgMSkgIT09IChrZXkubGVuZ3RoIDw8IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmNyeXB0aW9uIGtleSBzaXplXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNiY0htYWNFbmNyeXB0Rk4oc2l6ZSkge1xuICB2YXIgY29tbW9uRW5jcnlwdCA9IGNvbW1vbkNiY0VuY3J5cHRGTihzaXplKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrS2V5KGtleSwgc2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgZUtleSA9IGtleS5zbGljZShzaXplIC8gOCksXG4gICAgICAgIGlLZXkgPSBrZXkuc2xpY2UoMCwgc2l6ZSAvIDgpLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgLy8gU1RFUCAxIC0tIEVuY3J5cHRcbiAgICB2YXIgcHJvbWlzZSA9IGNvbW1vbkVuY3J5cHQoZUtleSwgcGRhdGEsIGl2KTtcblxuICAgIC8vIFNURVAgMiAtLSBNQUNcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNkYXRhKXtcbiAgICAgIHZhciBtZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBhZGF0YSxcbiAgICAgICAgaXYsXG4gICAgICAgIGNkYXRhLFxuICAgICAgICBoZWxwZXJzLmludDY0VG9CdWZmZXIoYWRhdGEubGVuZ3RoICogOClcbiAgICAgIF0pO1xuXG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBITUFDW1wiSFNcIiArIChzaXplICogMildLnNpZ24oaUtleSwgbWRhdGEsIHtcbiAgICAgICAgbGVuZ3RoOiBzaXplXG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIC8vIFRPRE86IG1vdmUgc2xpY2UgdG8gaG1hYy5qc1xuICAgICAgICB2YXIgdGFnID0gcmVzdWx0Lm1hYy5zbGljZSgwLCBzaXplIC8gOCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogY2RhdGEsXG4gICAgICAgICAgdGFnOiB0YWdcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2JjSG1hY0RlY3J5cHRGTihzaXplKSB7XG4gIHZhciBjb21tb25EZWNyeXB0ID0gY29tbW9uQ2JjRGVjcnlwdEZOKHNpemUpO1xuXG4gIHJldHVybiBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjaGVja0tleShrZXksIHNpemUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGVLZXkgPSBrZXkuc2xpY2Uoc2l6ZSAvIDgpLFxuICAgICAgICBpS2V5ID0ga2V5LnNsaWNlKDAsIHNpemUgLyA4KSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgdGFnID0gcHJvcHMudGFnIHx8IHByb3BzLm1hYyB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgLy8gU1RFUCAxIC0tIE1BQ1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIC8vIGNvbnN0cnVjdCBNQUMgaW5wdXRcbiAgICAgIHZhciBtZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBhZGF0YSxcbiAgICAgICAgaXYsXG4gICAgICAgIGNkYXRhLFxuICAgICAgICBoZWxwZXJzLmludDY0VG9CdWZmZXIoYWRhdGEubGVuZ3RoICogOClcbiAgICAgIF0pO1xuICAgICAgcHJvbWlzZSA9IEhNQUNbXCJIU1wiICsgKHNpemUgKiAyKV0udmVyaWZ5KGlLZXksIG1kYXRhLCB0YWcsIHtcbiAgICAgICAgbGVuZ3RoOiBzaXplXG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjZGF0YTtcbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBmYWlsdXJlIC0tIGludmFsaWQgdGFnIGVycm9yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hYyBjaGVjayBmYWlsZWRcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH0pO1xuXG4gICAgLy8gU1RFUCAyIC0tIERlY3J5cHRcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY29tbW9uRGVjcnlwdChlS2V5LCBjZGF0YSwgaXYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG59XG5cbnZhciBFbmNyeXB0aW9uTGFiZWwgPSBCdWZmZXIuZnJvbShcIkVuY3J5cHRpb25cIiwgXCJ1dGY4XCIpO1xudmFyIEludGVncml0eUxhYmVsID0gQnVmZmVyLmZyb20oXCJJbnRlZ3JpdHlcIiwgXCJ1dGY4XCIpO1xudmFyIERvdExhYmVsID0gQnVmZmVyLmZyb20oXCIuXCIsIFwidXRmOFwiKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDZWsobWFzdGVyS2V5LCBhbGcsIGVwdSwgZXB2KSB7XG4gIHZhciBtYXN0ZXJTaXplID0gbWFzdGVyS2V5Lmxlbmd0aCAqIDg7XG4gIHZhciBjZWtTaXplID0gbWFzdGVyU2l6ZSAvIDI7XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpe1xuICAgIHZhciBpbnB1dCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgaGVscGVycy5pbnQzMlRvQnVmZmVyKDEpLFxuICAgICAgbWFzdGVyS2V5LFxuICAgICAgaGVscGVycy5pbnQzMlRvQnVmZmVyKGNla1NpemUpLFxuICAgICAgQnVmZmVyLmZyb20oYWxnLCBcInV0ZjhcIiksXG4gICAgICBlcHUsXG4gICAgICBlcHYsXG4gICAgICBFbmNyeXB0aW9uTGFiZWxcbiAgICBdKTtcblxuICAgIHJldHVybiBpbnB1dDtcbiAgfSk7XG5cbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbiggZnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gc2hhW1wiU0hBLVwiICsgbWFzdGVyU2l6ZV0uZGlnZXN0KGlucHV0KS50aGVuKGZ1bmN0aW9uKGRpZ2VzdCkge1xuICAgICAgcmV0dXJuIGRpZ2VzdC5zbGljZSgwLCBjZWtTaXplIC8gOCk7XG4gICAgfSk7XG4gIH0pO1xuICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNpayhtYXN0ZXJLZXksIGFsZywgZXB1LCBlcHYpIHtcbiAgdmFyIG1hc3RlclNpemUgPSBtYXN0ZXJLZXkubGVuZ3RoICogODtcbiAgdmFyIGNpa1NpemUgPSBtYXN0ZXJTaXplO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcbiAgICB2YXIgaW5wdXQgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGhlbHBlcnMuaW50MzJUb0J1ZmZlcigxKSxcbiAgICAgIG1hc3RlcktleSxcbiAgICAgIGhlbHBlcnMuaW50MzJUb0J1ZmZlcihjaWtTaXplKSxcbiAgICAgIEJ1ZmZlci5mcm9tKGFsZywgXCJ1dGY4XCIpLFxuICAgICAgZXB1LFxuICAgICAgZXB2LFxuICAgICAgSW50ZWdyaXR5TGFiZWxcbiAgICBdKTtcblxuICAgIHJldHVybiBpbnB1dDtcbiAgfSk7XG5cbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbiggZnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gc2hhW1wiU0hBLVwiICsgbWFzdGVyU2l6ZV0uZGlnZXN0KGlucHV0KS50aGVuKGZ1bmN0aW9uKGRpZ2VzdCkge1xuICAgICAgcmV0dXJuIGRpZ2VzdC5zbGljZSgwLCBjaWtTaXplIC8gOCk7XG4gICAgfSk7XG4gIH0pO1xuICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb21pc2UpO1xuXG4gIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBjb25jYXRLZGZDYmNIbWFjRW5jcnlwdEZOKHNpemUsIGFsZykge1xuICB2YXIgY29tbW9uRW5jcnlwdCA9IGNvbW1vbkNiY0VuY3J5cHRGTihzaXplKTtcblxuICByZXR1cm4gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgZXB1ID0gcHJvcHMuZXB1IHx8IGhlbHBlcnMuaW50MzJUb0J1ZmZlcigwKSxcbiAgICAgICAgZXB2ID0gcHJvcHMuZXB2IHx8IGhlbHBlcnMuaW50MzJUb0J1ZmZlcigwKSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAga2RhdGEgPSBwcm9wcy5rZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvLyBQcmUgU3RlcCAxIC0tIEdlbmVyYXRlIEtleXNcbiAgICB2YXIgcHJvbWlzZXMgPSBbXG4gICAgICBnZW5lcmF0ZUNlayhrZXksIGFsZywgZXB1LCBlcHYpLFxuICAgICAgZ2VuZXJhdGVDaWsoa2V5LCBhbGcsIGVwdSwgZXB2KVxuICAgIF07XG5cbiAgICB2YXIgY2VrLFxuICAgICAgICBjaWs7XG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihrZXlzKSB7XG4gICAgICBjZWsgPSBrZXlzWzBdO1xuICAgICAgY2lrID0ga2V5c1sxXTtcbiAgICB9KTtcblxuICAgIC8vIFNURVAgMSAtLSBFbmNyeXB0XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGNvbW1vbkVuY3J5cHQoY2VrLCBwZGF0YSwgaXYpO1xuICAgIH0pO1xuXG4gICAgLy8gU1RFUCAyIC0tIE1hY1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY2RhdGEpe1xuICAgICAgdmFyIG1kYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGFkYXRhLFxuICAgICAgICBEb3RMYWJlbCxcbiAgICAgICAgQnVmZmVyLmZyb20oa2RhdGEpLFxuICAgICAgICBEb3RMYWJlbCxcbiAgICAgICAgQnVmZmVyLmZyb20odXRpbC5iYXNlNjR1cmwuZW5jb2RlKGl2KSwgXCJ1dGY4XCIpLFxuICAgICAgICBEb3RMYWJlbCxcbiAgICAgICAgQnVmZmVyLmZyb20odXRpbC5iYXNlNjR1cmwuZW5jb2RlKGNkYXRhKSwgXCJ1dGY4XCIpXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIFByb21pc2UucmVzb2x2ZShjZGF0YSksXG4gICAgICAgIEhNQUNbXCJIU1wiICsgKHNpemUgKiAyKV0uc2lnbihjaWssIG1kYXRhLCB7IGxlbmd0aDogc2l6ZSB9KVxuICAgICAgXSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcmVzdWx0WzBdLFxuICAgICAgICB0YWc6IHJlc3VsdFsxXS5tYWNcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29uY2F0S2RmQ2JjSG1hY0RlY3J5cHRGTihzaXplLCBhbGcpIHtcbiAgdmFyIGNvbW1vbkRlY3J5cHQgPSBjb21tb25DYmNEZWNyeXB0Rk4oc2l6ZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgdmFyIGVwdSA9IHByb3BzLmVwdSB8fCBoZWxwZXJzLmludDMyVG9CdWZmZXIoMCksXG4gICAgICAgIGVwdiA9IHByb3BzLmVwdiB8fCBoZWxwZXJzLmludDMyVG9CdWZmZXIoMCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGtkYXRhID0gcHJvcHMua2RhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICB0YWcgPSBwcm9wcy50YWcgfHwgcHJvcHMubWFjIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIC8vIFByZSBTdGVwIDEgLS0gR2VuZXJhdGUgS2V5c1xuICAgIHZhciBwcm9taXNlcyA9IFtcbiAgICAgIGdlbmVyYXRlQ2VrKGtleSwgYWxnLCBlcHUsIGVwdiksXG4gICAgICBnZW5lcmF0ZUNpayhrZXksIGFsZywgZXB1LCBlcHYpXG4gICAgXTtcblxuICAgIHZhciBjZWssXG4gICAgICAgIGNpaztcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGtleXMpe1xuICAgICAgY2VrID0ga2V5c1swXTtcbiAgICAgIGNpayA9IGtleXNbMV07XG4gICAgfSk7XG5cblxuICAgIC8vIFNURVAgMSAtLSBNQUNcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc3RydWN0IE1BQyBpbnB1dFxuICAgICAgdmFyIG1kYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGFkYXRhLFxuICAgICAgICBEb3RMYWJlbCxcbiAgICAgICAgQnVmZmVyLmZyb20oa2RhdGEpLFxuICAgICAgICBEb3RMYWJlbCxcbiAgICAgICAgQnVmZmVyLmZyb20odXRpbC5iYXNlNjR1cmwuZW5jb2RlKGl2KSwgXCJ1dGY4XCIpLFxuICAgICAgICBEb3RMYWJlbCxcbiAgICAgICAgQnVmZmVyLmZyb20odXRpbC5iYXNlNjR1cmwuZW5jb2RlKGNkYXRhKSwgXCJ1dGY4XCIpXG4gICAgICBdKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEhNQUNbXCJIU1wiICsgKHNpemUgKiAyKV0udmVyaWZ5KGNpaywgbWRhdGEsIHRhZywge1xuICAgICAgICAgIGxvb3NlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFjIGNoZWNrIGZhaWxlZFwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNURVAgMiAtLSBEZWNyeXB0XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGNvbW1vbkRlY3J5cHQoY2VrLCBjZGF0YSwgaXYpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5lbmNyeXB0XG4vLyAqIFtuYW1lXS5kZWNyeXB0XG52YXIgYWVzQ2JjSG1hY1NoYTIgPSB7fTtcbltcbiAgXCJBMTI4Q0JDLUhTMjU2XCIsXG4gIFwiQTE5MkNCQy1IUzM4NFwiLFxuICBcIkEyNTZDQkMtSFM1MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICB2YXIgc2l6ZSA9IHBhcnNlSW50KC9BKFxcZCspQ0JDLUhTKFxcZCspPy9nLmV4ZWMoYWxnKVsxXSk7XG4gIGFlc0NiY0htYWNTaGEyW2FsZ10gPSB7XG4gICAgZW5jcnlwdDogY2JjSG1hY0VuY3J5cHRGTihzaXplKSxcbiAgICBkZWNyeXB0OiBjYmNIbWFjRGVjcnlwdEZOKHNpemUpXG4gIH07XG59KTtcblxuW1xuICBcIkExMjhDQkMrSFMyNTZcIixcbiAgXCJBMTkyQ0JDK0hTMzg0XCIsXG4gIFwiQTI1NkNCQytIUzUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBzaXplID0gcGFyc2VJbnQoL0EoXFxkKylDQkNcXCtIUyhcXGQrKT8vZy5leGVjKGFsZylbMV0pO1xuICBhZXNDYmNIbWFjU2hhMlthbGddID0ge1xuICAgIGVuY3J5cHQ6IGNvbmNhdEtkZkNiY0htYWNFbmNyeXB0Rk4oc2l6ZSwgYWxnKSxcbiAgICBkZWNyeXB0OiBjb25jYXRLZGZDYmNIbWFjRGVjcnlwdEZOKHNpemUsIGFsZylcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFlc0NiY0htYWNTaGEyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-gcm.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-gcm.js - AES-GCM Encryption and Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    GCM = __webpack_require__(/*! ../deps/ciphermodes/gcm */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js\");\n\nfunction gcmEncryptFN(size, wrap) {\n  function commonChecks(key, iv) {\n    if (size !== (key.length << 3)) {\n       throw new Error(\"invalid key size\");\n    }\n    if (!iv && !wrap) {\n      throw new Error(\"invalid iv\");\n    }\n    if (iv && 12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n  }\n\n  function prepareResults(results) {\n    if (wrap) {\n      var iv = util.base64url.encode(results.iv);\n      var tag = util.base64url.encode(results.tag);\n\n      results = {\n        data: results.data,\n        header: {\n          iv: iv,\n          tag: tag\n        }\n      };\n    }\n\n    return results;\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        cipher,\n        cdata;\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    // setup cipher\n    cipher = GCM.createCipher({\n      key: key,\n      iv: iv,\n      additionalData: adata\n    });\n    // ciphertext is the same length as plaintext\n    cdata = Buffer.alloc(pdata.length);\n\n    var promise = new Promise(function(resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          clen = 0,\n          poff = 0;\n\n      (function doChunk() {\n        var plen = Math.min(amt, pdata.length - poff);\n        clen += cipher.update(pdata,\n                              poff,\n                              plen,\n                              cdata,\n                              clen);\n        poff += plen;\n        if (pdata.length > poff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        // finish it\n        clen += cipher.finish(cdata, clen);\n        if (clen !== pdata.length) {\n          reject(new Error(\"encryption failed\"));\n          return;\n        }\n\n        // resolve with output\n        var tag = cipher.tag;\n        resolve(prepareResults({\n          data: cdata,\n          iv: iv,\n          tag: tag\n        }));\n      })();\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"encrypt\"]);\n    promise = promise.then(function(key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var tagStart = result.byteLength - 16;\n\n      var tag = result.slice(tagStart);\n      tag = Buffer.from(tag);\n\n      var cdata = result.slice(0, tagStart);\n      cdata = Buffer.from(cdata);\n\n      return prepareResults({\n        data: cdata,\n        iv: iv,\n        tag: tag\n      });\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    var alg = \"aes-\" + (key.length * 8) + \"-gcm\";\n    var cipher;\n    try {\n      cipher = helpers.nodeCrypto.createCipheriv(alg, key, iv);\n    } catch (err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    var cdata = Buffer.concat([\n      cipher.update(pdata),\n      cipher.final()\n    ]);\n    var tag = cipher.getAuthTag();\n\n    return prepareResults({\n      data: cdata,\n      iv: iv,\n      tag: tag\n    });\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction gcmDecryptFN(size) {\n  function commonChecks(key, iv, tag) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n    if (16 !== tag.length) {\n      throw new Error(\"invalid tag length\");\n    }\n  }\n\n  // ### fallback implementation -- uses forge\n  var fallback = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0),\n        cipher,\n        pdata;\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    cipher = GCM.createDecipher({\n      key: key,\n      iv: iv,\n      additionalData: adata,\n      tag: tag\n    });\n    // plaintext is the same length as ciphertext\n    pdata = Buffer.alloc(cdata.length);\n\n    var promise = new Promise(function(resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          plen = 0,\n          coff = 0;\n\n      (function doChunk() {\n        var clen = Math.min(amt, cdata.length - coff);\n        plen += cipher.update(cdata,\n                              coff,\n                              clen,\n                              pdata,\n                              plen);\n        coff += clen;\n        if (cdata.length > coff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        try {\n          plen += cipher.finish(pdata, plen);\n        } catch (err) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        if (plen !== cdata.length) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        // resolve with output\n        resolve(pdata);\n      })();\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"decrypt\"]);\n    promise = promise.then(function(key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      // concatenate cdata and tag\n      cdata = Buffer.concat([cdata, tag], cdata.length + tag.length);\n\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function(pdata) {\n      pdata = Buffer.from(pdata);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  var nodejs = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = \"aes-\" + (key.length * 8) + \"-gcm\";\n    var cipher;\n    try {\n      cipher = helpers.nodeCrypto.createDecipheriv(alg, key, iv);\n    } catch(err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    cipher.setAuthTag(tag);\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    try {\n      var pdata = Buffer.concat([\n        cipher.update(cdata),\n        cipher.final()\n      ]);\n\n      return pdata;\n    } catch (err) {\n      throw new Error(\"decryption failed\");\n    }\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesGcm = {};\n[\n  \"A128GCM\",\n  \"A192GCM\",\n  \"A256GCM\",\n  \"A128GCMKW\",\n  \"A192GCMKW\",\n  \"A256GCMKW\"\n].forEach(function(alg) {\n  var parts = /A(\\d+)GCM(KW)?/g.exec(alg);\n  var size = parseInt(parts[1]);\n  var wrap = (parts[2] === \"KW\");\n  aesGcm[alg] = {\n    encrypt: gcmEncryptFN(size, wrap),\n    decrypt: gcmDecryptFN(size, wrap)\n  };\n});\n\nmodule.exports = aesGcm;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1nY20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxpR0FBeUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1nY20uanM/ZWJhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvYWVzLWdjbS5qcyAtIEFFUy1HQ00gRW5jcnlwdGlvbiBhbmQgS2V5LVdyYXBwaW5nXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKSxcbiAgICBHQ00gPSByZXF1aXJlKFwiLi4vZGVwcy9jaXBoZXJtb2Rlcy9nY21cIik7XG5cbmZ1bmN0aW9uIGdjbUVuY3J5cHRGTihzaXplLCB3cmFwKSB7XG4gIGZ1bmN0aW9uIGNvbW1vbkNoZWNrcyhrZXksIGl2KSB7XG4gICAgaWYgKHNpemUgIT09IChrZXkubGVuZ3RoIDw8IDMpKSB7XG4gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKCFpdiAmJiAhd3JhcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKTtcbiAgICB9XG4gICAgaWYgKGl2ICYmIDEyICE9PSBpdi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVJlc3VsdHMocmVzdWx0cykge1xuICAgIGlmICh3cmFwKSB7XG4gICAgICB2YXIgaXYgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0cy5pdik7XG4gICAgICB2YXIgdGFnID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdHMudGFnKTtcblxuICAgICAgcmVzdWx0cyA9IHtcbiAgICAgICAgZGF0YTogcmVzdWx0cy5kYXRhLFxuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICBpdjogaXYsXG4gICAgICAgICAgdGFnOiB0YWdcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vICMjIyAnZmFsbGJhY2snIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgaXYgPSBwcm9wcy5pdixcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBjaXBoZXIsXG4gICAgICAgIGNkYXRhO1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGl2LCBhZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBpdiA9IGl2IHx8IHV0aWwucmFuZG9tQnl0ZXMoMTIpO1xuXG4gICAgLy8gc2V0dXAgY2lwaGVyXG4gICAgY2lwaGVyID0gR0NNLmNyZWF0ZUNpcGhlcih7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGl2OiBpdixcbiAgICAgIGFkZGl0aW9uYWxEYXRhOiBhZGF0YVxuICAgIH0pO1xuICAgIC8vIGNpcGhlcnRleHQgaXMgdGhlIHNhbWUgbGVuZ3RoIGFzIHBsYWludGV4dFxuICAgIGNkYXRhID0gQnVmZmVyLmFsbG9jKHBkYXRhLmxlbmd0aCk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGFtdCA9IENPTlNUQU5UUy5DSFVOS19TSVpFLFxuICAgICAgICAgIGNsZW4gPSAwLFxuICAgICAgICAgIHBvZmYgPSAwO1xuXG4gICAgICAoZnVuY3Rpb24gZG9DaHVuaygpIHtcbiAgICAgICAgdmFyIHBsZW4gPSBNYXRoLm1pbihhbXQsIHBkYXRhLmxlbmd0aCAtIHBvZmYpO1xuICAgICAgICBjbGVuICs9IGNpcGhlci51cGRhdGUocGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ZmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlbik7XG4gICAgICAgIHBvZmYgKz0gcGxlbjtcbiAgICAgICAgaWYgKHBkYXRhLmxlbmd0aCA+IHBvZmYpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGRvQ2h1bmssIDApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCBpdFxuICAgICAgICBjbGVuICs9IGNpcGhlci5maW5pc2goY2RhdGEsIGNsZW4pO1xuICAgICAgICBpZiAoY2xlbiAhPT0gcGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcImVuY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNvbHZlIHdpdGggb3V0cHV0XG4gICAgICAgIHZhciB0YWcgPSBjaXBoZXIudGFnO1xuICAgICAgICByZXNvbHZlKHByZXBhcmVSZXN1bHRzKHtcbiAgICAgICAgICBkYXRhOiBjZGF0YSxcbiAgICAgICAgICBpdjogaXYsXG4gICAgICAgICAgdGFnOiB0YWdcbiAgICAgICAgfSkpO1xuICAgICAgfSkoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgLy8gVE9ETzogY2FjaGUgQ3J5cHRvS2V5IHNvb25lclxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgaXYgPSBwcm9wcy5pdixcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGl2LCBhZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBpdiA9IGl2IHx8IHV0aWwucmFuZG9tQnl0ZXMoMTIpO1xuXG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiQUVTLUdDTVwiXG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJlbmNyeXB0XCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgYWxnLml2ID0gaXY7XG4gICAgICBhbGcudGFnTGVuZ3RoID0gMTI4O1xuICAgICAgaWYgKGFkYXRhLmxlbmd0aCkge1xuICAgICAgICBhbGcuYWRkaXRpb25hbERhdGEgPSBhZGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmVuY3J5cHQoYWxnLCBrZXksIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdmFyIHRhZ1N0YXJ0ID0gcmVzdWx0LmJ5dGVMZW5ndGggLSAxNjtcblxuICAgICAgdmFyIHRhZyA9IHJlc3VsdC5zbGljZSh0YWdTdGFydCk7XG4gICAgICB0YWcgPSBCdWZmZXIuZnJvbSh0YWcpO1xuXG4gICAgICB2YXIgY2RhdGEgPSByZXN1bHQuc2xpY2UoMCwgdGFnU3RhcnQpO1xuICAgICAgY2RhdGEgPSBCdWZmZXIuZnJvbShjZGF0YSk7XG5cbiAgICAgIHJldHVybiBwcmVwYXJlUmVzdWx0cyh7XG4gICAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgICBpdjogaXYsXG4gICAgICAgIHRhZzogdGFnXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBOb2RlSlMgaW1wbGVtZW50YXRpb25cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgdmFyIGl2ID0gcHJvcHMuaXYsXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBpdiwgYWRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgaXYgPSBpdiB8fCB1dGlsLnJhbmRvbUJ5dGVzKDEyKTtcblxuICAgIHZhciBhbGcgPSBcImFlcy1cIiArIChrZXkubGVuZ3RoICogOCkgKyBcIi1nY21cIjtcbiAgICB2YXIgY2lwaGVyO1xuICAgIHRyeSB7XG4gICAgICBjaXBoZXIgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYWxnLCBrZXksIGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpO1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2lwaGVyLnNldEFBRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZyk7XG4gICAgfVxuICAgIGlmIChhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNpcGhlci5zZXRBQUQoYWRhdGEpO1xuICAgIH1cblxuICAgIHZhciBjZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgY2lwaGVyLnVwZGF0ZShwZGF0YSksXG4gICAgICBjaXBoZXIuZmluYWwoKVxuICAgIF0pO1xuICAgIHZhciB0YWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpO1xuXG4gICAgcmV0dXJuIHByZXBhcmVSZXN1bHRzKHtcbiAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgaXY6IGl2LFxuICAgICAgdGFnOiB0YWdcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdjbURlY3J5cHRGTihzaXplKSB7XG4gIGZ1bmN0aW9uIGNvbW1vbkNoZWNrcyhrZXksIGl2LCB0YWcpIHtcbiAgICBpZiAoc2l6ZSAhPT0gKGtleS5sZW5ndGggPDwgMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IHNpemVcIik7XG4gICAgfVxuICAgIGlmICgxMiAhPT0gaXYubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl2XCIpO1xuICAgIH1cbiAgICBpZiAoMTYgIT09IHRhZy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdGFnIGxlbmd0aFwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHZhciBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICB0YWcgPSBwcm9wcy50YWcgfHwgcHJvcHMubWFjIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgY2lwaGVyLFxuICAgICAgICBwZGF0YTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBpdiwgdGFnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGNpcGhlclxuICAgIGNpcGhlciA9IEdDTS5jcmVhdGVEZWNpcGhlcih7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIGl2OiBpdixcbiAgICAgIGFkZGl0aW9uYWxEYXRhOiBhZGF0YSxcbiAgICAgIHRhZzogdGFnXG4gICAgfSk7XG4gICAgLy8gcGxhaW50ZXh0IGlzIHRoZSBzYW1lIGxlbmd0aCBhcyBjaXBoZXJ0ZXh0XG4gICAgcGRhdGEgPSBCdWZmZXIuYWxsb2MoY2RhdGEubGVuZ3RoKTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgYW10ID0gQ09OU1RBTlRTLkNIVU5LX1NJWkUsXG4gICAgICAgICAgcGxlbiA9IDAsXG4gICAgICAgICAgY29mZiA9IDA7XG5cbiAgICAgIChmdW5jdGlvbiBkb0NodW5rKCkge1xuICAgICAgICB2YXIgY2xlbiA9IE1hdGgubWluKGFtdCwgY2RhdGEubGVuZ3RoIC0gY29mZik7XG4gICAgICAgIHBsZW4gKz0gY2lwaGVyLnVwZGF0ZShjZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGVuKTtcbiAgICAgICAgY29mZiArPSBjbGVuO1xuICAgICAgICBpZiAoY2RhdGEubGVuZ3RoID4gY29mZikge1xuICAgICAgICAgIHNldFRpbWVvdXQoZG9DaHVuaywgMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwbGVuICs9IGNpcGhlci5maW5pc2gocGRhdGEsIHBsZW4pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiZGVjcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwbGVuICE9PSBjZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiZGVjcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc29sdmUgd2l0aCBvdXRwdXRcbiAgICAgICAgcmVzb2x2ZShwZGF0YSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICAvLyBUT0RPOiBjYWNoZSBDcnlwdG9LZXkgc29vbmVyXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHZhciBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICB0YWcgPSBwcm9wcy50YWcgfHwgcHJvcHMubWFjIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBpdiwgdGFnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkFFUy1HQ01cIlxuICAgIH07XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wiZGVjcnlwdFwiXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIGFsZy5pdiA9IGl2O1xuICAgICAgYWxnLnRhZ0xlbmd0aCA9IDEyODtcbiAgICAgIGlmIChhZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgYWxnLmFkZGl0aW9uYWxEYXRhID0gYWRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbmNhdGVuYXRlIGNkYXRhIGFuZCB0YWdcbiAgICAgIGNkYXRhID0gQnVmZmVyLmNvbmNhdChbY2RhdGEsIHRhZ10sIGNkYXRhLmxlbmd0aCArIHRhZy5sZW5ndGgpO1xuXG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZGVjcnlwdChhbGcsIGtleSwgY2RhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocGRhdGEpIHtcbiAgICAgIHBkYXRhID0gQnVmZmVyLmZyb20ocGRhdGEpO1xuICAgICAgcmV0dXJuIHBkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgdmFyIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIHRhZyA9IHByb3BzLnRhZyB8fCBwcm9wcy5tYWMgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGl2LCB0YWcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGFsZyA9IFwiYWVzLVwiICsgKGtleS5sZW5ndGggKiA4KSArIFwiLWdjbVwiO1xuICAgIHZhciBjaXBoZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNpcGhlciA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGFsZywga2V5LCBpdik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpO1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2lwaGVyLnNldEFBRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZyk7XG4gICAgfVxuICAgIGNpcGhlci5zZXRBdXRoVGFnKHRhZyk7XG4gICAgaWYgKGFkYXRhLmxlbmd0aCkge1xuICAgICAgY2lwaGVyLnNldEFBRChhZGF0YSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBwZGF0YSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBjaXBoZXIudXBkYXRlKGNkYXRhKSxcbiAgICAgICAgY2lwaGVyLmZpbmFsKClcbiAgICAgIF0pO1xuXG4gICAgICByZXR1cm4gcGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWNyeXB0aW9uIGZhaWxlZFwiKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZW5jcnlwdFxuLy8gKiBbbmFtZV0uZGVjcnlwdFxudmFyIGFlc0djbSA9IHt9O1xuW1xuICBcIkExMjhHQ01cIixcbiAgXCJBMTkyR0NNXCIsXG4gIFwiQTI1NkdDTVwiLFxuICBcIkExMjhHQ01LV1wiLFxuICBcIkExOTJHQ01LV1wiLFxuICBcIkEyNTZHQ01LV1wiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBwYXJ0cyA9IC9BKFxcZCspR0NNKEtXKT8vZy5leGVjKGFsZyk7XG4gIHZhciBzaXplID0gcGFyc2VJbnQocGFydHNbMV0pO1xuICB2YXIgd3JhcCA9IChwYXJ0c1syXSA9PT0gXCJLV1wiKTtcbiAgYWVzR2NtW2FsZ10gPSB7XG4gICAgZW5jcnlwdDogZ2NtRW5jcnlwdEZOKHNpemUsIHdyYXApLFxuICAgIGRlY3J5cHQ6IGdjbURlY3J5cHRGTihzaXplLCB3cmFwKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWVzR2NtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-kw.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-kw.js - AES-KW Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\");\n\nvar A0 = Buffer.from(\"a6a6a6a6a6a6a6a6\", \"hex\");\n\n// ### helpers\nfunction xor(a, b) {\n  var len = Math.max(a.length, b.length);\n  var result = Buffer.alloc(len);\n  for (var idx = 0; len > idx; idx++) {\n    result[idx] = (a[idx] || 0) ^ (b[idx] || 0);\n  }\n  return result;\n}\n\nfunction split(input, size) {\n  var output = [];\n  for (var idx = 0; input.length > idx; idx += size) {\n    output.push(input.slice(idx, idx + size));\n  }\n  return output;\n}\n\nfunction longToBigEndian(input) {\n  var hi = Math.floor(input / 4294967296),\n      lo = input % 4294967296;\n  var output = Buffer.alloc(8);\n  output[0] = 0xff & (hi >>> 24);\n  output[1] = 0xff & (hi >>> 16);\n  output[2] = 0xff & (hi >>> 8);\n  output[3] = 0xff & (hi >>> 0);\n  output[4] = 0xff & (lo >>> 24);\n  output[5] = 0xff & (lo >>> 16);\n  output[6] = 0xff & (lo >>> 8);\n  output[7] = 0xff & (lo >>> 0);\n  return output;\n}\n\nfunction kwEncryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (0 < data.length && 0 !== (data.length % 8)) {\n      throw new Error(\"invalid data length\");\n    }\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    var cipher = forge.cipher.createCipher(\"AES\", new DataBuffer(key));\n\n    // split input into chunks\n    var R = split(pdata, 8);\n    var A,\n        B,\n        count;\n    A = A0;\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = (R.length * jdx) + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = Buffer.from(cipher.output.bytes(), \"binary\");\n\n        A = xor(B.slice(0, 8),\n                longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n  // ### WebCryptoAPI implementation\n  var webcrypto = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = [\n      helpers.subtleCrypto.importKey(\"raw\", pdata, { name: \"HMAC\", hash: \"SHA-256\" }, true, [\"sign\"]),\n      helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"wrapKey\"])\n    ];\n    promise = Promise.all(promise);\n    promise = promise.then(function(keys) {\n      return helpers.subtleCrypto.wrapKey(\"raw\",\n                                          keys[0], // key\n                                          keys[1], // wrappingKey\n                                          alg);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n\n      return {\n        data: result\n      };\n    });\n    return promise;\n  };\n  var node = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // split input into chunks\n    var R = split(pdata, 8),\n        iv = Buffer.alloc(16);\n    var A,\n        B,\n        count;\n    A = A0;\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = (R.length * jdx) + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        var cipher = helpers.nodeCrypto.createCipheriv(\"AES\" + size, key, iv);\n        B = cipher.update(B);\n\n        A = xor(B.slice(0, 8),\n                longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n\n  return helpers.setupFallback(node, webcrypto, fallback);\n}\nfunction kwDecryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (0 < (data.length - 8) && 0 !== (data.length % 8)) {\n      throw new Error(\"invalid data length\");\n    }\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    var cipher = forge.cipher.createDecipher(\"AES\", new DataBuffer(key));\n\n    // prepare inputs\n    var R = split(cdata, 8),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = (R.length * jdx) + idx + 1;\n        B = xor(A,\n                longToBigEndian(count));\n        B = Buffer.concat([B, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = Buffer.from(cipher.output.bytes(), \"binary\");\n\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  };\n  // ### WebCryptoAPI implementation\n  var webcrypto = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"unwrapKey\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.unwrapKey(\"raw\", cdata, key, alg, {name: \"HMAC\", hash: \"SHA-256\"}, true, [\"sign\"]);\n    });\n    promise = promise.then(function(result) {\n      // unwrapped CryptoKey -- extract raw\n      return helpers.subtleCrypto.exportKey(\"raw\", result);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return promise;\n  };\n  var node = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // prepare inputs\n    var R = split(cdata, 8),\n        iv = Buffer.alloc(16),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = (R.length * jdx) + idx + 1;\n        B = xor(A,\n                longToBigEndian(count));\n        B = Buffer.concat([B, R[idx], iv]);\n        var cipher = helpers.nodeCrypto.createDecipheriv(\"AES\" + size, key, iv);\n        B = cipher.update(B);\n\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  };\n\n  return helpers.setupFallback(node, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesKw = {};\n[\n  \"A128KW\",\n  \"A192KW\",\n  \"A256KW\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)KW/g.exec(alg)[1]);\n  aesKw[alg] = {\n    encrypt: kwEncryptFN(size),\n    decrypt: kwDecryptFN(size)\n  };\n});\n\nmodule.exports = aesKw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1rdy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDhFQUFjO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXVCOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtCQUErQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw4QkFBOEI7QUFDbkcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1rdy5qcz81YjVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9hZXMta3cuanMgLSBBRVMtS1cgS2V5LVdyYXBwaW5nXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBEYXRhQnVmZmVyID0gcmVxdWlyZShcIi4uL3V0aWwvZGF0YWJ1ZmZlci5qc1wiKTtcblxudmFyIEEwID0gQnVmZmVyLmZyb20oXCJhNmE2YTZhNmE2YTZhNmE2XCIsIFwiaGV4XCIpO1xuXG4vLyAjIyMgaGVscGVyc1xuZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gIHZhciByZXN1bHQgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgZm9yICh2YXIgaWR4ID0gMDsgbGVuID4gaWR4OyBpZHgrKykge1xuICAgIHJlc3VsdFtpZHhdID0gKGFbaWR4XSB8fCAwKSBeIChiW2lkeF0gfHwgMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc3BsaXQoaW5wdXQsIHNpemUpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpZHggPSAwOyBpbnB1dC5sZW5ndGggPiBpZHg7IGlkeCArPSBzaXplKSB7XG4gICAgb3V0cHV0LnB1c2goaW5wdXQuc2xpY2UoaWR4LCBpZHggKyBzaXplKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gbG9uZ1RvQmlnRW5kaWFuKGlucHV0KSB7XG4gIHZhciBoaSA9IE1hdGguZmxvb3IoaW5wdXQgLyA0Mjk0OTY3Mjk2KSxcbiAgICAgIGxvID0gaW5wdXQgJSA0Mjk0OTY3Mjk2O1xuICB2YXIgb3V0cHV0ID0gQnVmZmVyLmFsbG9jKDgpO1xuICBvdXRwdXRbMF0gPSAweGZmICYgKGhpID4+PiAyNCk7XG4gIG91dHB1dFsxXSA9IDB4ZmYgJiAoaGkgPj4+IDE2KTtcbiAgb3V0cHV0WzJdID0gMHhmZiAmIChoaSA+Pj4gOCk7XG4gIG91dHB1dFszXSA9IDB4ZmYgJiAoaGkgPj4+IDApO1xuICBvdXRwdXRbNF0gPSAweGZmICYgKGxvID4+PiAyNCk7XG4gIG91dHB1dFs1XSA9IDB4ZmYgJiAobG8gPj4+IDE2KTtcbiAgb3V0cHV0WzZdID0gMHhmZiAmIChsbyA+Pj4gOCk7XG4gIG91dHB1dFs3XSA9IDB4ZmYgJiAobG8gPj4+IDApO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBrd0VuY3J5cHRGTihzaXplKSB7XG4gIGZ1bmN0aW9uIGNvbW1vbkNoZWNrcyhrZXksIGRhdGEpIHtcbiAgICBpZiAoc2l6ZSAhPT0gKGtleS5sZW5ndGggPDwgMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IHNpemVcIik7XG4gICAgfVxuICAgIGlmICgwIDwgZGF0YS5sZW5ndGggJiYgMCAhPT0gKGRhdGEubGVuZ3RoICUgOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YSBsZW5ndGhcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjICdmYWxsYmFjaycgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIHBkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGNpcGhlclxuICAgIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlQ2lwaGVyKFwiQUVTXCIsIG5ldyBEYXRhQnVmZmVyKGtleSkpO1xuXG4gICAgLy8gc3BsaXQgaW5wdXQgaW50byBjaHVua3NcbiAgICB2YXIgUiA9IHNwbGl0KHBkYXRhLCA4KTtcbiAgICB2YXIgQSxcbiAgICAgICAgQixcbiAgICAgICAgY291bnQ7XG4gICAgQSA9IEEwO1xuICAgIGZvciAodmFyIGpkeCA9IDA7IDYgPiBqZHg7IGpkeCsrKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBSLmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgICAgY291bnQgPSAoUi5sZW5ndGggKiBqZHgpICsgaWR4ICsgMTtcbiAgICAgICAgQiA9IEJ1ZmZlci5jb25jYXQoW0EsIFJbaWR4XV0pO1xuICAgICAgICBjaXBoZXIuc3RhcnQoKTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZShuZXcgRGF0YUJ1ZmZlcihCKSk7XG4gICAgICAgIGNpcGhlci5maW5pc2goKTtcbiAgICAgICAgQiA9IEJ1ZmZlci5mcm9tKGNpcGhlci5vdXRwdXQuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG5cbiAgICAgICAgQSA9IHhvcihCLnNsaWNlKDAsIDgpLFxuICAgICAgICAgICAgICAgIGxvbmdUb0JpZ0VuZGlhbihjb3VudCkpO1xuICAgICAgICBSW2lkeF0gPSBCLnNsaWNlKDgsIDE2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgUiA9IFtBXS5jb25jYXQoUik7XG4gICAgdmFyIGNkYXRhID0gQnVmZmVyLmNvbmNhdChSKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IGNkYXRhXG4gICAgfSk7XG4gIH07XG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgcGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiQUVTLUtXXCJcbiAgICB9O1xuICAgIHZhciBwcm9taXNlID0gW1xuICAgICAgaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIHBkYXRhLCB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LCB0cnVlLCBbXCJzaWduXCJdKSxcbiAgICAgIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wid3JhcEtleVwiXSlcbiAgICBdO1xuICAgIHByb21pc2UgPSBQcm9taXNlLmFsbChwcm9taXNlKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by53cmFwS2V5KFwicmF3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzWzBdLCAvLyBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXNbMV0sIC8vIHdyYXBwaW5nS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGcpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIHZhciBub2RlID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBwZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICAvLyBzcGxpdCBpbnB1dCBpbnRvIGNodW5rc1xuICAgIHZhciBSID0gc3BsaXQocGRhdGEsIDgpLFxuICAgICAgICBpdiA9IEJ1ZmZlci5hbGxvYygxNik7XG4gICAgdmFyIEEsXG4gICAgICAgIEIsXG4gICAgICAgIGNvdW50O1xuICAgIEEgPSBBMDtcbiAgICBmb3IgKHZhciBqZHggPSAwOyA2ID4gamR4OyBqZHgrKykge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgUi5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgICAgIGNvdW50ID0gKFIubGVuZ3RoICogamR4KSArIGlkeCArIDE7XG4gICAgICAgIEIgPSBCdWZmZXIuY29uY2F0KFtBLCBSW2lkeF1dKTtcbiAgICAgICAgdmFyIGNpcGhlciA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVDaXBoZXJpdihcIkFFU1wiICsgc2l6ZSwga2V5LCBpdik7XG4gICAgICAgIEIgPSBjaXBoZXIudXBkYXRlKEIpO1xuXG4gICAgICAgIEEgPSB4b3IoQi5zbGljZSgwLCA4KSxcbiAgICAgICAgICAgICAgICBsb25nVG9CaWdFbmRpYW4oY291bnQpKTtcbiAgICAgICAgUltpZHhdID0gQi5zbGljZSg4LCAxNik7XG4gICAgICB9XG4gICAgfVxuICAgIFIgPSBbQV0uY29uY2F0KFIpO1xuICAgIHZhciBjZGF0YSA9IEJ1ZmZlci5jb25jYXQoUik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBjZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZSwgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5mdW5jdGlvbiBrd0RlY3J5cHRGTihzaXplKSB7XG4gIGZ1bmN0aW9uIGNvbW1vbkNoZWNrcyhrZXksIGRhdGEpIHtcbiAgICBpZiAoc2l6ZSAhPT0gKGtleS5sZW5ndGggPDwgMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IHNpemVcIik7XG4gICAgfVxuICAgIGlmICgwIDwgKGRhdGEubGVuZ3RoIC0gOCkgJiYgMCAhPT0gKGRhdGEubGVuZ3RoICUgOCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YSBsZW5ndGhcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjICdmYWxsYmFjaycgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIGNkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGNkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGNpcGhlclxuICAgIHZhciBjaXBoZXIgPSBmb3JnZS5jaXBoZXIuY3JlYXRlRGVjaXBoZXIoXCJBRVNcIiwgbmV3IERhdGFCdWZmZXIoa2V5KSk7XG5cbiAgICAvLyBwcmVwYXJlIGlucHV0c1xuICAgIHZhciBSID0gc3BsaXQoY2RhdGEsIDgpLFxuICAgICAgICBBLFxuICAgICAgICBCLFxuICAgICAgICBjb3VudDtcbiAgICBBID0gUlswXTtcbiAgICBSID0gUi5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBqZHggPSA1OyAwIDw9IGpkeDsgLS1qZHgpIHtcbiAgICAgIGZvciAodmFyIGlkeCA9IFIubGVuZ3RoIC0gMTsgMCA8PSBpZHg7IC0taWR4KSB7XG4gICAgICAgIGNvdW50ID0gKFIubGVuZ3RoICogamR4KSArIGlkeCArIDE7XG4gICAgICAgIEIgPSB4b3IoQSxcbiAgICAgICAgICAgICAgICBsb25nVG9CaWdFbmRpYW4oY291bnQpKTtcbiAgICAgICAgQiA9IEJ1ZmZlci5jb25jYXQoW0IsIFJbaWR4XV0pO1xuICAgICAgICBjaXBoZXIuc3RhcnQoKTtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZShuZXcgRGF0YUJ1ZmZlcihCKSk7XG4gICAgICAgIGNpcGhlci5maW5pc2goKTtcbiAgICAgICAgQiA9IEJ1ZmZlci5mcm9tKGNpcGhlci5vdXRwdXQuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG5cbiAgICAgICAgQSA9IEIuc2xpY2UoMCwgOCk7XG4gICAgICAgIFJbaWR4XSA9IEIuc2xpY2UoOCwgMTYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQS50b1N0cmluZygpICE9PSBBMC50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiZGVjcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgIH1cbiAgICB2YXIgcGRhdGEgPSBCdWZmZXIuY29uY2F0KFIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGRhdGEpO1xuICB9O1xuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIGNkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGNkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkFFUy1LV1wiXG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1widW53cmFwS2V5XCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnVud3JhcEtleShcInJhd1wiLCBjZGF0YSwga2V5LCBhbGcsIHtuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCJ9LCB0cnVlLCBbXCJzaWduXCJdKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgLy8gdW53cmFwcGVkIENyeXB0b0tleSAtLSBleHRyYWN0IHJhd1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmV4cG9ydEtleShcInJhd1wiLCByZXN1bHQpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgdmFyIG5vZGUgPSBmdW5jdGlvbihrZXksIGNkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGNkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIC8vIHByZXBhcmUgaW5wdXRzXG4gICAgdmFyIFIgPSBzcGxpdChjZGF0YSwgOCksXG4gICAgICAgIGl2ID0gQnVmZmVyLmFsbG9jKDE2KSxcbiAgICAgICAgQSxcbiAgICAgICAgQixcbiAgICAgICAgY291bnQ7XG4gICAgQSA9IFJbMF07XG4gICAgUiA9IFIuc2xpY2UoMSk7XG4gICAgZm9yICh2YXIgamR4ID0gNTsgMCA8PSBqZHg7IC0tamR4KSB7XG4gICAgICBmb3IgKHZhciBpZHggPSBSLmxlbmd0aCAtIDE7IDAgPD0gaWR4OyAtLWlkeCkge1xuICAgICAgICBjb3VudCA9IChSLmxlbmd0aCAqIGpkeCkgKyBpZHggKyAxO1xuICAgICAgICBCID0geG9yKEEsXG4gICAgICAgICAgICAgICAgbG9uZ1RvQmlnRW5kaWFuKGNvdW50KSk7XG4gICAgICAgIEIgPSBCdWZmZXIuY29uY2F0KFtCLCBSW2lkeF0sIGl2XSk7XG4gICAgICAgIHZhciBjaXBoZXIgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcIkFFU1wiICsgc2l6ZSwga2V5LCBpdik7XG4gICAgICAgIEIgPSBjaXBoZXIudXBkYXRlKEIpO1xuXG4gICAgICAgIEEgPSBCLnNsaWNlKDAsIDgpO1xuICAgICAgICBSW2lkeF0gPSBCLnNsaWNlKDgsIDE2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKEEudG9TdHJpbmcoKSAhPT0gQTAudG9TdHJpbmcoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImRlY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICB9XG4gICAgdmFyIHBkYXRhID0gQnVmZmVyLmNvbmNhdChSKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBkYXRhKTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGUsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZW5jcnlwdFxuLy8gKiBbbmFtZV0uZGVjcnlwdFxudmFyIGFlc0t3ID0ge307XG5bXG4gIFwiQTEyOEtXXCIsXG4gIFwiQTE5MktXXCIsXG4gIFwiQTI1NktXXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgdmFyIHNpemUgPSBwYXJzZUludCgvQShcXGQrKUtXL2cuZXhlYyhhbGcpWzFdKTtcbiAgYWVzS3dbYWxnXSA9IHtcbiAgICBlbmNyeXB0OiBrd0VuY3J5cHRGTihzaXplKSxcbiAgICBkZWNyeXB0OiBrd0RlY3J5cHRGTihzaXplKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWVzS3c7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/concat.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/concat.js - Concat Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\");\n\nfunction concatDeriveFn(name) {\n  name = name.replace(\"CONCAT-\", \"\");\n\n  // NOTE: no nodejs/webcrypto/fallback model, since ConcatKDF is\n  //       implemented using the SHA algorithms\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var keyLen = props.length,\n        hashLen = CONSTANTS.HASHLENGTH[name];\n    if (!keyLen) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    // setup otherInfo\n    if (!props.otherInfo) {\n      return Promise.reject(new Error(\"invalid otherInfo\"));\n    }\n    var otherInfo = props.otherInfo;\n\n    var op = sha[name].digest;\n    var N = Math.ceil(keyLen / hashLen),\n        idx = 0,\n        okm = [];\n    function step() {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      var T = Buffer.alloc(4 + key.length + otherInfo.length);\n      T.writeUInt32BE(idx, 0);\n      key.copy(T, 4);\n      otherInfo.copy(T, 4 + key.length);\n      return op(T).then(function(result) {\n        okm.push(result);\n        return step();\n      });\n    }\n\n    return step();\n  };\n\n  return fn;\n}\n\n// Public API\n// * [name].derive\nvar concat = {};\n[\n  \"CONCAT-SHA-1\",\n  \"CONCAT-SHA-256\",\n  \"CONCAT-SHA-384\",\n  \"CONCAT-SHA-512\"\n].forEach(function(name) {\n  concat[name] = {\n    derive: concatDeriveFn(name)\n  };\n});\n\nmodule.exports = concat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbmNhdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9jb25jYXQuanM/ZDAxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvY29uY2F0LmpzIC0gQ29uY2F0IEtleSBEZXJpdmF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpLFxuICAgIHNoYSA9IHJlcXVpcmUoXCIuL3NoYS5qc1wiKTtcblxuZnVuY3Rpb24gY29uY2F0RGVyaXZlRm4obmFtZSkge1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKFwiQ09OQ0FULVwiLCBcIlwiKTtcblxuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSBDb25jYXRLREYgaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIFNIQSBhbGdvcml0aG1zXG5cbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICBoYXNoTGVuID0gQ09OU1RBTlRTLkhBU0hMRU5HVEhbbmFtZV07XG4gICAgaWYgKCFrZXlMZW4pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBsZW5ndGhcIikpO1xuICAgIH1cblxuICAgIC8vIHNldHVwIG90aGVySW5mb1xuICAgIGlmICghcHJvcHMub3RoZXJJbmZvKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBvdGhlckluZm9cIikpO1xuICAgIH1cbiAgICB2YXIgb3RoZXJJbmZvID0gcHJvcHMub3RoZXJJbmZvO1xuXG4gICAgdmFyIG9wID0gc2hhW25hbWVdLmRpZ2VzdDtcbiAgICB2YXIgTiA9IE1hdGguY2VpbChrZXlMZW4gLyBoYXNoTGVuKSxcbiAgICAgICAgaWR4ID0gMCxcbiAgICAgICAgb2ttID0gW107XG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmIChOID09PSBpZHgrKykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChva20pLnNsaWNlKDAsIGtleUxlbik7XG4gICAgICB9XG5cbiAgICAgIHZhciBUID0gQnVmZmVyLmFsbG9jKDQgKyBrZXkubGVuZ3RoICsgb3RoZXJJbmZvLmxlbmd0aCk7XG4gICAgICBULndyaXRlVUludDMyQkUoaWR4LCAwKTtcbiAgICAgIGtleS5jb3B5KFQsIDQpO1xuICAgICAgb3RoZXJJbmZvLmNvcHkoVCwgNCArIGtleS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG9wKFQpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIG9rbS5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBzdGVwKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcCgpO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuLy8gUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZGVyaXZlXG52YXIgY29uY2F0ID0ge307XG5bXG4gIFwiQ09OQ0FULVNIQS0xXCIsXG4gIFwiQ09OQ0FULVNIQS0yNTZcIixcbiAgXCJDT05DQVQtU0hBLTM4NFwiLFxuICBcIkNPTkNBVC1TSEEtNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIGNvbmNhdFtuYW1lXSA9IHtcbiAgICBkZXJpdmU6IGNvbmNhdERlcml2ZUZuKG5hbWUpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25jYXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/*!\n * algorithms/constants.js - Constants used in Cryptographic Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nmodule.exports = {\n  CHUNK_SIZE: 1024,\n  HASHLENGTH: {\n    \"SHA-1\": 160,\n    \"SHA-256\": 256,\n    \"SHA-384\": 384,\n    \"SHA-512\": 512\n  },\n  ENCLENGTH: {\n    \"AES-128-CBC\": 128,\n    \"AES-192-CBC\": 192,\n    \"AES-256-CBC\": 256,\n    \"AES-128-KW\": 128,\n    \"AES-192-KW\": 192,\n    \"AES-256-KW\": 256\n  },\n  KEYLENGTH: {\n    \"A128CBC-HS256\": 256,\n    \"A192CBC-HS384\": 384,\n    \"A256CBC-HS512\": 512,\n    \"A128CBC+HS256\": 256,\n    \"A192CBC+HS384\": 384,\n    \"A256CBC+HS512\": 512,\n    \"A128GCM\": 128,\n    \"A192GCM\": 192,\n    \"A256GCM\": 256,\n    \"A128KW\": 128,\n    \"A192KW\": 192,\n    \"A256KW\": 256,\n    \"ECDH-ES+A128KW\": 128,\n    \"ECDH-ES+A192KW\": 192,\n    \"ECDH-ES+A256KW\": 256\n  },\n  NONCELENGTH: {\n    \"A128CBC-HS256\": 128,\n    \"A192CBC-HS384\": 128,\n    \"A256CBC-HS512\": 128,\n    \"A128CBC+HS256\": 128,\n    \"A192CBC+HS384\": 128,\n    \"A256CBC+HS512\": 128,\n    \"A128GCM\": 96,\n    \"A192GCM\": 96,\n    \"A256GCM\": 96\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9jb25zdGFudHMuanM/OGFiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvY29uc3RhbnRzLmpzIC0gQ29uc3RhbnRzIHVzZWQgaW4gQ3J5cHRvZ3JhcGhpYyBBbGdvcml0aG1zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cbiBcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENIVU5LX1NJWkU6IDEwMjQsXG4gIEhBU0hMRU5HVEg6IHtcbiAgICBcIlNIQS0xXCI6IDE2MCxcbiAgICBcIlNIQS0yNTZcIjogMjU2LFxuICAgIFwiU0hBLTM4NFwiOiAzODQsXG4gICAgXCJTSEEtNTEyXCI6IDUxMlxuICB9LFxuICBFTkNMRU5HVEg6IHtcbiAgICBcIkFFUy0xMjgtQ0JDXCI6IDEyOCxcbiAgICBcIkFFUy0xOTItQ0JDXCI6IDE5MixcbiAgICBcIkFFUy0yNTYtQ0JDXCI6IDI1NixcbiAgICBcIkFFUy0xMjgtS1dcIjogMTI4LFxuICAgIFwiQUVTLTE5Mi1LV1wiOiAxOTIsXG4gICAgXCJBRVMtMjU2LUtXXCI6IDI1NlxuICB9LFxuICBLRVlMRU5HVEg6IHtcbiAgICBcIkExMjhDQkMtSFMyNTZcIjogMjU2LFxuICAgIFwiQTE5MkNCQy1IUzM4NFwiOiAzODQsXG4gICAgXCJBMjU2Q0JDLUhTNTEyXCI6IDUxMixcbiAgICBcIkExMjhDQkMrSFMyNTZcIjogMjU2LFxuICAgIFwiQTE5MkNCQytIUzM4NFwiOiAzODQsXG4gICAgXCJBMjU2Q0JDK0hTNTEyXCI6IDUxMixcbiAgICBcIkExMjhHQ01cIjogMTI4LFxuICAgIFwiQTE5MkdDTVwiOiAxOTIsXG4gICAgXCJBMjU2R0NNXCI6IDI1NixcbiAgICBcIkExMjhLV1wiOiAxMjgsXG4gICAgXCJBMTkyS1dcIjogMTkyLFxuICAgIFwiQTI1NktXXCI6IDI1NixcbiAgICBcIkVDREgtRVMrQTEyOEtXXCI6IDEyOCxcbiAgICBcIkVDREgtRVMrQTE5MktXXCI6IDE5MixcbiAgICBcIkVDREgtRVMrQTI1NktXXCI6IDI1NlxuICB9LFxuICBOT05DRUxFTkdUSDoge1xuICAgIFwiQTEyOENCQy1IUzI1NlwiOiAxMjgsXG4gICAgXCJBMTkyQ0JDLUhTMzg0XCI6IDEyOCxcbiAgICBcIkEyNTZDQkMtSFM1MTJcIjogMTI4LFxuICAgIFwiQTEyOENCQytIUzI1NlwiOiAxMjgsXG4gICAgXCJBMTkyQ0JDK0hTMzg0XCI6IDEyOCxcbiAgICBcIkEyNTZDQkMrSFM1MTJcIjogMTI4LFxuICAgIFwiQTEyOEdDTVwiOiA5NixcbiAgICBcIkExOTJHQ01cIjogOTYsXG4gICAgXCJBMjU2R0NNXCI6IDk2XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/dir.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/dir.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n * algorithms/dir.js - Direct key mode\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nfunction dirEncryptFN(key) {\n  // NOTE: pdata unused\n  // NOTE: props unused\n  return Promise.resolve({\n    data: key,\n    once: true,\n    direct: true\n  });\n}\nfunction dirDecryptFN(key) {\n  // NOTE: pdata unused\n  // NOTE: props unused\n  return Promise.resolve(key);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar direct = {\n  dir: {\n    encrypt: dirEncryptFN,\n    decrypt: dirDecryptFN\n  }\n};\n\nmodule.exports = direct;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Rpci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Rpci5qcz8zMjY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9kaXIuanMgLSBEaXJlY3Qga2V5IG1vZGVcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGRpckVuY3J5cHRGTihrZXkpIHtcbiAgLy8gTk9URTogcGRhdGEgdW51c2VkXG4gIC8vIE5PVEU6IHByb3BzIHVudXNlZFxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICBkYXRhOiBrZXksXG4gICAgb25jZTogdHJ1ZSxcbiAgICBkaXJlY3Q6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBkaXJEZWNyeXB0Rk4oa2V5KSB7XG4gIC8vIE5PVEU6IHBkYXRhIHVudXNlZFxuICAvLyBOT1RFOiBwcm9wcyB1bnVzZWRcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZW5jcnlwdFxuLy8gKiBbbmFtZV0uZGVjcnlwdFxudmFyIGRpcmVjdCA9IHtcbiAgZGlyOiB7XG4gICAgZW5jcnlwdDogZGlyRW5jcnlwdEZOLFxuICAgIGRlY3J5cHQ6IGRpckRlY3J5cHRGTlxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpcmVjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/dir.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ec-util.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ec-util.js - Elliptic Curve Utility Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    ecc = __webpack_require__(/*! ../deps/ecc */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar EC_KEYSIZES = {\n  \"P-256\": 256,\n  \"P-384\": 384,\n  \"P-521\": 521\n};\n\nfunction convertToForge(key, isPublic) {\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"d\"];\n  parts = parts.map(function(f) {\n    return new forge.jsbn.BigInteger(key[f].toString(\"hex\"), 16);\n  });\n  // prefix with curve\n  parts = [key.crv].concat(parts);\n  var fn = isPublic ?\n           ecc.asPublicKey :\n           ecc.asPrivateKey;\n  return fn.apply(ecc, parts);\n}\n\nfunction convertToJWK(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"x\", \"y\", \"d\"];\n  parts.forEach(function(f) {\n    result[f] = util.base64url.encode(result[f]);\n  });\n\n  // remove potentially troublesome properties\n  delete result.key_ops;\n  delete result.use;\n  delete result.alg;\n\n  if (isPublic) {\n    delete result.d;\n  }\n\n  return result;\n}\n\nfunction convertToObj(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"d\"];\n  parts.forEach(function(f) {\n    // assume string if base64url-encoded\n    result[f] = util.asBuffer(result[f], \"base64url\");\n  });\n\n  return result;\n}\n\nvar UNCOMPRESSED = Buffer.from([0x04]);\nfunction convertToBuffer(key, isPublic) {\n  key = convertToObj(key, isPublic);\n  var result = isPublic ?\n               Buffer.concat([UNCOMPRESSED, key.x, key.y]) :\n               key.d;\n  return result;\n}\n\nfunction curveSize(crv) {\n  return EC_KEYSIZES[crv || \"\"] || NaN;\n}\n\nfunction curveNameToOid(crv) {\n  switch (crv) {\n    case \"P-256\":\n      return \"1.2.840.10045.3.1.7\";\n    case \"P-384\":\n      return \"1.3.132.0.34\";\n    case \"P-521\":\n      return \"1.3.132.0.35\";\n    default:\n      return null;\n  }\n}\n\nvar EC_OID = \"1.2.840.10045.2.1\";\nfunction convertToPEM(key, isPrivate) {\n  // curveName to OID\n  var oid = key.crv;\n  oid = curveNameToOid(oid);\n  oid = forge.asn1.oidToDer(oid);\n  // key as bytes\n  var type,\n      pub,\n      asn1;\n  if (isPrivate) {\n    type = \"EC PRIVATE KEY\";\n    pub = Buffer.concat([\n      Buffer.from([0x00, 0x04]),\n      key.x,\n      key.y\n    ]).toString(\"binary\");\n    key = key.d.toString(\"binary\");\n    asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, \"\\u0001\"),\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, key),\n      forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())\n      ]),\n      forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, pub)\n      ])\n    ]);\n  } else {\n    type = \"PUBLIC KEY\";\n    key = Buffer.concat([\n      Buffer.from([0x00, 0x04]),\n      key.x,\n      key.y\n    ]).toString(\"binary\");\n    asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, forge.asn1.oidToDer(EC_OID).bytes()),\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())\n      ]),\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, key)\n    ]);\n  }\n  asn1 = forge.asn1.toDer(asn1).bytes();\n  var pem = forge.pem.encode({\n    type: type,\n    body: asn1\n  });\n  return pem;\n}\n\n// Inspired by teifip/node-webtokens/blob/master/lib/ecdsa.js\nvar ERR_MSG = \"Could not extract parameters from DER signature\";\nfunction derToConcat(signature, size) {\n  var offset = 0;\n  if (signature[offset++] !== 0x30) {\n    throw new Error(ERR_MSG);\n  }\n  var seqLength = signature[offset++];\n  if (seqLength === 0x81) {\n    seqLength = signature[offset++];\n  }\n  if (seqLength > signature.length - offset) {\n    throw new Error(ERR_MSG);\n  }\n  if (signature[offset++] !== 0x02) {\n    throw new Error(ERR_MSG);\n  }\n  var rLength = signature[offset++];\n  if (rLength > signature.length - offset - 2) {\n    throw new Error(ERR_MSG);\n  }\n  if (rLength > size + 1) {\n    throw new Error(ERR_MSG);\n  }\n  var rOffset = offset;\n  offset += rLength;\n  if (signature[offset++] !== 0x02) {\n    throw new Error(ERR_MSG);\n  }\n  var sLength = signature[offset++];\n  if (sLength !== signature.length - offset) {\n    throw new Error(ERR_MSG);\n  }\n  if (sLength > size + 1) {\n    throw new Error(ERR_MSG);\n  }\n  var sOffset = offset;\n  offset += sLength;\n  if (offset !== signature.length) {\n    throw new Error(ERR_MSG);\n  }\n  var rPadding = size - rLength;\n  var sPadding = size - sLength;\n  var dst = Buffer.alloc(rPadding + rLength + sPadding + sLength);\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  var rPad = Math.max(-rPadding, 0);\n  signature.copy(dst, offset, rOffset + rPad, rOffset + rLength);\n  offset = size;\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  var sPad = Math.max(-sPadding, 0);\n  signature.copy(dst, offset, sOffset + sPad, sOffset + sLength);\n  return dst;\n}\n\nfunction countPadding(buf, start, stop) {\n  var padding = 0;\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n  var needsSign = buf[start + padding] >= 0x80;\n  if (needsSign) {\n    --padding;\n  }\n  return padding;\n}\n\nfunction concatToDer(signature, size) {\n  var rPadding = countPadding(signature, 0, size);\n  var sPadding = countPadding(signature, size, signature.length);\n  var rLength = size - rPadding;\n  var sLength = size - sPadding;\n  var rsBytes = rLength + sLength + 4;\n  var shortLength = rsBytes < 0x80;\n  var dst = Buffer.alloc((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = 0x30;\n  if (shortLength) {\n    dst[offset++] = rsBytes;\n  } else {\n    dst[offset++] = 0x81;\n    dst[offset++] = rsBytes & 0xFF;\n  }\n  dst[offset++] = 0x02;\n  dst[offset++] = rLength;\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, size);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, size);\n  }\n  dst[offset++] = 0x02;\n  dst[offset++] = sLength;\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, size);\n  } else {\n    signature.copy(dst, offset, size + sPadding);\n  }\n  return dst;\n}\n\nmodule.exports = {\n  convertToForge: convertToForge,\n  convertToJWK: convertToJWK,\n  convertToObj: convertToObj,\n  convertToBuffer: convertToBuffer,\n  curveSize: curveSize,\n  derToConcat: derToConcat,\n  concatToDer: concatToDer,\n  convertToPEM: convertToPEM,\n  EC_OID: EC_OID\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxVQUFVLG1CQUFPLENBQUMseUVBQWE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvZWMtdXRpbC5qcz9hNmFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9lYy11dGlsLmpzIC0gRWxsaXB0aWMgQ3VydmUgVXRpbGl0eSBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIiksXG4gICAgZWNjID0gcmVxdWlyZShcIi4uL2RlcHMvZWNjXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG52YXIgRUNfS0VZU0laRVMgPSB7XG4gIFwiUC0yNTZcIjogMjU2LFxuICBcIlAtMzg0XCI6IDM4NCxcbiAgXCJQLTUyMVwiOiA1MjFcbn07XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0ZvcmdlKGtleSwgaXNQdWJsaWMpIHtcbiAgdmFyIHBhcnRzID0gaXNQdWJsaWMgP1xuICAgICAgICAgICAgICBbXCJ4XCIsIFwieVwiXSA6XG4gICAgICAgICAgICAgIFtcImRcIl07XG4gIHBhcnRzID0gcGFydHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gbmV3IGZvcmdlLmpzYm4uQmlnSW50ZWdlcihrZXlbZl0udG9TdHJpbmcoXCJoZXhcIiksIDE2KTtcbiAgfSk7XG4gIC8vIHByZWZpeCB3aXRoIGN1cnZlXG4gIHBhcnRzID0gW2tleS5jcnZdLmNvbmNhdChwYXJ0cyk7XG4gIHZhciBmbiA9IGlzUHVibGljID9cbiAgICAgICAgICAgZWNjLmFzUHVibGljS2V5IDpcbiAgICAgICAgICAgZWNjLmFzUHJpdmF0ZUtleTtcbiAgcmV0dXJuIGZuLmFwcGx5KGVjYywgcGFydHMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9KV0soa2V5LCBpc1B1YmxpYykge1xuICB2YXIgcmVzdWx0ID0gY2xvbmUoa2V5KTtcbiAgdmFyIHBhcnRzID0gaXNQdWJsaWMgP1xuICAgICAgICAgICAgICBbXCJ4XCIsIFwieVwiXSA6XG4gICAgICAgICAgICAgIFtcInhcIiwgXCJ5XCIsIFwiZFwiXTtcbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgcmVzdWx0W2ZdID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdFtmXSk7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBwb3RlbnRpYWxseSB0cm91Ymxlc29tZSBwcm9wZXJ0aWVzXG4gIGRlbGV0ZSByZXN1bHQua2V5X29wcztcbiAgZGVsZXRlIHJlc3VsdC51c2U7XG4gIGRlbGV0ZSByZXN1bHQuYWxnO1xuXG4gIGlmIChpc1B1YmxpYykge1xuICAgIGRlbGV0ZSByZXN1bHQuZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb09iaihrZXksIGlzUHVibGljKSB7XG4gIHZhciByZXN1bHQgPSBjbG9uZShrZXkpO1xuICB2YXIgcGFydHMgPSBpc1B1YmxpYyA/XG4gICAgICAgICAgICAgIFtcInhcIiwgXCJ5XCJdIDpcbiAgICAgICAgICAgICAgW1wiZFwiXTtcbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgLy8gYXNzdW1lIHN0cmluZyBpZiBiYXNlNjR1cmwtZW5jb2RlZFxuICAgIHJlc3VsdFtmXSA9IHV0aWwuYXNCdWZmZXIocmVzdWx0W2ZdLCBcImJhc2U2NHVybFwiKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFVOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFsweDA0XSk7XG5mdW5jdGlvbiBjb252ZXJ0VG9CdWZmZXIoa2V5LCBpc1B1YmxpYykge1xuICBrZXkgPSBjb252ZXJ0VG9PYmooa2V5LCBpc1B1YmxpYyk7XG4gIHZhciByZXN1bHQgPSBpc1B1YmxpYyA/XG4gICAgICAgICAgICAgICBCdWZmZXIuY29uY2F0KFtVTkNPTVBSRVNTRUQsIGtleS54LCBrZXkueV0pIDpcbiAgICAgICAgICAgICAgIGtleS5kO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVNpemUoY3J2KSB7XG4gIHJldHVybiBFQ19LRVlTSVpFU1tjcnYgfHwgXCJcIl0gfHwgTmFOO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZU5hbWVUb09pZChjcnYpIHtcbiAgc3dpdGNoIChjcnYpIHtcbiAgICBjYXNlIFwiUC0yNTZcIjpcbiAgICAgIHJldHVybiBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIjtcbiAgICBjYXNlIFwiUC0zODRcIjpcbiAgICAgIHJldHVybiBcIjEuMy4xMzIuMC4zNFwiO1xuICAgIGNhc2UgXCJQLTUyMVwiOlxuICAgICAgcmV0dXJuIFwiMS4zLjEzMi4wLjM1XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBFQ19PSUQgPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XG5mdW5jdGlvbiBjb252ZXJ0VG9QRU0oa2V5LCBpc1ByaXZhdGUpIHtcbiAgLy8gY3VydmVOYW1lIHRvIE9JRFxuICB2YXIgb2lkID0ga2V5LmNydjtcbiAgb2lkID0gY3VydmVOYW1lVG9PaWQob2lkKTtcbiAgb2lkID0gZm9yZ2UuYXNuMS5vaWRUb0RlcihvaWQpO1xuICAvLyBrZXkgYXMgYnl0ZXNcbiAgdmFyIHR5cGUsXG4gICAgICBwdWIsXG4gICAgICBhc24xO1xuICBpZiAoaXNQcml2YXRlKSB7XG4gICAgdHlwZSA9IFwiRUMgUFJJVkFURSBLRVlcIjtcbiAgICBwdWIgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIEJ1ZmZlci5mcm9tKFsweDAwLCAweDA0XSksXG4gICAgICBrZXkueCxcbiAgICAgIGtleS55XG4gICAgXSkudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAga2V5ID0ga2V5LmQudG9TdHJpbmcoXCJiaW5hcnlcIik7XG4gICAgYXNuMSA9IGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsIHRydWUsIFtcbiAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuSU5URUdFUiwgZmFsc2UsIFwiXFx1MDAwMVwiKSxcbiAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuT0NURVRTVFJJTkcsIGZhbHNlLCBrZXkpLFxuICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAwLCB0cnVlLCBbXG4gICAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuT0lELCBmYWxzZSwgb2lkLmJ5dGVzKCkpXG4gICAgICBdKSxcbiAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQywgMSwgdHJ1ZSwgW1xuICAgICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIHB1YilcbiAgICAgIF0pXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IFwiUFVCTElDIEtFWVwiO1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20oWzB4MDAsIDB4MDRdKSxcbiAgICAgIGtleS54LFxuICAgICAga2V5LnlcbiAgICBdKS50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICBhc24xID0gZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLk9JRCwgZmFsc2UsIGZvcmdlLmFzbjEub2lkVG9EZXIoRUNfT0lEKS5ieXRlcygpKSxcbiAgICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5PSUQsIGZhbHNlLCBvaWQuYnl0ZXMoKSlcbiAgICAgIF0pLFxuICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsIGZhbHNlLCBrZXkpXG4gICAgXSk7XG4gIH1cbiAgYXNuMSA9IGZvcmdlLmFzbjEudG9EZXIoYXNuMSkuYnl0ZXMoKTtcbiAgdmFyIHBlbSA9IGZvcmdlLnBlbS5lbmNvZGUoe1xuICAgIHR5cGU6IHR5cGUsXG4gICAgYm9keTogYXNuMVxuICB9KTtcbiAgcmV0dXJuIHBlbTtcbn1cblxuLy8gSW5zcGlyZWQgYnkgdGVpZmlwL25vZGUtd2VidG9rZW5zL2Jsb2IvbWFzdGVyL2xpYi9lY2RzYS5qc1xudmFyIEVSUl9NU0cgPSBcIkNvdWxkIG5vdCBleHRyYWN0IHBhcmFtZXRlcnMgZnJvbSBERVIgc2lnbmF0dXJlXCI7XG5mdW5jdGlvbiBkZXJUb0NvbmNhdChzaWduYXR1cmUsIHNpemUpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIGlmIChzaWduYXR1cmVbb2Zmc2V0KytdICE9PSAweDMwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIHZhciBzZXFMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuICBpZiAoc2VxTGVuZ3RoID09PSAweDgxKSB7XG4gICAgc2VxTGVuZ3RoID0gc2lnbmF0dXJlW29mZnNldCsrXTtcbiAgfVxuICBpZiAoc2VxTGVuZ3RoID4gc2lnbmF0dXJlLmxlbmd0aCAtIG9mZnNldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICBpZiAoc2lnbmF0dXJlW29mZnNldCsrXSAhPT0gMHgwMikge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICB2YXIgckxlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG4gIGlmIChyTGVuZ3RoID4gc2lnbmF0dXJlLmxlbmd0aCAtIG9mZnNldCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgaWYgKHJMZW5ndGggPiBzaXplICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICB2YXIgck9mZnNldCA9IG9mZnNldDtcbiAgb2Zmc2V0ICs9IHJMZW5ndGg7XG4gIGlmIChzaWduYXR1cmVbb2Zmc2V0KytdICE9PSAweDAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIHZhciBzTGVuZ3RoID0gc2lnbmF0dXJlW29mZnNldCsrXTtcbiAgaWYgKHNMZW5ndGggIT09IHNpZ25hdHVyZS5sZW5ndGggLSBvZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgaWYgKHNMZW5ndGggPiBzaXplICsgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICB2YXIgc09mZnNldCA9IG9mZnNldDtcbiAgb2Zmc2V0ICs9IHNMZW5ndGg7XG4gIGlmIChvZmZzZXQgIT09IHNpZ25hdHVyZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgdmFyIHJQYWRkaW5nID0gc2l6ZSAtIHJMZW5ndGg7XG4gIHZhciBzUGFkZGluZyA9IHNpemUgLSBzTGVuZ3RoO1xuICB2YXIgZHN0ID0gQnVmZmVyLmFsbG9jKHJQYWRkaW5nICsgckxlbmd0aCArIHNQYWRkaW5nICsgc0xlbmd0aCk7XG4gIGZvciAob2Zmc2V0ID0gMDsgb2Zmc2V0IDwgclBhZGRpbmc7ICsrb2Zmc2V0KSB7XG4gICAgZHN0W29mZnNldF0gPSAwO1xuICB9XG4gIHZhciByUGFkID0gTWF0aC5tYXgoLXJQYWRkaW5nLCAwKTtcbiAgc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHJPZmZzZXQgKyByUGFkLCByT2Zmc2V0ICsgckxlbmd0aCk7XG4gIG9mZnNldCA9IHNpemU7XG4gIGZvciAodmFyIG8gPSBvZmZzZXQ7IG9mZnNldCA8IG8gKyBzUGFkZGluZzsgKytvZmZzZXQpIHtcbiAgICBkc3Rbb2Zmc2V0XSA9IDA7XG4gIH1cbiAgdmFyIHNQYWQgPSBNYXRoLm1heCgtc1BhZGRpbmcsIDApO1xuICBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgc09mZnNldCArIHNQYWQsIHNPZmZzZXQgKyBzTGVuZ3RoKTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuZnVuY3Rpb24gY291bnRQYWRkaW5nKGJ1Ziwgc3RhcnQsIHN0b3ApIHtcbiAgdmFyIHBhZGRpbmcgPSAwO1xuICB3aGlsZSAoc3RhcnQgKyBwYWRkaW5nIDwgc3RvcCAmJiBidWZbc3RhcnQgKyBwYWRkaW5nXSA9PT0gMCkge1xuICAgICsrcGFkZGluZztcbiAgfVxuICB2YXIgbmVlZHNTaWduID0gYnVmW3N0YXJ0ICsgcGFkZGluZ10gPj0gMHg4MDtcbiAgaWYgKG5lZWRzU2lnbikge1xuICAgIC0tcGFkZGluZztcbiAgfVxuICByZXR1cm4gcGFkZGluZztcbn1cblxuZnVuY3Rpb24gY29uY2F0VG9EZXIoc2lnbmF0dXJlLCBzaXplKSB7XG4gIHZhciByUGFkZGluZyA9IGNvdW50UGFkZGluZyhzaWduYXR1cmUsIDAsIHNpemUpO1xuICB2YXIgc1BhZGRpbmcgPSBjb3VudFBhZGRpbmcoc2lnbmF0dXJlLCBzaXplLCBzaWduYXR1cmUubGVuZ3RoKTtcbiAgdmFyIHJMZW5ndGggPSBzaXplIC0gclBhZGRpbmc7XG4gIHZhciBzTGVuZ3RoID0gc2l6ZSAtIHNQYWRkaW5nO1xuICB2YXIgcnNCeXRlcyA9IHJMZW5ndGggKyBzTGVuZ3RoICsgNDtcbiAgdmFyIHNob3J0TGVuZ3RoID0gcnNCeXRlcyA8IDB4ODA7XG4gIHZhciBkc3QgPSBCdWZmZXIuYWxsb2MoKHNob3J0TGVuZ3RoID8gMiA6IDMpICsgcnNCeXRlcyk7XG4gIHZhciBvZmZzZXQgPSAwO1xuICBkc3Rbb2Zmc2V0KytdID0gMHgzMDtcbiAgaWYgKHNob3J0TGVuZ3RoKSB7XG4gICAgZHN0W29mZnNldCsrXSA9IHJzQnl0ZXM7XG4gIH0gZWxzZSB7XG4gICAgZHN0W29mZnNldCsrXSA9IDB4ODE7XG4gICAgZHN0W29mZnNldCsrXSA9IHJzQnl0ZXMgJiAweEZGO1xuICB9XG4gIGRzdFtvZmZzZXQrK10gPSAweDAyO1xuICBkc3Rbb2Zmc2V0KytdID0gckxlbmd0aDtcbiAgaWYgKHJQYWRkaW5nIDwgMCkge1xuICAgIGRzdFtvZmZzZXQrK10gPSAwO1xuICAgIG9mZnNldCArPSBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgMCwgc2l6ZSk7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ICs9IHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCByUGFkZGluZywgc2l6ZSk7XG4gIH1cbiAgZHN0W29mZnNldCsrXSA9IDB4MDI7XG4gIGRzdFtvZmZzZXQrK10gPSBzTGVuZ3RoO1xuICBpZiAoc1BhZGRpbmcgPCAwKSB7XG4gICAgZHN0W29mZnNldCsrXSA9IDA7XG4gICAgc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHNpemUpO1xuICB9IGVsc2Uge1xuICAgIHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCBzaXplICsgc1BhZGRpbmcpO1xuICB9XG4gIHJldHVybiBkc3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb252ZXJ0VG9Gb3JnZTogY29udmVydFRvRm9yZ2UsXG4gIGNvbnZlcnRUb0pXSzogY29udmVydFRvSldLLFxuICBjb252ZXJ0VG9PYmo6IGNvbnZlcnRUb09iaixcbiAgY29udmVydFRvQnVmZmVyOiBjb252ZXJ0VG9CdWZmZXIsXG4gIGN1cnZlU2l6ZTogY3VydmVTaXplLFxuICBkZXJUb0NvbmNhdDogZGVyVG9Db25jYXQsXG4gIGNvbmNhdFRvRGVyOiBjb25jYXRUb0RlcixcbiAgY29udmVydFRvUEVNOiBjb252ZXJ0VG9QRU0sXG4gIEVDX09JRDogRUNfT0lEXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ecdh.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ecdh.js - Elliptic Curve Diffie-Hellman algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    ecUtil = __webpack_require__(/*! ./ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    hkdf = __webpack_require__(/*! ./hkdf.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\"),\n    concat = __webpack_require__(/*! ./concat.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\"),\n    aesKw = __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\");\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar omit = __webpack_require__(/*! lodash/omit */ \"(ssr)/./node_modules/lodash/omit.js\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"(ssr)/./node_modules/lodash/pick.js\");\n\nfunction idealHash(curve) {\n  switch (curve) {\n    case \"P-256\":\n      return \"SHA-256\";\n    case \"P-384\":\n      return \"SHA-384\";\n    case \"P-521\":\n      return \"SHA-512\";\n    default:\n      throw new Error(\"unsupported curve: \" + curve);\n  }\n}\n\n// ### Exported\nvar ecdh = module.exports = {};\n\n// ### Derivation algorithms\n// ### \"raw\" ECDH\nfunction ecdhDeriveFn() {\n  var alg = {\n    name: \"ECDH\"\n  };\n\n  var validatePublic = function(pk, form) {\n    var pubKey = pk && ecUtil.convertToForge(pk, true);\n    if (!pubKey || !pubKey.isValid()) {\n      return Promise.reject(new Error(\"invalid EC public key\"));\n    }\n\n    switch (form) {\n      case \"jwk\":\n        pubKey = ecUtil.convertToJWK(pk, true);\n        break;\n      case \"buffer\":\n        pubKey = ecUtil.convertToBuffer(pk, true);\n        break;\n    }\n    return Promise.resolve(pubKey);\n  }\n\n  // ### fallback implementation -- uses ecc + forge\n  var fallback = function(key, props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    // assume {key} is privateKey\n    // assume {props.public} is publicKey\n    var privKey = ecUtil.convertToForge(key, false);\n\n    var p = validatePublic(props.public, \"forge\");\n    p = p.then(function(pubKey) {\n      // {pubKey} is \"forge\"\n\n      var secret = privKey.computeSecret(pubKey);\n      if (keyLen) {\n        // truncate to requested key length\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n        secret = secret.slice(0, keyLen);\n      }\n\n      return secret;\n    });\n    return p;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, props) {\n    key = key || {};\n    props = props || {};\n\n    var keyLen = props.length || 0,\n        algParams = merge(clone(alg), {\n          namedCurve: key.crv\n        });\n\n    // assume {key} is privateKey\n    if (!keyLen) {\n      // calculate key length from private key size\n      keyLen = key.d.length;\n    }\n    var privKey = ecUtil.convertToJWK(key, false);\n    privKey = helpers.subtleCrypto.importKey(\"jwk\",\n                                             privKey,\n                                             algParams,\n                                             false,\n                                             [ \"deriveBits\" ]);\n\n    // assume {props.public} is publicKey\n    var pubKey = validatePublic(props.public, \"jwk\");\n    pubKey = pubKey.then(function(pubKey) {\n      // {pubKey} is \"jwk\"\n      return helpers.subtleCrypto.importKey(\"jwk\",\n                                            pubKey,\n                                            algParams,\n                                            false,\n                                            []);\n    });\n\n    var p = Promise.all([privKey, pubKey]);\n    p = p.then(function(keypair) {\n      var privKey = keypair[0],\n          pubKey = keypair[1];\n\n      var algParams = merge(clone(alg), {\n        public: pubKey\n      });\n      return helpers.subtleCrypto.deriveBits(algParams, privKey, keyLen * 8);\n    });\n    p = p.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return p;\n  };\n\n  var nodejs = function(key, props) {\n    if (\"function\" !== typeof helpers.nodeCrypto.createECDH) {\n      throw new Error(\"unsupported algorithm: ECDH\");\n    }\n\n    props = props || {};\n    var keyLen = props.length || 0;\n    var curve;\n    switch (key.crv) {\n      case \"P-256\":\n        curve = \"prime256v1\";\n        break;\n      case \"P-384\":\n        curve = \"secp384r1\";\n        break;\n      case \"P-521\":\n        curve = \"secp521r1\";\n        break;\n      default:\n        return Promise.reject(new Error(\"invalid curve: \" + curve));\n    }\n\n    // assume {key} is privateKey\n    // assume {props.public} is publicKey\n    var privKey = ecUtil.convertToBuffer(key, false);\n\n    var p = validatePublic(props.public, \"buffer\");\n    p = p.then(function(pubKey) {\n      // {pubKey} is \"buffer\"\n      var ecdh = helpers.nodeCrypto.createECDH(curve);\n      // dummy call so computeSecret doesn't fail\n      // ecdh.generateKeys();\n      ecdh.setPrivateKey(privKey);\n      var secret = ecdh.computeSecret(pubKey);\n      if (keyLen) {\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n        secret = secret.slice(0, keyLen);\n      }\n      return secret;\n    });\n    return p;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdhConcatDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var hash;\n    try {\n      hash = props.hash || idealHash(key.crv);\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"];\n    // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n    var promise = ecdh.ECDH.derive(key, pick(props, params));\n    // expand\n    promise = promise.then(function(shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return concat[\"CONCAT-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhHkdfDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var hash;\n    try {\n      hash = props.hash || idealHash(key.crv);\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"];\n    // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n    var promise = ecdh.ECDH.derive(key, pick(props, params));\n    // extract-and-expand\n    promise = promise.then(function(shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return hkdf[\"HKDF-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\n// ### Wrap/Unwrap algorithms\nfunction doEcdhesCommonDerive(privKey, pubKey, props) {\n  function prependLen(input) {\n    return Buffer.concat([\n      helpers.int32ToBuffer(input.length),\n      input\n    ]);\n  }\n\n  var algId = props.algorithm || \"\",\n      keyLen = CONSTANTS.KEYLENGTH[algId],\n      apu = util.asBuffer(props.apu || \"\", \"base64url\"),\n      apv = util.asBuffer(props.apv || \"\", \"base64url\");\n  var otherInfo = Buffer.concat([\n    prependLen(Buffer.from(algId, \"utf8\")),\n    prependLen(apu),\n    prependLen(apv),\n    helpers.int32ToBuffer(keyLen)\n  ]);\n\n  var params = {\n    public: pubKey,\n    length: keyLen / 8,\n    hash: \"SHA-256\",\n    otherInfo: otherInfo\n  };\n  return ecdh[\"ECDH-CONCAT\"].derive(privKey, params);\n}\n\nfunction ecdhesDirEncryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, pdata, props) {\n    props = props || {};\n\n    // {props.epk} is private\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, false);\n\n    // {key} is public\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n    var spk = ecUtil.convertToObj(key, true);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      return {\n        data: shared,\n        once: true,\n        direct: true\n      };\n    });\n    return promise;\n  };\n\n  return fn;\n}\nfunction ecdhesDirDecryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, cdata, props) {\n    props = props || {};\n\n    // {props.epk} is public\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, true);\n\n    // {key} is private\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n    var spk = ecUtil.convertToObj(key, false);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      return shared;\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwEncryptFn(wrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, pdata, props) {\n    props = props || {};\n\n    // {props.epk} is private\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, false);\n\n    // {key} is public\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n    var spk = ecUtil.convertToObj(key, true);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      // wrap provided key with ECDH shared\n      return wrap(shared, pdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwDecryptFn(unwrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, cdata, props) {\n    props = props || {};\n\n    // {props.epk} is public\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, true);\n\n    // {key} is private\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n    var spk = ecUtil.convertToObj(key, false);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      // unwrap provided key with ECDH shared\n      return unwrap(shared, cdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\n// ### Public API\n// * [name].derive\n[\n  \"ECDH\",\n  \"ECDH-HKDF\",\n  \"ECDH-CONCAT\"\n].forEach(function(name) {\n  var kdf = /^ECDH(?:-(\\w+))?$/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n  switch (kdf || \"\") {\n    case \"CONCAT\":\n      op.derive = ecdhConcatDeriveFn();\n      break;\n    case \"HKDF\":\n      op.derive = ecdhHkdfDeriveFn();\n      break;\n    case \"\":\n      op.derive = ecdhDeriveFn();\n      break;\n    default:\n      op.derive = null;\n  }\n});\n\n// * [name].encrypt\n// * [name].decrypt\n[\n  \"ECDH-ES\",\n  \"ECDH-ES+A128KW\",\n  \"ECDH-ES+A192KW\",\n  \"ECDH-ES+A256KW\"\n].forEach(function(name) {\n  var kw = /^ECDH-ES(?:\\+(.+))?/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n  if (!kw) {\n    op.encrypt = ecdhesDirEncryptFn();\n    op.decrypt = ecdhesDirDecryptFn();\n  } else {\n    kw = aesKw[kw];\n    if (kw) {\n      op.encrypt = ecdhesKwEncryptFn(kw.encrypt);\n      op.decrypt = ecdhesKwDecryptFn(kw.decrypt);\n    } else {\n      op.ecrypt = op.decrypt = null;\n    }\n  }\n});\n//*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZGguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx1RUFBZTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLDhFQUFjO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyx3RUFBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsNEVBQWE7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFhO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBZ0I7O0FBRXhDLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLHdEQUFhOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLGNBQWM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLFVBQVUsUUFBUTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxjQUFjO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsS0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZGguanM/MThlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvZWNkaC5qcyAtIEVsbGlwdGljIEN1cnZlIERpZmZpZS1IZWxsbWFuIGFsZ29yaXRobXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBlY1V0aWwgPSByZXF1aXJlKFwiLi9lYy11dGlsLmpzXCIpLFxuICAgIGhrZGYgPSByZXF1aXJlKFwiLi9oa2RmLmpzXCIpLFxuICAgIGNvbmNhdCA9IHJlcXVpcmUoXCIuL2NvbmNhdC5qc1wiKSxcbiAgICBhZXNLdyA9IHJlcXVpcmUoXCIuL2Flcy1rdy5qc1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIik7XG52YXIgb21pdCA9IHJlcXVpcmUoXCJsb2Rhc2gvb21pdFwiKTtcbnZhciBwaWNrID0gcmVxdWlyZShcImxvZGFzaC9waWNrXCIpO1xuXG5mdW5jdGlvbiBpZGVhbEhhc2goY3VydmUpIHtcbiAgc3dpdGNoIChjdXJ2ZSkge1xuICAgIGNhc2UgXCJQLTI1NlwiOlxuICAgICAgcmV0dXJuIFwiU0hBLTI1NlwiO1xuICAgIGNhc2UgXCJQLTM4NFwiOlxuICAgICAgcmV0dXJuIFwiU0hBLTM4NFwiO1xuICAgIGNhc2UgXCJQLTUyMVwiOlxuICAgICAgcmV0dXJuIFwiU0hBLTUxMlwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBjdXJ2ZTogXCIgKyBjdXJ2ZSk7XG4gIH1cbn1cblxuLy8gIyMjIEV4cG9ydGVkXG52YXIgZWNkaCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vICMjIyBEZXJpdmF0aW9uIGFsZ29yaXRobXNcbi8vICMjIyBcInJhd1wiIEVDREhcbmZ1bmN0aW9uIGVjZGhEZXJpdmVGbigpIHtcbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBcIkVDREhcIlxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZVB1YmxpYyA9IGZ1bmN0aW9uKHBrLCBmb3JtKSB7XG4gICAgdmFyIHB1YktleSA9IHBrICYmIGVjVXRpbC5jb252ZXJ0VG9Gb3JnZShwaywgdHJ1ZSk7XG4gICAgaWYgKCFwdWJLZXkgfHwgIXB1YktleS5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIEVDIHB1YmxpYyBrZXlcIikpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZm9ybSkge1xuICAgICAgY2FzZSBcImp3a1wiOlxuICAgICAgICBwdWJLZXkgPSBlY1V0aWwuY29udmVydFRvSldLKHBrLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYnVmZmVyXCI6XG4gICAgICAgIHB1YktleSA9IGVjVXRpbC5jb252ZXJ0VG9CdWZmZXIocGssIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwdWJLZXkpO1xuICB9XG5cbiAgLy8gIyMjIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZWNjICsgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCB8fCAwO1xuICAgIC8vIGFzc3VtZSB7a2V5fSBpcyBwcml2YXRlS2V5XG4gICAgLy8gYXNzdW1lIHtwcm9wcy5wdWJsaWN9IGlzIHB1YmxpY0tleVxuICAgIHZhciBwcml2S2V5ID0gZWNVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgZmFsc2UpO1xuXG4gICAgdmFyIHAgPSB2YWxpZGF0ZVB1YmxpYyhwcm9wcy5wdWJsaWMsIFwiZm9yZ2VcIik7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihwdWJLZXkpIHtcbiAgICAgIC8vIHtwdWJLZXl9IGlzIFwiZm9yZ2VcIlxuXG4gICAgICB2YXIgc2VjcmV0ID0gcHJpdktleS5jb21wdXRlU2VjcmV0KHB1YktleSk7XG4gICAgICBpZiAoa2V5TGVuKSB7XG4gICAgICAgIC8vIHRydW5jYXRlIHRvIHJlcXVlc3RlZCBrZXkgbGVuZ3RoXG4gICAgICAgIGlmIChzZWNyZXQubGVuZ3RoIDwga2V5TGVuKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImtleSBsZW5ndGggdG9vIGxhcmdlOiBcIiArIGtleUxlbikpO1xuICAgICAgICB9XG4gICAgICAgIHNlY3JldCA9IHNlY3JldC5zbGljZSgwLCBrZXlMZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VjcmV0O1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgLy8gVE9ETzogY2FjaGUgQ3J5cHRvS2V5IHNvb25lclxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIGtleSA9IGtleSB8fCB7fTtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCB8fCAwLFxuICAgICAgICBhbGdQYXJhbXMgPSBtZXJnZShjbG9uZShhbGcpLCB7XG4gICAgICAgICAgbmFtZWRDdXJ2ZToga2V5LmNydlxuICAgICAgICB9KTtcblxuICAgIC8vIGFzc3VtZSB7a2V5fSBpcyBwcml2YXRlS2V5XG4gICAgaWYgKCFrZXlMZW4pIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBrZXkgbGVuZ3RoIGZyb20gcHJpdmF0ZSBrZXkgc2l6ZVxuICAgICAga2V5TGVuID0ga2V5LmQubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgcHJpdktleSA9IGVjVXRpbC5jb252ZXJ0VG9KV0soa2V5LCBmYWxzZSk7XG4gICAgcHJpdktleSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdktleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZ1BhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBcImRlcml2ZUJpdHNcIiBdKTtcblxuICAgIC8vIGFzc3VtZSB7cHJvcHMucHVibGljfSBpcyBwdWJsaWNLZXlcbiAgICB2YXIgcHViS2V5ID0gdmFsaWRhdGVQdWJsaWMocHJvcHMucHVibGljLCBcImp3a1wiKTtcbiAgICBwdWJLZXkgPSBwdWJLZXkudGhlbihmdW5jdGlvbihwdWJLZXkpIHtcbiAgICAgIC8vIHtwdWJLZXl9IGlzIFwiandrXCJcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHViS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGdQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSk7XG4gICAgfSk7XG5cbiAgICB2YXIgcCA9IFByb21pc2UuYWxsKFtwcml2S2V5LCBwdWJLZXldKTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGtleXBhaXIpIHtcbiAgICAgIHZhciBwcml2S2V5ID0ga2V5cGFpclswXSxcbiAgICAgICAgICBwdWJLZXkgPSBrZXlwYWlyWzFdO1xuXG4gICAgICB2YXIgYWxnUGFyYW1zID0gbWVyZ2UoY2xvbmUoYWxnKSwge1xuICAgICAgICBwdWJsaWM6IHB1YktleVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZGVyaXZlQml0cyhhbGdQYXJhbXMsIHByaXZLZXksIGtleUxlbiAqIDgpO1xuICAgIH0pO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlRUNESCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBFQ0RIXCIpO1xuICAgIH1cblxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCB8fCAwO1xuICAgIHZhciBjdXJ2ZTtcbiAgICBzd2l0Y2ggKGtleS5jcnYpIHtcbiAgICAgIGNhc2UgXCJQLTI1NlwiOlxuICAgICAgICBjdXJ2ZSA9IFwicHJpbWUyNTZ2MVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQLTM4NFwiOlxuICAgICAgICBjdXJ2ZSA9IFwic2VjcDM4NHIxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlAtNTIxXCI6XG4gICAgICAgIGN1cnZlID0gXCJzZWNwNTIxcjFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZTogXCIgKyBjdXJ2ZSkpO1xuICAgIH1cblxuICAgIC8vIGFzc3VtZSB7a2V5fSBpcyBwcml2YXRlS2V5XG4gICAgLy8gYXNzdW1lIHtwcm9wcy5wdWJsaWN9IGlzIHB1YmxpY0tleVxuICAgIHZhciBwcml2S2V5ID0gZWNVdGlsLmNvbnZlcnRUb0J1ZmZlcihrZXksIGZhbHNlKTtcblxuICAgIHZhciBwID0gdmFsaWRhdGVQdWJsaWMocHJvcHMucHVibGljLCBcImJ1ZmZlclwiKTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHB1YktleSkge1xuICAgICAgLy8ge3B1YktleX0gaXMgXCJidWZmZXJcIlxuICAgICAgdmFyIGVjZGggPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlRUNESChjdXJ2ZSk7XG4gICAgICAvLyBkdW1teSBjYWxsIHNvIGNvbXB1dGVTZWNyZXQgZG9lc24ndCBmYWlsXG4gICAgICAvLyBlY2RoLmdlbmVyYXRlS2V5cygpO1xuICAgICAgZWNkaC5zZXRQcml2YXRlS2V5KHByaXZLZXkpO1xuICAgICAgdmFyIHNlY3JldCA9IGVjZGguY29tcHV0ZVNlY3JldChwdWJLZXkpO1xuICAgICAgaWYgKGtleUxlbikge1xuICAgICAgICBpZiAoc2VjcmV0Lmxlbmd0aCA8IGtleUxlbikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJrZXkgbGVuZ3RoIHRvbyBsYXJnZTogXCIgKyBrZXlMZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBzZWNyZXQgPSBzZWNyZXQuc2xpY2UoMCwga2V5TGVuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWNyZXQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBlY2RoQ29uY2F0RGVyaXZlRm4oKSB7XG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgYWxnb3JpdGhtIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIG90aGVyIHByaW1pdGl2ZXNcblxuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBoYXNoO1xuICAgIHRyeSB7XG4gICAgICBoYXNoID0gcHJvcHMuaGFzaCB8fCBpZGVhbEhhc2goa2V5LmNydik7XG4gICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBoYXNoOiBcIiArIGhhc2gpO1xuICAgICAgfVxuICAgICAgaGFzaC50b1VwcGVyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBbXCJwdWJsaWNcIl07XG4gICAgLy8gZGVyaXZlIHNoYXJlZCBzZWNyZXRcbiAgICAvLyBOT1RFOiB3aGl0ZWxpc3QgaXRlbXMgZnJvbSB7cHJvcHN9IGZvciBFQ0RIXG4gICAgdmFyIHByb21pc2UgPSBlY2RoLkVDREguZGVyaXZlKGtleSwgcGljayhwcm9wcywgcGFyYW1zKSk7XG4gICAgLy8gZXhwYW5kXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaGFyZWQpIHtcbiAgICAgIC8vIE5PVEU6IGJsYWNrbGlzdCBpdGVtcyBmcm9tIHtwcm9wc30gZm9yIEVDREhcbiAgICAgIHJldHVybiBjb25jYXRbXCJDT05DQVQtXCIgKyBoYXNoXS5kZXJpdmUoc2hhcmVkLCBvbWl0KHByb3BzLCBwYXJhbXMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGVjZGhIa2RmRGVyaXZlRm4oKSB7XG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgYWxnb3JpdGhtIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIG90aGVyIHByaW1pdGl2ZXNcblxuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBoYXNoO1xuICAgIHRyeSB7XG4gICAgICBoYXNoID0gcHJvcHMuaGFzaCB8fCBpZGVhbEhhc2goa2V5LmNydik7XG4gICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBoYXNoOiBcIiArIGhhc2gpO1xuICAgICAgfVxuICAgICAgaGFzaC50b1VwcGVyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXgpO1xuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSBbXCJwdWJsaWNcIl07XG4gICAgLy8gZGVyaXZlIHNoYXJlZCBzZWNyZXRcbiAgICAvLyBOT1RFOiB3aGl0ZWxpc3QgaXRlbXMgZnJvbSB7cHJvcHN9IGZvciBFQ0RIXG4gICAgdmFyIHByb21pc2UgPSBlY2RoLkVDREguZGVyaXZlKGtleSwgcGljayhwcm9wcywgcGFyYW1zKSk7XG4gICAgLy8gZXh0cmFjdC1hbmQtZXhwYW5kXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaGFyZWQpIHtcbiAgICAgIC8vIE5PVEU6IGJsYWNrbGlzdCBpdGVtcyBmcm9tIHtwcm9wc30gZm9yIEVDREhcbiAgICAgIHJldHVybiBoa2RmW1wiSEtERi1cIiArIGhhc2hdLmRlcml2ZShzaGFyZWQsIG9taXQocHJvcHMsIHBhcmFtcykpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuLy8gIyMjIFdyYXAvVW53cmFwIGFsZ29yaXRobXNcbmZ1bmN0aW9uIGRvRWNkaGVzQ29tbW9uRGVyaXZlKHByaXZLZXksIHB1YktleSwgcHJvcHMpIHtcbiAgZnVuY3Rpb24gcHJlcGVuZExlbihpbnB1dCkge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGhlbHBlcnMuaW50MzJUb0J1ZmZlcihpbnB1dC5sZW5ndGgpLFxuICAgICAgaW5wdXRcbiAgICBdKTtcbiAgfVxuXG4gIHZhciBhbGdJZCA9IHByb3BzLmFsZ29yaXRobSB8fCBcIlwiLFxuICAgICAga2V5TGVuID0gQ09OU1RBTlRTLktFWUxFTkdUSFthbGdJZF0sXG4gICAgICBhcHUgPSB1dGlsLmFzQnVmZmVyKHByb3BzLmFwdSB8fCBcIlwiLCBcImJhc2U2NHVybFwiKSxcbiAgICAgIGFwdiA9IHV0aWwuYXNCdWZmZXIocHJvcHMuYXB2IHx8IFwiXCIsIFwiYmFzZTY0dXJsXCIpO1xuICB2YXIgb3RoZXJJbmZvID0gQnVmZmVyLmNvbmNhdChbXG4gICAgcHJlcGVuZExlbihCdWZmZXIuZnJvbShhbGdJZCwgXCJ1dGY4XCIpKSxcbiAgICBwcmVwZW5kTGVuKGFwdSksXG4gICAgcHJlcGVuZExlbihhcHYpLFxuICAgIGhlbHBlcnMuaW50MzJUb0J1ZmZlcihrZXlMZW4pXG4gIF0pO1xuXG4gIHZhciBwYXJhbXMgPSB7XG4gICAgcHVibGljOiBwdWJLZXksXG4gICAgbGVuZ3RoOiBrZXlMZW4gLyA4LFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiLFxuICAgIG90aGVySW5mbzogb3RoZXJJbmZvXG4gIH07XG4gIHJldHVybiBlY2RoW1wiRUNESC1DT05DQVRcIl0uZGVyaXZlKHByaXZLZXksIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGVjZGhlc0RpckVuY3J5cHRGbigpIHtcbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBhbGdvcml0aG0gaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgb3RoZXIgcHJpbWl0aXZlc1xuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICAvLyB7cHJvcHMuZXBrfSBpcyBwcml2YXRlXG4gICAgaWYgKCFwcm9wcy5lcGsgfHwgIXByb3BzLmVway5kKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBlcGhlbWVyYWwgcHJpdmF0ZSBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgZXBrID0gZWNVdGlsLmNvbnZlcnRUb09iaihwcm9wcy5lcGssIGZhbHNlKTtcblxuICAgIC8vIHtrZXl9IGlzIHB1YmxpY1xuICAgIGlmICgha2V5IHx8ICFrZXkueCB8fCAha2V5LnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIHN0YXRpYyBwdWJsaWMga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIHNwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmooa2V5LCB0cnVlKTtcblxuICAgIC8vIGRlcml2ZSBFQ0RIIHNoYXJlZFxuICAgIHZhciBwcm9taXNlID0gZG9FY2RoZXNDb21tb25EZXJpdmUoZXBrLCBzcGssIHtcbiAgICAgIGFsZ29yaXRobTogcHJvcHMuZW5jLFxuICAgICAgYXB1OiBwcm9wcy5hcHUsXG4gICAgICBhcHY6IHByb3BzLmFwdlxuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2hhcmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBzaGFyZWQsXG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIGRpcmVjdDogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5mdW5jdGlvbiBlY2RoZXNEaXJEZWNyeXB0Rm4oKSB7XG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgYWxnb3JpdGhtIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIG90aGVyIHByaW1pdGl2ZXNcbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgLy8ge3Byb3BzLmVwa30gaXMgcHVibGljXG4gICAgaWYgKCFwcm9wcy5lcGsgfHwgIXByb3BzLmVway54IHx8ICFwcm9wcy5lcGsueSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3NpbmcgZXBoZW1lcmFsIHB1YmxpYyBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgZXBrID0gZWNVdGlsLmNvbnZlcnRUb09iaihwcm9wcy5lcGssIHRydWUpO1xuXG4gICAgLy8ge2tleX0gaXMgcHJpdmF0ZVxuICAgIGlmICgha2V5IHx8ICFrZXkuZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3Npbmcgc3RhdGljIHByaXZhdGUga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIHNwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmooa2V5LCBmYWxzZSk7XG5cbiAgICAvLyBkZXJpdmUgRUNESCBzaGFyZWRcbiAgICB2YXIgcHJvbWlzZSA9IGRvRWNkaGVzQ29tbW9uRGVyaXZlKHNwaywgZXBrLCB7XG4gICAgICBhbGdvcml0aG06IHByb3BzLmVuYyxcbiAgICAgIGFwdTogcHJvcHMuYXB1LFxuICAgICAgYXB2OiBwcm9wcy5hcHZcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNoYXJlZCkge1xuICAgICAgcmV0dXJuIHNoYXJlZDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGVjZGhlc0t3RW5jcnlwdEZuKHdyYXApIHtcbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBhbGdvcml0aG0gaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgb3RoZXIgcHJpbWl0aXZlc1xuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICAvLyB7cHJvcHMuZXBrfSBpcyBwcml2YXRlXG4gICAgaWYgKCFwcm9wcy5lcGsgfHwgIXByb3BzLmVway5kKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBlcGhlbWVyYWwgcHJpdmF0ZSBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgZXBrID0gZWNVdGlsLmNvbnZlcnRUb09iaihwcm9wcy5lcGssIGZhbHNlKTtcblxuICAgIC8vIHtrZXl9IGlzIHB1YmxpY1xuICAgIGlmICgha2V5IHx8ICFrZXkueCB8fCAha2V5LnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIHN0YXRpYyBwdWJsaWMga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIHNwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmooa2V5LCB0cnVlKTtcblxuICAgIC8vIGRlcml2ZSBFQ0RIIHNoYXJlZFxuICAgIHZhciBwcm9taXNlID0gZG9FY2RoZXNDb21tb25EZXJpdmUoZXBrLCBzcGssIHtcbiAgICAgIGFsZ29yaXRobTogcHJvcHMuYWxnLFxuICAgICAgYXB1OiBwcm9wcy5hcHUsXG4gICAgICBhcHY6IHByb3BzLmFwdlxuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2hhcmVkKSB7XG4gICAgICAvLyB3cmFwIHByb3ZpZGVkIGtleSB3aXRoIEVDREggc2hhcmVkXG4gICAgICByZXR1cm4gd3JhcChzaGFyZWQsIHBkYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbmZ1bmN0aW9uIGVjZGhlc0t3RGVjcnlwdEZuKHVud3JhcCkge1xuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIGFsZ29yaXRobSBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyBvdGhlciBwcmltaXRpdmVzXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIC8vIHtwcm9wcy5lcGt9IGlzIHB1YmxpY1xuICAgIGlmICghcHJvcHMuZXBrIHx8ICFwcm9wcy5lcGsueCB8fCAhcHJvcHMuZXBrLnkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIGVwaGVtZXJhbCBwdWJsaWMga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIGVwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmoocHJvcHMuZXBrLCB0cnVlKTtcblxuICAgIC8vIHtrZXl9IGlzIHByaXZhdGVcbiAgICBpZiAoIWtleSB8fCAha2V5LmQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIHN0YXRpYyBwcml2YXRlIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBzcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKGtleSwgZmFsc2UpO1xuXG4gICAgLy8gZGVyaXZlIEVDREggc2hhcmVkXG4gICAgdmFyIHByb21pc2UgPSBkb0VjZGhlc0NvbW1vbkRlcml2ZShzcGssIGVwaywge1xuICAgICAgYWxnb3JpdGhtOiBwcm9wcy5hbGcsXG4gICAgICBhcHU6IHByb3BzLmFwdSxcbiAgICAgIGFwdjogcHJvcHMuYXB2XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaGFyZWQpIHtcbiAgICAgIC8vIHVud3JhcCBwcm92aWRlZCBrZXkgd2l0aCBFQ0RIIHNoYXJlZFxuICAgICAgcmV0dXJuIHVud3JhcChzaGFyZWQsIGNkYXRhKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gZm47XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5kZXJpdmVcbltcbiAgXCJFQ0RIXCIsXG4gIFwiRUNESC1IS0RGXCIsXG4gIFwiRUNESC1DT05DQVRcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGtkZiA9IC9eRUNESCg/Oi0oXFx3KykpPyQvZy5leGVjKG5hbWUgfHwgXCJcIilbMV07XG4gIHZhciBvcCA9IGVjZGhbbmFtZV0gPSBlY2RoW25hbWVdIHx8IHt9O1xuICBzd2l0Y2ggKGtkZiB8fCBcIlwiKSB7XG4gICAgY2FzZSBcIkNPTkNBVFwiOlxuICAgICAgb3AuZGVyaXZlID0gZWNkaENvbmNhdERlcml2ZUZuKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSEtERlwiOlxuICAgICAgb3AuZGVyaXZlID0gZWNkaEhrZGZEZXJpdmVGbigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlwiOlxuICAgICAgb3AuZGVyaXZlID0gZWNkaERlcml2ZUZuKCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgb3AuZGVyaXZlID0gbnVsbDtcbiAgfVxufSk7XG5cbi8vICogW25hbWVdLmVuY3J5cHRcbi8vICogW25hbWVdLmRlY3J5cHRcbltcbiAgXCJFQ0RILUVTXCIsXG4gIFwiRUNESC1FUytBMTI4S1dcIixcbiAgXCJFQ0RILUVTK0ExOTJLV1wiLFxuICBcIkVDREgtRVMrQTI1NktXXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBrdyA9IC9eRUNESC1FUyg/OlxcKyguKykpPy9nLmV4ZWMobmFtZSB8fCBcIlwiKVsxXTtcbiAgdmFyIG9wID0gZWNkaFtuYW1lXSA9IGVjZGhbbmFtZV0gfHwge307XG4gIGlmICgha3cpIHtcbiAgICBvcC5lbmNyeXB0ID0gZWNkaGVzRGlyRW5jcnlwdEZuKCk7XG4gICAgb3AuZGVjcnlwdCA9IGVjZGhlc0RpckRlY3J5cHRGbigpO1xuICB9IGVsc2Uge1xuICAgIGt3ID0gYWVzS3dba3ddO1xuICAgIGlmIChrdykge1xuICAgICAgb3AuZW5jcnlwdCA9IGVjZGhlc0t3RW5jcnlwdEZuKGt3LmVuY3J5cHQpO1xuICAgICAgb3AuZGVjcnlwdCA9IGVjZGhlc0t3RGVjcnlwdEZuKGt3LmRlY3J5cHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcC5lY3J5cHQgPSBvcC5kZWNyeXB0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn0pO1xuLy8qL1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ecdsa.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar ecUtil = __webpack_require__(/*! ./ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n    case \"SHA-384\":\n      return \"P-384\";\n    case \"SHA-512\":\n      return \"P-521\";\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, false);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // sign hash\n    promise = promise.then(function(result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, false);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [ \"sign\" ]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createSign(nodeHash));\n      promise = promise.then(function (sign) {\n        sign.update(pdata);\n        return sign;\n      });\n\n      var size;\n\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      promise = promise.then(function (sign) {\n        return ecUtil.derToConcat(sign.sign(ecUtil.convertToPEM(key, true)), size);\n      });\n\n      promise = promise.then(function (result) {\n        return {\n          data: pdata,\n          mac: result\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, true);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // verify hash\n    promise = promise.then(function(result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata, mac /* , props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, true);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata, mac /* , props */) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var size;\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createVerify(nodeHash));\n      promise = promise.then(function (verify) {\n        verify.update(pdata);\n        verify.end();\n        return verify.verify(ecUtil.convertToPEM(key, false), ecUtil.concatToDer(mac, size));\n      });\n      promise = promise.then(function (result) {\n        if (!result) {\n          throw new Error(\"verification failed\");\n        }\n        return {\n          data: pdata,\n          mac: mac,\n          valid: true\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\nvar ecdsa = {};\n\n// * [name].sign\n// * [name].verify\n[\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n].forEach(function(name) {\n  var hash = name.replace(/ES(\\d+)/g, function(m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\n\nmodule.exports = ecdsa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZHNhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLDhFQUFjO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9lY2RzYS5qcz8wMjIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9lY2RzYS5qcyAtIEVsbGlwdGljIEN1cnZlIERpZ2l0aWFsIFNpZ25hdHVyZSBBbGdvcml0aG1zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZWNVdGlsID0gcmVxdWlyZShcIi4vZWMtdXRpbC5qc1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBzaGEgPSByZXF1aXJlKFwiLi9zaGEuanNcIik7XG5cbmZ1bmN0aW9uIGlkZWFsQ3VydmUoaGFzaCkge1xuICBzd2l0Y2ggKGhhc2gpIHtcbiAgICBjYXNlIFwiU0hBLTI1NlwiOlxuICAgICAgcmV0dXJuIFwiUC0yNTZcIjtcbiAgICBjYXNlIFwiU0hBLTM4NFwiOlxuICAgICAgcmV0dXJuIFwiUC0zODRcIjtcbiAgICBjYXNlIFwiU0hBLTUxMlwiOlxuICAgICAgcmV0dXJuIFwiUC01MjFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgaGFzaDogXCIgKyBoYXNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlY2RzYVNpZ25GTihoYXNoKSB7XG4gIHZhciBjdXJ2ZSA9IGlkZWFsQ3VydmUoaGFzaCk7XG5cbiAgLy8gIyMjIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSAvKiwgcHJvcHMgKi8pIHtcbiAgICBpZiAoY3VydmUgIT09IGtleS5jcnYpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlXCIpKTtcbiAgICB9XG4gICAgdmFyIHBrID0gZWNVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgZmFsc2UpO1xuXG4gICAgdmFyIHByb21pc2U7XG4gICAgLy8gZ2VuZXJhdGUgaGFzaFxuICAgIHByb21pc2UgPSBzaGFbaGFzaF0uZGlnZXN0KHBkYXRhKTtcbiAgICAvLyBzaWduIGhhc2hcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gcGsuc2lnbihyZXN1bHQpO1xuICAgICAgcmVzdWx0ID0gQnVmZmVyLmNvbmNhdChbcmVzdWx0LnIsIHJlc3VsdC5zXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiByZXN1bHRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0byBBUEkgaW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEgLyosIHByb3BzICovKSB7XG4gICAgaWYgKGN1cnZlICE9PSBrZXkuY3J2KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZVwiKSk7XG4gICAgfVxuICAgIHZhciBwayA9IGVjVXRpbC5jb252ZXJ0VG9KV0soa2V5LCBmYWxzZSk7XG5cbiAgICB2YXIgcHJvbWlzZTtcbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgbmFtZWRDdXJ2ZTogcGsuY3J2LFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBoYXNoXG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFwic2lnblwiIF0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uc2lnbihhbGcsIGtleSwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogcmVzdWx0XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanM7XG4gIHZhciBub2RlSGFzaCA9IGhhc2gudG9Mb3dlckNhc2UoKS5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcbiAgaWYgKGhlbHBlcnMubm9kZUNyeXB0byAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uZ2V0SGFzaGVzKCkuaW5kZXhPZihub2RlSGFzaCkgPiAtMSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIGlmIChjdXJ2ZSAhPT0ga2V5LmNydikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlU2lnbihub2RlSGFzaCkpO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoc2lnbikge1xuICAgICAgICBzaWduLnVwZGF0ZShwZGF0YSk7XG4gICAgICAgIHJldHVybiBzaWduO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzaXplO1xuXG4gICAgICBzd2l0Y2ggKG5vZGVIYXNoLnNsaWNlKC0zKSkge1xuICAgICAgICBjYXNlIFwiMzg0XCI6XG4gICAgICAgICAgc2l6ZSA9IDQ4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiNTEyXCI6XG4gICAgICAgICAgc2l6ZSA9IDY2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHNpemUgPSAzMjtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoc2lnbikge1xuICAgICAgICByZXR1cm4gZWNVdGlsLmRlclRvQ29uY2F0KHNpZ24uc2lnbihlY1V0aWwuY29udmVydFRvUEVNKGtleSwgdHJ1ZSkpLCBzaXplKTtcbiAgICAgIH0pO1xuXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgICBtYWM6IHJlc3VsdFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGVjZHNhVmVyaWZ5Rk4oaGFzaCkge1xuICB2YXIgY3VydmUgPSBpZGVhbEN1cnZlKGhhc2gpO1xuXG4gIC8vICMjIyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYyAvKiwgcHJvcHMgKi8pIHtcbiAgICBpZiAoY3VydmUgIT09IGtleS5jcnYpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlXCIpKTtcbiAgICB9XG4gICAgdmFyIHBrID0gZWNVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgdHJ1ZSk7XG5cbiAgICB2YXIgcHJvbWlzZTtcbiAgICAvLyBnZW5lcmF0ZSBoYXNoXG4gICAgcHJvbWlzZSA9IHNoYVtoYXNoXS5kaWdlc3QocGRhdGEpO1xuICAgIC8vIHZlcmlmeSBoYXNoXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHZhciBsZW4gPSBtYWMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBycyA9IHtcbiAgICAgICAgcjogbWFjLnNsaWNlKDAsIGxlbiksXG4gICAgICAgIHM6IG1hYy5zbGljZShsZW4pXG4gICAgICB9O1xuICAgICAgaWYgKCFway52ZXJpZnkocmVzdWx0LCBycykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvIEFQSSBpbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjIC8qICwgcHJvcHMgKi8pIHtcbiAgICBpZiAoY3VydmUgIT09IGtleS5jcnYpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlXCIpKTtcbiAgICB9XG4gICAgdmFyIHBrID0gZWNVdGlsLmNvbnZlcnRUb0pXSyhrZXksIHRydWUpO1xuXG4gICAgdmFyIHByb21pc2U7XG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiRUNEU0FcIixcbiAgICAgIG5hbWVkQ3VydmU6IHBrLmNydixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogaGFzaFxuICAgICAgfVxuICAgIH07XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widmVyaWZ5XCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnZlcmlmeShhbGcsIGtleSwgbWFjLCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcztcbiAgdmFyIG5vZGVIYXNoID0gaGFzaC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xuICBpZiAoaGVscGVycy5ub2RlQ3J5cHRvICYmIGhlbHBlcnMubm9kZUNyeXB0by5nZXRIYXNoZXMoKS5pbmRleE9mKG5vZGVIYXNoKSA+IC0xKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjIC8qICwgcHJvcHMgKi8pIHtcbiAgICAgIGlmIChjdXJ2ZSAhPT0ga2V5LmNydikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBjdXJ2ZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaXplO1xuICAgICAgc3dpdGNoIChub2RlSGFzaC5zbGljZSgtMykpIHtcbiAgICAgICAgY2FzZSBcIjM4NFwiOlxuICAgICAgICAgIHNpemUgPSA0ODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjUxMlwiOlxuICAgICAgICAgIHNpemUgPSA2NjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzaXplID0gMzI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlVmVyaWZ5KG5vZGVIYXNoKSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2ZXJpZnkpIHtcbiAgICAgICAgdmVyaWZ5LnVwZGF0ZShwZGF0YSk7XG4gICAgICAgIHZlcmlmeS5lbmQoKTtcbiAgICAgICAgcmV0dXJuIHZlcmlmeS52ZXJpZnkoZWNVdGlsLmNvbnZlcnRUb1BFTShrZXksIGZhbHNlKSwgZWNVdGlsLmNvbmNhdFRvRGVyKG1hYywgc2l6ZSkpO1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxudmFyIGVjZHNhID0ge307XG5cbi8vICogW25hbWVdLnNpZ25cbi8vICogW25hbWVdLnZlcmlmeVxuW1xuICBcIkVTMjU2XCIsXG4gIFwiRVMzODRcIixcbiAgXCJFUzUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaGFzaCA9IG5hbWUucmVwbGFjZSgvRVMoXFxkKykvZywgZnVuY3Rpb24obSwgc2l6ZSkge1xuICAgIHJldHVybiBcIlNIQS1cIiArIHNpemU7XG4gIH0pO1xuICBlY2RzYVtuYW1lXSA9IHtcbiAgICBzaWduOiBlY2RzYVNpZ25GTihoYXNoKSxcbiAgICB2ZXJpZnk6IGVjZHNhVmVyaWZ5Rk4oaGFzaClcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVjZHNhO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/helpers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * algorithms/helpers.js - Internal functions and fields used in Cryptographic\n * Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nif (typeof Promise === \"undefined\") {\n  (__webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\").polyfill)();\n}\n\n// ###\nexports.int32ToBuffer = function(v, b) {\n  b = b || Buffer.alloc(4);\n  b[0] = (v >>> 24) & 0xff;\n  b[1] = (v >>> 16) & 0xff;\n  b[2] = (v >>> 8) & 0xff;\n  b[3] = v & 0xff;\n  return b;\n};\n\nvar MAX_INT32 = Math.pow(2, 32);\nexports.int64ToBuffer = function(v, b) {\n  b = b || Buffer.alloc(8);\n  var hi = Math.floor(v / MAX_INT32),\n      lo = v % MAX_INT32;\n  hi = exports.int32ToBuffer(hi);\n  lo = exports.int32ToBuffer(lo);\n  b = Buffer.concat([hi, lo]);\n  return b;\n};\n\n// ### crypto and DOMException in browsers ###\n/* global crypto:false, DOMException:false */\n\nfunction getCryptoSubtle() {\n  if (\"undefined\" !== typeof crypto) {\n    if (\"undefined\" !== typeof crypto.subtle) {\n      return crypto.subtle;\n    }\n  }\n\n  return undefined;\n}\nfunction getCryptoNodeJS() {\n  var crypto;\n  try {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n  } catch (err) {\n    return undefined;\n  }\n\n  if (!Object.keys(crypto).length) {\n    // treat empty the same as missing\n    return undefined;\n  }\n\n  return crypto;\n}\n\nvar supported = {};\nObject.defineProperty(exports, \"subtleCrypto\", ({\n  get: function() {\n    var result;\n\n    if (\"subtleCrypto\" in supported) {\n      result = supported.subtleCrypto;\n    } else {\n      result = supported.subtleCrypto = getCryptoSubtle();\n    }\n\n    return result;\n  },\n  enumerable: true\n}));\nObject.defineProperty(exports, \"nodeCrypto\", ({\n  get: function() {\n    var result;\n\n    if (\"nodeCrypto\" in supported) {\n      result = supported.nodeCrypto;\n    } else {\n      result = supported.nodeCrypto = getCryptoNodeJS();\n    }\n\n    return result;\n  },\n  enumerable: true\n}));\n\nexports.setupFallback = function(nodejs, webcrypto, fallback) {\n  var impl;\n\n  if (nodejs && exports.nodeCrypto) {\n    impl = function main() {\n      var args = arguments,\n          promise;\n\n      function check(err) {\n        if (0 === err.message.indexOf(\"unsupported algorithm:\")) {\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n        return Promise.reject(err);\n      }\n\n      try {\n        promise = Promise.resolve(nodejs.apply(null, args));\n      } catch(err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else if (webcrypto && exports.subtleCrypto) {\n    impl = function main() {\n      var args = arguments,\n         promise;\n\n      function check(err) {\n        if (err.code === DOMException.NOT_SUPPORTED_ERR ||\n            // Firefox rejects some operations erroneously complaining about inputs\n            err.message === \"Only ArrayBuffer and ArrayBufferView objects can be passed as CryptoOperationData\" ||\n            // MS Edge rejects with not an Error\n            !(err instanceof Error)) {\n          // not actually supported -- always use fallback\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n       return Promise.reject(err);\n      }\n\n      try {\n        promise = webcrypto.apply(null, args);\n        promise = promise.catch(check);\n      } catch(err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else {\n    impl = fallback;\n  }\n\n  return impl;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxFQUFFLHlHQUErQjtBQUNqQzs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsRUFBQzs7QUFFRixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvaGVscGVycy5qcz9kYzRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9oZWxwZXJzLmpzIC0gSW50ZXJuYWwgZnVuY3Rpb25zIGFuZCBmaWVsZHMgdXNlZCBpbiBDcnlwdG9ncmFwaGljXG4gKiBBbGdvcml0aG1zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mIFByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgcmVxdWlyZShcImVzNi1wcm9taXNlXCIpLnBvbHlmaWxsKCk7XG59XG5cbi8vICMjI1xuZXhwb3J0cy5pbnQzMlRvQnVmZmVyID0gZnVuY3Rpb24odiwgYikge1xuICBiID0gYiB8fCBCdWZmZXIuYWxsb2MoNCk7XG4gIGJbMF0gPSAodiA+Pj4gMjQpICYgMHhmZjtcbiAgYlsxXSA9ICh2ID4+PiAxNikgJiAweGZmO1xuICBiWzJdID0gKHYgPj4+IDgpICYgMHhmZjtcbiAgYlszXSA9IHYgJiAweGZmO1xuICByZXR1cm4gYjtcbn07XG5cbnZhciBNQVhfSU5UMzIgPSBNYXRoLnBvdygyLCAzMik7XG5leHBvcnRzLmludDY0VG9CdWZmZXIgPSBmdW5jdGlvbih2LCBiKSB7XG4gIGIgPSBiIHx8IEJ1ZmZlci5hbGxvYyg4KTtcbiAgdmFyIGhpID0gTWF0aC5mbG9vcih2IC8gTUFYX0lOVDMyKSxcbiAgICAgIGxvID0gdiAlIE1BWF9JTlQzMjtcbiAgaGkgPSBleHBvcnRzLmludDMyVG9CdWZmZXIoaGkpO1xuICBsbyA9IGV4cG9ydHMuaW50MzJUb0J1ZmZlcihsbyk7XG4gIGIgPSBCdWZmZXIuY29uY2F0KFtoaSwgbG9dKTtcbiAgcmV0dXJuIGI7XG59O1xuXG4vLyAjIyMgY3J5cHRvIGFuZCBET01FeGNlcHRpb24gaW4gYnJvd3NlcnMgIyMjXG4vKiBnbG9iYWwgY3J5cHRvOmZhbHNlLCBET01FeGNlcHRpb246ZmFsc2UgKi9cblxuZnVuY3Rpb24gZ2V0Q3J5cHRvU3VidGxlKCkge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGNyeXB0bykge1xuICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY3J5cHRvLnN1YnRsZSkge1xuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldENyeXB0b05vZGVKUygpIHtcbiAgdmFyIGNyeXB0bztcbiAgdHJ5IHtcbiAgICBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cyhjcnlwdG8pLmxlbmd0aCkge1xuICAgIC8vIHRyZWF0IGVtcHR5IHRoZSBzYW1lIGFzIG1pc3NpbmdcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0bztcbn1cblxudmFyIHN1cHBvcnRlZCA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3VidGxlQ3J5cHRvXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKFwic3VidGxlQ3J5cHRvXCIgaW4gc3VwcG9ydGVkKSB7XG4gICAgICByZXN1bHQgPSBzdXBwb3J0ZWQuc3VidGxlQ3J5cHRvO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBzdXBwb3J0ZWQuc3VidGxlQ3J5cHRvID0gZ2V0Q3J5cHRvU3VidGxlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub2RlQ3J5cHRvXCIsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKFwibm9kZUNyeXB0b1wiIGluIHN1cHBvcnRlZCkge1xuICAgICAgcmVzdWx0ID0gc3VwcG9ydGVkLm5vZGVDcnlwdG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHN1cHBvcnRlZC5ub2RlQ3J5cHRvID0gZ2V0Q3J5cHRvTm9kZUpTKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuc2V0dXBGYWxsYmFjayA9IGZ1bmN0aW9uKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjaykge1xuICB2YXIgaW1wbDtcblxuICBpZiAobm9kZWpzICYmIGV4cG9ydHMubm9kZUNyeXB0bykge1xuICAgIGltcGwgPSBmdW5jdGlvbiBtYWluKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgZnVuY3Rpb24gY2hlY2soZXJyKSB7XG4gICAgICAgIGlmICgwID09PSBlcnIubWVzc2FnZS5pbmRleE9mKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOlwiKSkge1xuICAgICAgICAgIGltcGwgPSBmYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gaW1wbC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG5vZGVqcy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBwcm9taXNlID0gY2hlY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh3ZWJjcnlwdG8gJiYgZXhwb3J0cy5zdWJ0bGVDcnlwdG8pIHtcbiAgICBpbXBsID0gZnVuY3Rpb24gbWFpbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgcHJvbWlzZTtcblxuICAgICAgZnVuY3Rpb24gY2hlY2soZXJyKSB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gRE9NRXhjZXB0aW9uLk5PVF9TVVBQT1JURURfRVJSIHx8XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJlamVjdHMgc29tZSBvcGVyYXRpb25zIGVycm9uZW91c2x5IGNvbXBsYWluaW5nIGFib3V0IGlucHV0c1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiT25seSBBcnJheUJ1ZmZlciBhbmQgQXJyYXlCdWZmZXJWaWV3IG9iamVjdHMgY2FuIGJlIHBhc3NlZCBhcyBDcnlwdG9PcGVyYXRpb25EYXRhXCIgfHxcbiAgICAgICAgICAgIC8vIE1TIEVkZ2UgcmVqZWN0cyB3aXRoIG5vdCBhbiBFcnJvclxuICAgICAgICAgICAgIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAvLyBub3QgYWN0dWFsbHkgc3VwcG9ydGVkIC0tIGFsd2F5cyB1c2UgZmFsbGJhY2tcbiAgICAgICAgICBpbXBsID0gZmFsbGJhY2s7XG4gICAgICAgICAgcmV0dXJuIGltcGwuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwcm9taXNlID0gd2ViY3J5cHRvLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5jYXRjaChjaGVjayk7XG4gICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBwcm9taXNlID0gY2hlY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbXBsID0gZmFsbGJhY2s7XG4gIH1cblxuICByZXR1cm4gaW1wbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/hkdf.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/hkdf.js - HMAC-based Extract-and-Expand Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    hmac = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\");\n\nfunction hkdfDeriveFn(name) {\n  var hash = name.replace(\"HKDF-\", \"\"),\n      op = name.replace(\"HKDF-SHA-\", \"HS\");\n\n  // NOTE: no nodejs/webcrypto/fallback model, since this HKDF is\n  //       implemented using the HMAC algorithms\n\n  var fn = function(key, props) {\n    var hashLen = CONSTANTS.HASHLENGTH[hash] / 8;\n\n    if (\"string\" === typeof op) {\n      op = hmac[op].sign;\n    }\n\n    // prepare options\n    props = props || {};\n    var salt = props.salt;\n    if (!salt || 0 === salt.length) {\n      salt = Buffer.alloc(hashLen);\n    }\n    var info = props.info || Buffer.alloc(0);\n    var keyLen = props.length || hashLen;\n\n    var promise;\n\n    // Setup Expansion\n    var N = Math.ceil(keyLen / hashLen),\n        okm = [],\n        idx = 0;\n    function expand(key, T) {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      if (!T) {\n        T = Buffer.alloc(0);\n      }\n      T = Buffer.concat([T, info, Buffer.from([idx])]);\n      T = op(key, T);\n      T = T.then(function(result) {\n        T = result.mac;\n        okm.push(T);\n\n        return expand(key, T);\n      });\n      return T;\n    }\n\n    // Step 1: Extract\n    promise = op(salt, key, { length: salt.length * 8 });\n    promise = promise.then(function(result) {\n      // Step 2: Expand\n      return expand(result.mac);\n    });\n\n    return promise;\n  };\n\n  return fn;\n}\n\n// Public API\n// * [name].derive\nvar hkdf = {};\n[\n  \"HKDF-SHA-1\",\n  \"HKDF-SHA-256\",\n  \"HKDF-SHA-384\",\n  \"HKDF-SHA-512\"\n].forEach(function(name) {\n  hkdf[name] = {\n    derive: hkdfDeriveFn(name)\n  };\n});\n\nmodule.exports = hkdf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hrZGYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFnQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsd0VBQVc7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9oa2RmLmpzPzVmMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2hrZGYuanMgLSBITUFDLWJhc2VkIEV4dHJhY3QtYW5kLUV4cGFuZCBLZXkgRGVyaXZhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKSxcbiAgICBobWFjID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKTtcblxuZnVuY3Rpb24gaGtkZkRlcml2ZUZuKG5hbWUpIHtcbiAgdmFyIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJIS0RGLVwiLCBcIlwiKSxcbiAgICAgIG9wID0gbmFtZS5yZXBsYWNlKFwiSEtERi1TSEEtXCIsIFwiSFNcIik7XG5cbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBIS0RGIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIHRoZSBITUFDIGFsZ29yaXRobXNcblxuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgdmFyIGhhc2hMZW4gPSBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSAvIDg7XG5cbiAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wKSB7XG4gICAgICBvcCA9IGhtYWNbb3BdLnNpZ247XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBvcHRpb25zXG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICB2YXIgc2FsdCA9IHByb3BzLnNhbHQ7XG4gICAgaWYgKCFzYWx0IHx8IDAgPT09IHNhbHQubGVuZ3RoKSB7XG4gICAgICBzYWx0ID0gQnVmZmVyLmFsbG9jKGhhc2hMZW4pO1xuICAgIH1cbiAgICB2YXIgaW5mbyA9IHByb3BzLmluZm8gfHwgQnVmZmVyLmFsbG9jKDApO1xuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGggfHwgaGFzaExlbjtcblxuICAgIHZhciBwcm9taXNlO1xuXG4gICAgLy8gU2V0dXAgRXhwYW5zaW9uXG4gICAgdmFyIE4gPSBNYXRoLmNlaWwoa2V5TGVuIC8gaGFzaExlbiksXG4gICAgICAgIG9rbSA9IFtdLFxuICAgICAgICBpZHggPSAwO1xuICAgIGZ1bmN0aW9uIGV4cGFuZChrZXksIFQpIHtcbiAgICAgIGlmIChOID09PSBpZHgrKykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChva20pLnNsaWNlKDAsIGtleUxlbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghVCkge1xuICAgICAgICBUID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgfVxuICAgICAgVCA9IEJ1ZmZlci5jb25jYXQoW1QsIGluZm8sIEJ1ZmZlci5mcm9tKFtpZHhdKV0pO1xuICAgICAgVCA9IG9wKGtleSwgVCk7XG4gICAgICBUID0gVC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBUID0gcmVzdWx0Lm1hYztcbiAgICAgICAgb2ttLnB1c2goVCk7XG5cbiAgICAgICAgcmV0dXJuIGV4cGFuZChrZXksIFQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gVDtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDE6IEV4dHJhY3RcbiAgICBwcm9taXNlID0gb3Aoc2FsdCwga2V5LCB7IGxlbmd0aDogc2FsdC5sZW5ndGggKiA4IH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAvLyBTdGVwIDI6IEV4cGFuZFxuICAgICAgcmV0dXJuIGV4cGFuZChyZXN1bHQubWFjKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuLy8gUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZGVyaXZlXG52YXIgaGtkZiA9IHt9O1xuW1xuICBcIkhLREYtU0hBLTFcIixcbiAgXCJIS0RGLVNIQS0yNTZcIixcbiAgXCJIS0RGLVNIQS0zODRcIixcbiAgXCJIS0RGLVNIQS01MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgaGtkZltuYW1lXSA9IHtcbiAgICBkZXJpdmU6IGhrZGZEZXJpdmVGbihuYW1lKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaGtkZjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/hmac.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/hmac.js - HMAC-based \"signatures\"\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\");\n\nfunction hmacSignFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function checkKeyLength(len, key) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    if (len > key.length) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    return Promise.resolve(key);\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata, props) {\n    props = props || {};\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      var sig = forge.hmac.create();\n      sig.start(md, key.toString(\"binary\"));\n      sig.update(pdata.toString(\"binary\"));\n      sig = Buffer.from(sig.digest().bytes(), \"binary\");\n\n      return {\n        data: pdata,\n        mac: sig\n      }\n    });\n    return promise;\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, props) {\n    props = props || {};\n\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      return helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n    });\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(key, pdata, props) {\n    props = props || {};\n\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      var hmac = helpers.nodeCrypto.createHmac(md, key);\n      hmac.update(pdata);\n\n      var sig = hmac.digest();\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction hmacVerifyFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function compare(len, expected, actual) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    var valid = true;\n    for (var idx = 0; len > idx; idx++) {\n      valid = valid && (expected[idx] === actual[idx]);\n    }\n    return valid;\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var vrfy = forge.hmac.create();\n    vrfy.start(md, new DataBuffer(key));\n    vrfy.update(pdata.toString(\"binary\"));\n    vrfy = Buffer.from(vrfy.digest().bytes(), \"binary\");\n\n    if (compare(props.length, mac, vrfy)) {\n      return Promise.resolve({\n        data: pdata,\n        mac: mac,\n        valid: true\n      });\n    } else {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n  };\n\n  var webcrypto = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    if (props.length) {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.sign(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var sig = Buffer.from(result);\n        return compare(props.length, mac, sig);\n      });\n    } else {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"verify\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n      });\n    }\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verifaction failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var hmac = helpers.nodeCrypto.createHmac(md, key);\n    hmac.update(pdata);\n\n    var sig = hmac.digest();\n    if (!compare(props.length, mac, sig)) {\n      throw new Error(\"verification failed\");\n    }\n    return {\n      data: pdata,\n      mac: sig,\n      valid: true\n    };\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].sign\n// * [name].verify\nvar hmac = {};\n[\n  \"HS1\",\n  \"HS256\",\n  \"HS384\",\n  \"HS512\"\n].forEach(function(alg) {\n  hmac[alg] = {\n    sign: hmacSignFN(alg),\n    verify: hmacVerifyFN(alg)\n  };\n});\n\nmodule.exports = hmac;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2htYWMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXVCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyw4RUFBYzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvaG1hYy5qcz9kNDUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9obWFjLmpzIC0gSE1BQy1iYXNlZCBcInNpZ25hdHVyZXNcIlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIERhdGFCdWZmZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9kYXRhYnVmZmVyLmpzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpO1xuXG5mdW5jdGlvbiBobWFjU2lnbkZOKG5hbWUpIHtcbiAgdmFyIG1kID0gbmFtZS5yZXBsYWNlKFwiSFNcIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJIU1wiLCBcIlNIQS1cIik7XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXlMZW5ndGgobGVuLCBrZXkpIHtcbiAgICBsZW4gPSAobGVuIHx8IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdKSAvIDg7XG4gICAgaWYgKGxlbiA+IGtleS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBsZW5ndGhcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgfVxuXG4gIC8vICMjIyBGYWxsYmFjayBJbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gY2hlY2tLZXlMZW5ndGgocHJvcHMubGVuZ3RoLCBrZXkpO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2lnID0gZm9yZ2UuaG1hYy5jcmVhdGUoKTtcbiAgICAgIHNpZy5zdGFydChtZCwga2V5LnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbiAgICAgIHNpZy51cGRhdGUocGRhdGEudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuICAgICAgc2lnID0gQnVmZmVyLmZyb20oc2lnLmRpZ2VzdCgpLmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWdcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJITUFDXCIsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGhhc2hcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBjaGVja0tleUxlbmd0aChwcm9wcy5sZW5ndGgsIGtleSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcInNpZ25cIl0pO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uc2lnbihhbGcsIGtleSwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICB2YXIgc2lnID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBOb2RlSlMgaW1wbGVtZW50YXRpb25cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBjaGVja0tleUxlbmd0aChwcm9wcy5sZW5ndGgsIGtleSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBobWFjID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUhtYWMobWQsIGtleSk7XG4gICAgICBobWFjLnVwZGF0ZShwZGF0YSk7XG5cbiAgICAgIHZhciBzaWcgPSBobWFjLmRpZ2VzdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaG1hY1ZlcmlmeUZOKG5hbWUpIHtcbiAgdmFyIG1kID0gbmFtZS5yZXBsYWNlKFwiSFNcIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJIU1wiLCBcIlNIQS1cIik7XG5cbiAgZnVuY3Rpb24gY29tcGFyZShsZW4sIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICBsZW4gPSAobGVuIHx8IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdKSAvIDg7XG4gICAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBsZW4gPiBpZHg7IGlkeCsrKSB7XG4gICAgICB2YWxpZCA9IHZhbGlkICYmIChleHBlY3RlZFtpZHhdID09PSBhY3R1YWxbaWR4XSk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuXG4gIC8vICMjIyBGYWxsYmFjayBJbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYywgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIHZyZnkgPSBmb3JnZS5obWFjLmNyZWF0ZSgpO1xuICAgIHZyZnkuc3RhcnQobWQsIG5ldyBEYXRhQnVmZmVyKGtleSkpO1xuICAgIHZyZnkudXBkYXRlKHBkYXRhLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbiAgICB2cmZ5ID0gQnVmZmVyLmZyb20odnJmeS5kaWdlc3QoKS5ieXRlcygpLCBcImJpbmFyeVwiKTtcblxuICAgIGlmIChjb21wYXJlKHByb3BzLmxlbmd0aCwgbWFjLCB2cmZ5KSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogaGFzaFxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wic2lnblwiXSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uc2lnbihhbGcsIGtleSwgcGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICB2YXIgc2lnID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUocHJvcHMubGVuZ3RoLCBtYWMsIHNpZyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1widmVyaWZ5XCJdKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by52ZXJpZnkoYWxnLCBrZXksIG1hYywgcGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZhY3Rpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBobWFjID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUhtYWMobWQsIGtleSk7XG4gICAgaG1hYy51cGRhdGUocGRhdGEpO1xuXG4gICAgdmFyIHNpZyA9IGhtYWMuZGlnZXN0KCk7XG4gICAgaWYgKCFjb21wYXJlKHByb3BzLmxlbmd0aCwgbWFjLCBzaWcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogcGRhdGEsXG4gICAgICBtYWM6IHNpZyxcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5zaWduXG4vLyAqIFtuYW1lXS52ZXJpZnlcbnZhciBobWFjID0ge307XG5bXG4gIFwiSFMxXCIsXG4gIFwiSFMyNTZcIixcbiAgXCJIUzM4NFwiLFxuICBcIkhTNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgaG1hY1thbGddID0ge1xuICAgIHNpZ246IGhtYWNTaWduRk4oYWxnKSxcbiAgICB2ZXJpZnk6IGhtYWNWZXJpZnlGTihhbGcpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBobWFjO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/index.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * algorithms/index.js - Cryptographic Algorithms Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\n// setup implementations\nvar implementations = [\n  __webpack_require__(/*! ./aes-cbc-hmac-sha2.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js\"),\n  __webpack_require__(/*! ./aes-gcm.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js\"),\n  __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\"),\n  __webpack_require__(/*! ./concat.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\"),\n  __webpack_require__(/*! ./dir.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/dir.js\"),\n  __webpack_require__(/*! ./ecdh.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js\"),\n  __webpack_require__(/*! ./ecdsa.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js\"),\n  __webpack_require__(/*! ./hkdf.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\"),\n  __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\"),\n  __webpack_require__(/*! ./pbes2.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js\"),\n  __webpack_require__(/*! ./rsaes.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js\"),\n  __webpack_require__(/*! ./rsassa.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js\"),\n  __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\")\n];\n\nvar ALGS_DIGEST = {};\nvar ALGS_DERIVE = {};\nvar ALGS_SIGN = {},\n    ALGS_VRFY = {};\nvar ALGS_ENC = {},\n    ALGS_DEC = {};\n\nimplementations.forEach(function(mod) {\n  Object.keys(mod).forEach(function(alg) {\n    var op = mod[alg];\n\n    if (\"function\" === typeof op.encrypt) {\n      ALGS_ENC[alg] = op.encrypt;\n    }\n    if (\"function\" === typeof op.decrypt) {\n      ALGS_DEC[alg] = op.decrypt;\n    }\n    if (\"function\" === typeof op.sign) {\n      ALGS_SIGN[alg] = op.sign;\n    }\n    if (\"function\" === typeof op.verify) {\n      ALGS_VRFY[alg] = op.verify;\n    }\n    if (\"function\" === typeof op.digest) {\n      ALGS_DIGEST[alg] = op.digest;\n    }\n    if (\"function\" === typeof op.derive) {\n      ALGS_DERIVE[alg] = op.derive;\n    }\n  });\n});\n\n// public API\nexports.digest = function(alg, data, props) {\n  var op = ALGS_DIGEST[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(data, props);\n};\n\nexports.derive = function(alg, key, props) {\n  var op = ALGS_DERIVE[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, props);\n};\n\nexports.sign = function(alg, key, pdata, props) {\n  var op = ALGS_SIGN[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, props || {});\n};\n\nexports.verify = function(alg, key, pdata, mac, props) {\n  var op = ALGS_VRFY[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, mac, props || {});\n};\n\nexports.encrypt = function(alg, key, pdata, props) {\n  var op = ALGS_ENC[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, props || {});\n};\n\nexports.decrypt = function(alg, key, cdata, props) {\n  var op = ALGS_DEC[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, cdata, props || {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLGtHQUF3QjtBQUNsQyxFQUFFLG1CQUFPLENBQUMsOEVBQWM7QUFDeEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyw0RUFBYTtBQUN2QixFQUFFLG1CQUFPLENBQUMsc0VBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QixFQUFFLG1CQUFPLENBQUMsd0VBQVc7QUFDckIsRUFBRSxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QixFQUFFLG1CQUFPLENBQUMsMEVBQVk7QUFDdEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9pbmRleC5qcz9hZGFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9pbmRleC5qcyAtIENyeXB0b2dyYXBoaWMgQWxnb3JpdGhtcyBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gc2V0dXAgaW1wbGVtZW50YXRpb25zXG52YXIgaW1wbGVtZW50YXRpb25zID0gW1xuICByZXF1aXJlKFwiLi9hZXMtY2JjLWhtYWMtc2hhMi5qc1wiKSxcbiAgcmVxdWlyZShcIi4vYWVzLWdjbS5qc1wiKSxcbiAgcmVxdWlyZShcIi4vYWVzLWt3LmpzXCIpLFxuICByZXF1aXJlKFwiLi9jb25jYXQuanNcIiksXG4gIHJlcXVpcmUoXCIuL2Rpci5qc1wiKSxcbiAgcmVxdWlyZShcIi4vZWNkaC5qc1wiKSxcbiAgcmVxdWlyZShcIi4vZWNkc2EuanNcIiksXG4gIHJlcXVpcmUoXCIuL2hrZGYuanNcIiksXG4gIHJlcXVpcmUoXCIuL2htYWMuanNcIiksXG4gIHJlcXVpcmUoXCIuL3BiZXMyLmpzXCIpLFxuICByZXF1aXJlKFwiLi9yc2Flcy5qc1wiKSxcbiAgcmVxdWlyZShcIi4vcnNhc3NhLmpzXCIpLFxuICByZXF1aXJlKFwiLi9zaGEuanNcIilcbl07XG5cbnZhciBBTEdTX0RJR0VTVCA9IHt9O1xudmFyIEFMR1NfREVSSVZFID0ge307XG52YXIgQUxHU19TSUdOID0ge30sXG4gICAgQUxHU19WUkZZID0ge307XG52YXIgQUxHU19FTkMgPSB7fSxcbiAgICBBTEdTX0RFQyA9IHt9O1xuXG5pbXBsZW1lbnRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihtb2QpIHtcbiAgT2JqZWN0LmtleXMobW9kKS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICAgIHZhciBvcCA9IG1vZFthbGddO1xuXG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wLmVuY3J5cHQpIHtcbiAgICAgIEFMR1NfRU5DW2FsZ10gPSBvcC5lbmNyeXB0O1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3AuZGVjcnlwdCkge1xuICAgICAgQUxHU19ERUNbYWxnXSA9IG9wLmRlY3J5cHQ7XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcC5zaWduKSB7XG4gICAgICBBTEdTX1NJR05bYWxnXSA9IG9wLnNpZ247XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcC52ZXJpZnkpIHtcbiAgICAgIEFMR1NfVlJGWVthbGddID0gb3AudmVyaWZ5O1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3AuZGlnZXN0KSB7XG4gICAgICBBTEdTX0RJR0VTVFthbGddID0gb3AuZGlnZXN0O1xuICAgIH1cbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3AuZGVyaXZlKSB7XG4gICAgICBBTEdTX0RFUklWRVthbGddID0gb3AuZGVyaXZlO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLy8gcHVibGljIEFQSVxuZXhwb3J0cy5kaWdlc3QgPSBmdW5jdGlvbihhbGcsIGRhdGEsIHByb3BzKSB7XG4gIHZhciBvcCA9IEFMR1NfRElHRVNUW2FsZ107XG4gIGlmICghb3ApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZykpO1xuICB9XG5cbiAgcmV0dXJuIG9wKGRhdGEsIHByb3BzKTtcbn07XG5cbmV4cG9ydHMuZGVyaXZlID0gZnVuY3Rpb24oYWxnLCBrZXksIHByb3BzKSB7XG4gIHZhciBvcCA9IEFMR1NfREVSSVZFW2FsZ107XG4gIGlmICghb3ApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZykpO1xuICB9XG5cbiAgcmV0dXJuIG9wKGtleSwgcHJvcHMpO1xufTtcblxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24oYWxnLCBrZXksIHBkYXRhLCBwcm9wcykge1xuICB2YXIgb3AgPSBBTEdTX1NJR05bYWxnXTtcbiAgaWYgKCFvcCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKSk7XG4gIH1cblxuICByZXR1cm4gb3Aoa2V5LCBwZGF0YSwgcHJvcHMgfHwge30pO1xufTtcblxuZXhwb3J0cy52ZXJpZnkgPSBmdW5jdGlvbihhbGcsIGtleSwgcGRhdGEsIG1hYywgcHJvcHMpIHtcbiAgdmFyIG9wID0gQUxHU19WUkZZW2FsZ107XG4gIGlmICghb3ApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZykpO1xuICB9XG5cbiAgcmV0dXJuIG9wKGtleSwgcGRhdGEsIG1hYywgcHJvcHMgfHwge30pO1xufTtcblxuZXhwb3J0cy5lbmNyeXB0ID0gZnVuY3Rpb24oYWxnLCBrZXksIHBkYXRhLCBwcm9wcykge1xuICB2YXIgb3AgPSBBTEdTX0VOQ1thbGddO1xuICBpZiAoIW9wKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpKTtcbiAgfVxuXG4gIHJldHVybiBvcChrZXksIHBkYXRhLCBwcm9wcyB8fCB7fSk7XG59O1xuXG5leHBvcnRzLmRlY3J5cHQgPSBmdW5jdGlvbihhbGcsIGtleSwgY2RhdGEsIHByb3BzKSB7XG4gIHZhciBvcCA9IEFMR1NfREVDW2FsZ107XG4gIGlmICghb3ApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZykpO1xuICB9XG5cbiAgcmV0dXJuIG9wKGtleSwgY2RhdGEsIHByb3BzIHx8IHt9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/pbes2.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/pbes2.js - Password-Based Encryption (v2) Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    merge = __webpack_require__(/*! ../util/merge.js */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    KW = __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\");\n\nvar NULL_BUFFER = Buffer.from([0]);\nvar DEFAULT_ITERATIONS = 8192;\nvar DEFAULT_SALT_LENGTH = 16;\n\nfunction fixSalt(hmac, kw, salt) {\n  var alg = \"PBES2-\" + hmac + \"+\" + kw;\n  var output = [\n    Buffer.from(alg, \"utf8\"),\n    NULL_BUFFER,\n    salt\n  ];\n  return Buffer.concat(output);\n}\n\nfunction pbkdf2Fn(hash) {\n  function prepareProps(props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    var salt = util.asBuffer(props.salt || Buffer.alloc(0), \"base64u4l\"),\n        itrs = props.iterations || 0;\n\n    if (0 >= keyLen) {\n      throw new Error(\"invalid key length\");\n    }\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    props.length = keyLen;\n    props.salt = salt;\n    props.iterations = itrs;\n\n    return props;\n  }\n\n  var fallback = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = new Promise(function(resolve, reject) {\n      var md = forge.md[hash.replace(\"-\", \"\").toLowerCase()].create();\n      var cb = function(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = Buffer.from(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"),\n                         salt.toString(\"binary\"),\n                         itrs,\n                         keyLen,\n                         md,\n                         cb);\n    });\n    return promise;\n  };\n  var webcrypto = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = Promise.resolve(key);\n    promise = promise.then(function(keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveBits\"]);\n    });\n    promise = promise.then(function(key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: new Uint8Array(salt),\n        iterations: itrs,\n        hash: hash\n      };\n\n      return helpers.subtleCrypto.deriveBits(mainAlgo, key, keyLen * 8);\n    });\n    promise = promise.then(function(result) {\n      return util.asBuffer(result);\n    });\n    return promise;\n  };\n  var nodejs = function(key, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBKDF2-\" + hash);\n    }\n\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n        var md = hash.replace(\"-\", \"\");\n    var promise = new Promise(function(resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2EncryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, pdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n      itrs = props.p2c || DEFAULT_ITERATIONS;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n    if (0 === salt.length) {\n      salt = util.randomBytes(DEFAULT_SALT_LENGTH);\n    } else if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n    var header = {\n      p2s: util.base64url.encode(salt),\n      p2c: itrs\n    };\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n    // STEP 1: derive shared key\n    promise = promise.then(function (key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: encrypt cek\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    });\n    // STEP 3: (re-)apply headers\n    promise = promise.then(function (results) {\n      results.header = merge(results.header || {}, header);\n      return results;\n    });\n\n    return promise;\n  };\n}\n\nfunction pbes2DecryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, cdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n\n    // STEP 1: derived shared key\n    promise = promise.then(function(key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: decrypt cek\n    promise = promise.then(function(dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\nvar pbes2 = {};\n\n// * [name].derive\n[\n  \"PBKDF2-SHA-256\",\n  \"PBKDF2-SHA-384\",\n  \"PBKDF2-SHA-512\"\n].forEach(function(alg) {\n  var hash = alg.replace(\"PBKDF2-\", \"\");\n  pbes2[alg] = {\n    derive: pbkdf2Fn(hash)\n  };\n});\n\n// [name].encrypt\n// [name].decrypt\n[\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\"\n].forEach(function(alg) {\n  var parts = /PBES2-(HS\\d+)\\+(A\\d+KW)/g.exec(alg);\n  var hmac = parts[1],\n      kw = parts[2];\n  pbes2[alg] = {\n    encrypt: pbes2EncryptFN(hmac, kw),\n    decrypt: pbes2DecryptFN(hmac, kw)\n  };\n});\n\nmodule.exports = pbes2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3BiZXMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGlFQUFTO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDeEMsU0FBUyxtQkFBTyxDQUFDLDRFQUFhOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvcGJlczIuanM/YTYyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvcGJlczIuanMgLSBQYXNzd29yZC1CYXNlZCBFbmNyeXB0aW9uICh2MikgQWxnb3JpdGhtc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZS5qc1wiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpLFxuICAgIEtXID0gcmVxdWlyZShcIi4vYWVzLWt3LmpzXCIpO1xuXG52YXIgTlVMTF9CVUZGRVIgPSBCdWZmZXIuZnJvbShbMF0pO1xudmFyIERFRkFVTFRfSVRFUkFUSU9OUyA9IDgxOTI7XG52YXIgREVGQVVMVF9TQUxUX0xFTkdUSCA9IDE2O1xuXG5mdW5jdGlvbiBmaXhTYWx0KGhtYWMsIGt3LCBzYWx0KSB7XG4gIHZhciBhbGcgPSBcIlBCRVMyLVwiICsgaG1hYyArIFwiK1wiICsga3c7XG4gIHZhciBvdXRwdXQgPSBbXG4gICAgQnVmZmVyLmZyb20oYWxnLCBcInV0ZjhcIiksXG4gICAgTlVMTF9CVUZGRVIsXG4gICAgc2FsdFxuICBdO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBwYmtkZjJGbihoYXNoKSB7XG4gIGZ1bmN0aW9uIHByZXBhcmVQcm9wcyhwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCB8fCAwO1xuICAgIHZhciBzYWx0ID0gdXRpbC5hc0J1ZmZlcihwcm9wcy5zYWx0IHx8IEJ1ZmZlci5hbGxvYygwKSwgXCJiYXNlNjR1NGxcIiksXG4gICAgICAgIGl0cnMgPSBwcm9wcy5pdGVyYXRpb25zIHx8IDA7XG5cbiAgICBpZiAoMCA+PSBrZXlMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQga2V5IGxlbmd0aFwiKTtcbiAgICB9XG4gICAgaWYgKDAgPj0gaXRycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdGVyYXRpb24gY291bnRcIik7XG4gICAgfVxuXG4gICAgcHJvcHMubGVuZ3RoID0ga2V5TGVuO1xuICAgIHByb3BzLnNhbHQgPSBzYWx0O1xuICAgIHByb3BzLml0ZXJhdGlvbnMgPSBpdHJzO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHRyeSB7XG4gICAgICBwcm9wcyA9IHByZXBhcmVQcm9wcyhwcm9wcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICBzYWx0ID0gcHJvcHMuc2FsdCxcbiAgICAgICAgaXRycyA9IHByb3BzLml0ZXJhdGlvbnM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIG1kID0gZm9yZ2UubWRbaGFzaC5yZXBsYWNlKFwiLVwiLCBcIlwiKS50b0xvd2VyQ2FzZSgpXS5jcmVhdGUoKTtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uKGVyciwgZGspIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRrID0gQnVmZmVyLmZyb20oZGssIFwiYmluYXJ5XCIpO1xuICAgICAgICAgIHJlc29sdmUoZGspO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3JnZS5wa2NzNS5wYmtkZjIoa2V5LnRvU3RyaW5nKFwiYmluYXJ5XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHNhbHQudG9TdHJpbmcoXCJiaW5hcnlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgaXRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICBrZXlMZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgbWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2IpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIHRyeSB7XG4gICAgICBwcm9wcyA9IHByZXBhcmVQcm9wcyhwcm9wcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICBzYWx0ID0gcHJvcHMuc2FsdCxcbiAgICAgICAgaXRycyA9IHByb3BzLml0ZXJhdGlvbnM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShrZXkpO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5dmFsKSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleXZhbCwgXCJQQktERjJcIiwgZmFsc2UsIFtcImRlcml2ZUJpdHNcIl0pO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbWFpbkFsZ28gPSB7XG4gICAgICAgIG5hbWU6IFwiUEJLREYyXCIsXG4gICAgICAgIHNhbHQ6IG5ldyBVaW50OEFycmF5KHNhbHQpLFxuICAgICAgICBpdGVyYXRpb25zOiBpdHJzLFxuICAgICAgICBoYXNoOiBoYXNoXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZGVyaXZlQml0cyhtYWluQWxnbywga2V5LCBrZXlMZW4gKiA4KTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHV0aWwuYXNCdWZmZXIocmVzdWx0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBpZiAoNiA+IGhlbHBlcnMubm9kZUNyeXB0by5wYmtkZjIubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFBCS0RGMi1cIiArIGhhc2gpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9wcyA9IHByZXBhcmVQcm9wcyhwcm9wcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoLFxuICAgICAgICBzYWx0ID0gcHJvcHMuc2FsdCxcbiAgICAgICAgaXRycyA9IHByb3BzLml0ZXJhdGlvbnM7XG5cbiAgICAgICAgdmFyIG1kID0gaGFzaC5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gY2IoZXJyLCBkaykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShkayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhlbHBlcnMubm9kZUNyeXB0by5wYmtkZjIoa2V5LCBzYWx0LCBpdHJzLCBrZXlMZW4sIG1kLCBjYik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwYmVzMkVuY3J5cHRGTihobWFjLCBrdykge1xuICB2YXIgZGVyaXZlQWxnID0gXCJQQktERjItXCIgKyBobWFjLnJlcGxhY2UoXCJIU1wiLCBcIlNIQS1cIik7XG4gIHZhciBrZXlMZW4gPSBDT05TVEFOVFMuS0VZTEVOR1RIW2t3XSAvIDg7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBzYWx0ID0gdXRpbC5hc0J1ZmZlcihwcm9wcy5wMnMgfHwgQnVmZmVyLmFsbG9jKDApLCBcImJhc2U2NHVybFwiKSxcbiAgICAgIGl0cnMgPSBwcm9wcy5wMmMgfHwgREVGQVVMVF9JVEVSQVRJT05TO1xuXG4gICAgaWYgKDAgPj0gaXRycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdGVyYXRpb24gY291bnRcIik7XG4gICAgfVxuICAgIGlmICgwID09PSBzYWx0Lmxlbmd0aCkge1xuICAgICAgc2FsdCA9IHV0aWwucmFuZG9tQnl0ZXMoREVGQVVMVF9TQUxUX0xFTkdUSCk7XG4gICAgfSBlbHNlIGlmICg4ID4gc2FsdC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNhbHQgdG9vIHNtYWxsXCIpO1xuICAgIH1cbiAgICB2YXIgaGVhZGVyID0ge1xuICAgICAgcDJzOiB1dGlsLmJhc2U2NHVybC5lbmNvZGUoc2FsdCksXG4gICAgICBwMmM6IGl0cnNcbiAgICB9O1xuICAgIHNhbHQgPSBmaXhTYWx0KGhtYWMsIGt3LCBzYWx0KTtcbiAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCB7XG4gICAgICBzYWx0OiBzYWx0LFxuICAgICAgaXRlcmF0aW9uczogaXRycyxcbiAgICAgIGxlbmd0aDoga2V5TGVuXG4gICAgfSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShrZXkpO1xuICAgIC8vIFNURVAgMTogZGVyaXZlIHNoYXJlZCBrZXlcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBwYmVzMltkZXJpdmVBbGddLmRlcml2ZShrZXksIHByb3BzKTtcbiAgICB9KTtcbiAgICAvLyBTVEVQIDI6IGVuY3J5cHQgY2VrXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoZGspIHtcbiAgICAgIHJldHVybiBLV1trd10uZW5jcnlwdChkaywgcGRhdGEpO1xuICAgIH0pO1xuICAgIC8vIFNURVAgMzogKHJlLSlhcHBseSBoZWFkZXJzXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgcmVzdWx0cy5oZWFkZXIgPSBtZXJnZShyZXN1bHRzLmhlYWRlciB8fCB7fSwgaGVhZGVyKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBiZXMyRGVjcnlwdEZOKGhtYWMsIGt3KSB7XG4gIHZhciBkZXJpdmVBbGcgPSBcIlBCS0RGMi1cIiArIGhtYWMucmVwbGFjZShcIkhTXCIsIFwiU0hBLVwiKTtcbiAgdmFyIGtleUxlbiA9IENPTlNUQU5UUy5LRVlMRU5HVEhba3ddIC8gODtcblxuICByZXR1cm4gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIHNhbHQgPSB1dGlsLmFzQnVmZmVyKHByb3BzLnAycyB8fCBCdWZmZXIuYWxsb2MoMCksIFwiYmFzZTY0dXJsXCIpLFxuICAgICAgICBpdHJzID0gcHJvcHMucDJjIHx8IDA7XG5cbiAgICBpZiAoMCA+PSBpdHJzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW52YWxpZCBpdGVyYXRpb24gY291bnRcIikpO1xuICAgIH1cblxuICAgIGlmICg4ID4gc2FsdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzYWx0IHRvbyBzbWFsbFwiKSk7XG4gICAgfVxuICAgIHNhbHQgPSBmaXhTYWx0KGhtYWMsIGt3LCBzYWx0KTtcbiAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCB7XG4gICAgICBzYWx0OiBzYWx0LFxuICAgICAgaXRlcmF0aW9uczogaXRycyxcbiAgICAgIGxlbmd0aDoga2V5TGVuXG4gICAgfSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShrZXkpO1xuXG4gICAgLy8gU1RFUCAxOiBkZXJpdmVkIHNoYXJlZCBrZXlcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHBiZXMyW2Rlcml2ZUFsZ10uZGVyaXZlKGtleSwgcHJvcHMpO1xuICAgIH0pO1xuICAgIC8vIFNURVAgMjogZGVjcnlwdCBjZWtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGRrKSB7XG4gICAgICByZXR1cm4gS1dba3ddLmRlY3J5cHQoZGssIGNkYXRhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxudmFyIHBiZXMyID0ge307XG5cbi8vICogW25hbWVdLmRlcml2ZVxuW1xuICBcIlBCS0RGMi1TSEEtMjU2XCIsXG4gIFwiUEJLREYyLVNIQS0zODRcIixcbiAgXCJQQktERjItU0hBLTUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBoYXNoID0gYWxnLnJlcGxhY2UoXCJQQktERjItXCIsIFwiXCIpO1xuICBwYmVzMlthbGddID0ge1xuICAgIGRlcml2ZTogcGJrZGYyRm4oaGFzaClcbiAgfTtcbn0pO1xuXG4vLyBbbmFtZV0uZW5jcnlwdFxuLy8gW25hbWVdLmRlY3J5cHRcbltcbiAgXCJQQkVTMi1IUzI1NitBMTI4S1dcIixcbiAgXCJQQkVTMi1IUzM4NCtBMTkyS1dcIixcbiAgXCJQQkVTMi1IUzUxMitBMjU2S1dcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICB2YXIgcGFydHMgPSAvUEJFUzItKEhTXFxkKylcXCsoQVxcZCtLVykvZy5leGVjKGFsZyk7XG4gIHZhciBobWFjID0gcGFydHNbMV0sXG4gICAgICBrdyA9IHBhcnRzWzJdO1xuICBwYmVzMlthbGddID0ge1xuICAgIGVuY3J5cHQ6IHBiZXMyRW5jcnlwdEZOKGhtYWMsIGt3KSxcbiAgICBkZWNyeXB0OiBwYmVzMkRlY3J5cHRGTihobWFjLCBrdylcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBiZXMyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsa-util.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsa-util.js - RSA Utility Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\n// ### RSA-specific Helpers\nfunction convertToForge(key, isPublic) {\n  var parts = isPublic ?\n              [\"n\", \"e\"] :\n              [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"];\n  parts = parts.map(function(f) {\n    return new forge.jsbn.BigInteger(key[f].toString(\"hex\"), 16);\n  });\n\n  var fn = isPublic ?\n           forge.pki.rsa.setPublicKey :\n           forge.pki.rsa.setPrivateKey;\n  return fn.apply(forge.pki.rsa, parts);\n}\n\nfunction convertToJWK(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"n\", \"e\"] :\n              [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"];\n  parts.forEach(function(f) {\n    result[f] = util.base64url.encode(result[f]);\n  });\n\n  // remove potentially troublesome properties\n  delete result.key_ops;\n  delete result.use;\n  delete result.alg;\n\n  if (isPublic) {\n    delete result.d;\n    delete result.p;\n    delete result.q;\n    delete result.dp;\n    delete result.dq;\n    delete result.qi;\n  }\n\n  return result;\n}\n\nfunction convertToPem(key, isPublic) {\n  var cacheKey = isPublic ? \"__cachedPublicPem\" : \"__cachedPrivatePem\";\n  if (key[cacheKey]) {\n    return key[cacheKey];\n  }\n\n  var value;\n  if (isPublic) {\n    value = forge.pki.publicKeyToPem(convertToForge(key, isPublic));\n  } else {\n    value = forge.pki.privateKeyToPem(convertToForge(key, isPublic));\n  }\n\n  Object.defineProperty(key, cacheKey, { value: value });\n  return value;\n}\n\nmodule.exports = {\n  convertToForge: convertToForge,\n  convertToJWK: convertToJWK,\n  convertToPem: convertToPem\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYS11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9yc2EtdXRpbC5qcz8zZTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9yc2EtdXRpbC5qcyAtIFJTQSBVdGlsaXR5IEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxuLy8gIyMjIFJTQS1zcGVjaWZpYyBIZWxwZXJzXG5mdW5jdGlvbiBjb252ZXJ0VG9Gb3JnZShrZXksIGlzUHVibGljKSB7XG4gIHZhciBwYXJ0cyA9IGlzUHVibGljID9cbiAgICAgICAgICAgICAgW1wiblwiLCBcImVcIl0gOlxuICAgICAgICAgICAgICBbXCJuXCIsIFwiZVwiLCBcImRcIiwgXCJwXCIsIFwicVwiLCBcImRwXCIsIFwiZHFcIiwgXCJxaVwiXTtcbiAgcGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuanNibi5CaWdJbnRlZ2VyKGtleVtmXS50b1N0cmluZyhcImhleFwiKSwgMTYpO1xuICB9KTtcblxuICB2YXIgZm4gPSBpc1B1YmxpYyA/XG4gICAgICAgICAgIGZvcmdlLnBraS5yc2Euc2V0UHVibGljS2V5IDpcbiAgICAgICAgICAgZm9yZ2UucGtpLnJzYS5zZXRQcml2YXRlS2V5O1xuICByZXR1cm4gZm4uYXBwbHkoZm9yZ2UucGtpLnJzYSwgcGFydHMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9KV0soa2V5LCBpc1B1YmxpYykge1xuICB2YXIgcmVzdWx0ID0gY2xvbmUoa2V5KTtcbiAgdmFyIHBhcnRzID0gaXNQdWJsaWMgP1xuICAgICAgICAgICAgICBbXCJuXCIsIFwiZVwiXSA6XG4gICAgICAgICAgICAgIFtcIm5cIiwgXCJlXCIsIFwiZFwiLCBcInBcIiwgXCJxXCIsIFwiZHBcIiwgXCJkcVwiLCBcInFpXCJdO1xuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICByZXN1bHRbZl0gPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0W2ZdKTtcbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIHBvdGVudGlhbGx5IHRyb3VibGVzb21lIHByb3BlcnRpZXNcbiAgZGVsZXRlIHJlc3VsdC5rZXlfb3BzO1xuICBkZWxldGUgcmVzdWx0LnVzZTtcbiAgZGVsZXRlIHJlc3VsdC5hbGc7XG5cbiAgaWYgKGlzUHVibGljKSB7XG4gICAgZGVsZXRlIHJlc3VsdC5kO1xuICAgIGRlbGV0ZSByZXN1bHQucDtcbiAgICBkZWxldGUgcmVzdWx0LnE7XG4gICAgZGVsZXRlIHJlc3VsdC5kcDtcbiAgICBkZWxldGUgcmVzdWx0LmRxO1xuICAgIGRlbGV0ZSByZXN1bHQucWk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9QZW0oa2V5LCBpc1B1YmxpYykge1xuICB2YXIgY2FjaGVLZXkgPSBpc1B1YmxpYyA/IFwiX19jYWNoZWRQdWJsaWNQZW1cIiA6IFwiX19jYWNoZWRQcml2YXRlUGVtXCI7XG4gIGlmIChrZXlbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuIGtleVtjYWNoZUtleV07XG4gIH1cblxuICB2YXIgdmFsdWU7XG4gIGlmIChpc1B1YmxpYykge1xuICAgIHZhbHVlID0gZm9yZ2UucGtpLnB1YmxpY0tleVRvUGVtKGNvbnZlcnRUb0ZvcmdlKGtleSwgaXNQdWJsaWMpKTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGZvcmdlLnBraS5wcml2YXRlS2V5VG9QZW0oY29udmVydFRvRm9yZ2Uoa2V5LCBpc1B1YmxpYykpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGtleSwgY2FjaGVLZXksIHsgdmFsdWU6IHZhbHVlIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb252ZXJ0VG9Gb3JnZTogY29udmVydFRvRm9yZ2UsXG4gIGNvbnZlcnRUb0pXSzogY29udmVydFRvSldLLFxuICBjb252ZXJ0VG9QZW06IGNvbnZlcnRUb1BlbVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsaes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsaes.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    rsaUtil = __webpack_require__(/*! ./rsa-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\");\n\nvar nodeSupport = {\n  \"RSA-OAEP\": \"RSA_PKCS1_OAEP_PADDING\",\n  RSA1_5: \"RSA_PKCS1_PADDING\"\n};\n\nfunction nodeSupportCheck(name) {\n  return helpers.nodeCrypto && helpers.nodeCrypto.constants && Object.keys(nodeSupport).indexOf(name) !== -1;\n}\n\n// ### RSAES-PKCS1-v1_5\n\n// ### RSAES-OAEP\nfunction rsaesEncryptFn(name) {\n  var alg = {\n    name: name\n  };\n\n  if (\"RSA-OAEP-256\" === name) {\n    alg.name = \"RSA-OAEP\";\n    alg.hash = {\n      name: \"SHA-256\"\n    };\n  } else if (\"RSA-OAEP\" === name) {\n    alg.hash = {\n      name: \"SHA-1\"\n    };\n  } else {\n    alg.name = \"RSAES-PKCS1-v1_5\";\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata) {\n    // convert pdata to byte string\n    pdata = new DataBuffer(pdata).bytes();\n\n    // encrypt it\n    var pki = rsaUtil.convertToForge(key, true),\n        params = {};\n    if (\"RSA-OAEP\" === alg.name) {\n      params.md = alg.hash.name.toLowerCase().replace(/-/g, \"\");\n      params.md = forge.md[params.md].create();\n    }\n    var cdata = pki.encrypt(pdata, alg.name.toUpperCase(), params);\n\n    // convert cdata to Buffer\n    cdata = new DataBuffer(cdata).native();\n\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto;\n  if (\"RSAES-PKCS1-v1_5\" !== alg.name) {\n    webcrypto = function(key, pdata) {\n      key = rsaUtil.convertToJWK(key, true);\n      var promise;\n      promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"encrypt\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.encrypt(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var cdata = Buffer.from(result);\n        return {\n          data: cdata\n        };\n      });\n\n      return promise;\n    };\n  } else {\n    webcrypto = null;\n  }\n\n  var nodejs;\n  if (nodeSupportCheck(name)) {\n    nodejs = function (key, pdata) {\n      key = rsaUtil.convertToPem(key, true);\n\n      var cdata = helpers.nodeCrypto.publicEncrypt({\n        key: key,\n        padding: helpers.nodeCrypto.constants[nodeSupport[name]]\n      }, pdata);\n\n      return {\n        data: cdata\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsaesDecryptFn(name) {\n  var alg = {\n    name: name\n  };\n\n  if (\"RSA-OAEP-256\" === name) {\n    alg.name = \"RSA-OAEP\";\n    alg.hash = {\n      name: \"SHA-256\"\n    };\n  } else if (\"RSA-OAEP\" === name) {\n    alg.hash = {\n      name: \"SHA-1\"\n    };\n  } else {\n    alg.name = \"RSAES-PKCS1-v1_5\";\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, cdata) {\n    // convert cdata to byte string\n    cdata = new DataBuffer(cdata).bytes();\n\n    // decrypt it\n    var pki = rsaUtil.convertToForge(key, false),\n        params = {};\n    if (\"RSA-OAEP\" === alg.name) {\n      params.md = alg.hash.name.toLowerCase().replace(/-/g, \"\");\n      params.md = forge.md[params.md].create();\n    }\n    var pdata = pki.decrypt(cdata, alg.name.toUpperCase(), params);\n\n    // convert pdata to Buffer\n    pdata = new DataBuffer(pdata).native();\n\n    return Promise.resolve(pdata);\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto;\n  if (\"RSAES-PKCS1-v1_5\" !== alg.name) {\n    webcrypto = function(key, pdata) {\n      key = rsaUtil.convertToJWK(key, false);\n      var promise;\n      promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"decrypt\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.decrypt(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var pdata = Buffer.from(result);\n        return pdata;\n      });\n\n      return promise;\n    };\n  } else {\n    webcrypto = null;\n  }\n\n  var nodejs;\n  if (nodeSupportCheck(name)) { // node ^6.12.0 || >= 8.0.0\n    nodejs = function(key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      return helpers.nodeCrypto.privateDecrypt({\n        key: key,\n        padding: helpers.nodeCrypto.constants[nodeSupport[name]]\n      }, pdata);\n    };\n  } else if (helpers.nodeCrypto && name === \"RSA-OAEP\") { // node (>= 6.0.0 && < 6.12.0) || ^7.0.0\n    nodejs = function(key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      return helpers.nodeCrypto.privateDecrypt(key, pdata);\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar rsaes = {};\n[\n  \"RSA-OAEP\",\n  \"RSA-OAEP-256\",\n  \"RSA1_5\"\n].forEach(function(name) {\n  rsaes[name] = {\n    encrypt: rsaesEncryptFn(name),\n    decrypt: rsaesDecryptFn(name)\n  };\n});\n\nmodule.exports = rsaes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBdUI7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksc0RBQXNEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9yc2Flcy5qcz81YjYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9yc2Flcy5qcyAtIFJTQSBTaWduYXR1cmVzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBEYXRhQnVmZmVyID0gcmVxdWlyZShcIi4uL3V0aWwvZGF0YWJ1ZmZlci5qc1wiKSxcbiAgICByc2FVdGlsID0gcmVxdWlyZShcIi4vcnNhLXV0aWwuanNcIik7XG5cbnZhciBub2RlU3VwcG9ydCA9IHtcbiAgXCJSU0EtT0FFUFwiOiBcIlJTQV9QS0NTMV9PQUVQX1BBRERJTkdcIixcbiAgUlNBMV81OiBcIlJTQV9QS0NTMV9QQURESU5HXCJcbn07XG5cbmZ1bmN0aW9uIG5vZGVTdXBwb3J0Q2hlY2sobmFtZSkge1xuICByZXR1cm4gaGVscGVycy5ub2RlQ3J5cHRvICYmIGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMgJiYgT2JqZWN0LmtleXMobm9kZVN1cHBvcnQpLmluZGV4T2YobmFtZSkgIT09IC0xO1xufVxuXG4vLyAjIyMgUlNBRVMtUEtDUzEtdjFfNVxuXG4vLyAjIyMgUlNBRVMtT0FFUFxuZnVuY3Rpb24gcnNhZXNFbmNyeXB0Rm4obmFtZSkge1xuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IG5hbWVcbiAgfTtcblxuICBpZiAoXCJSU0EtT0FFUC0yNTZcIiA9PT0gbmFtZSkge1xuICAgIGFsZy5uYW1lID0gXCJSU0EtT0FFUFwiO1xuICAgIGFsZy5oYXNoID0ge1xuICAgICAgbmFtZTogXCJTSEEtMjU2XCJcbiAgICB9O1xuICB9IGVsc2UgaWYgKFwiUlNBLU9BRVBcIiA9PT0gbmFtZSkge1xuICAgIGFsZy5oYXNoID0ge1xuICAgICAgbmFtZTogXCJTSEEtMVwiXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBhbGcubmFtZSA9IFwiUlNBRVMtUEtDUzEtdjFfNVwiO1xuICB9XG5cbiAgLy8gIyMjIEZhbGxiYWNrIEltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIC8vIGNvbnZlcnQgcGRhdGEgdG8gYnl0ZSBzdHJpbmdcbiAgICBwZGF0YSA9IG5ldyBEYXRhQnVmZmVyKHBkYXRhKS5ieXRlcygpO1xuXG4gICAgLy8gZW5jcnlwdCBpdFxuICAgIHZhciBwa2kgPSByc2FVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgdHJ1ZSksXG4gICAgICAgIHBhcmFtcyA9IHt9O1xuICAgIGlmIChcIlJTQS1PQUVQXCIgPT09IGFsZy5uYW1lKSB7XG4gICAgICBwYXJhbXMubWQgPSBhbGcuaGFzaC5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCBcIlwiKTtcbiAgICAgIHBhcmFtcy5tZCA9IGZvcmdlLm1kW3BhcmFtcy5tZF0uY3JlYXRlKCk7XG4gICAgfVxuICAgIHZhciBjZGF0YSA9IHBraS5lbmNyeXB0KHBkYXRhLCBhbGcubmFtZS50b1VwcGVyQ2FzZSgpLCBwYXJhbXMpO1xuXG4gICAgLy8gY29udmVydCBjZGF0YSB0byBCdWZmZXJcbiAgICBjZGF0YSA9IG5ldyBEYXRhQnVmZmVyKGNkYXRhKS5uYXRpdmUoKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogY2RhdGFcbiAgICB9KTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG87XG4gIGlmIChcIlJTQUVTLVBLQ1MxLXYxXzVcIiAhPT0gYWxnLm5hbWUpIHtcbiAgICB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb0pXSyhrZXksIHRydWUpO1xuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsIGtleSwgYWxnLCB0cnVlLCBbXCJlbmNyeXB0XCJdKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5lbmNyeXB0KGFsZywga2V5LCBwZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBjZGF0YSA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogY2RhdGFcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHdlYmNyeXB0byA9IG51bGw7XG4gIH1cblxuICB2YXIgbm9kZWpzO1xuICBpZiAobm9kZVN1cHBvcnRDaGVjayhuYW1lKSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uIChrZXksIHBkYXRhKSB7XG4gICAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIHRydWUpO1xuXG4gICAgICB2YXIgY2RhdGEgPSBoZWxwZXJzLm5vZGVDcnlwdG8ucHVibGljRW5jcnlwdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwYWRkaW5nOiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzW25vZGVTdXBwb3J0W25hbWVdXVxuICAgICAgfSwgcGRhdGEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBjZGF0YVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiByc2Flc0RlY3J5cHRGbihuYW1lKSB7XG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogbmFtZVxuICB9O1xuXG4gIGlmIChcIlJTQS1PQUVQLTI1NlwiID09PSBuYW1lKSB7XG4gICAgYWxnLm5hbWUgPSBcIlJTQS1PQUVQXCI7XG4gICAgYWxnLmhhc2ggPSB7XG4gICAgICBuYW1lOiBcIlNIQS0yNTZcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoXCJSU0EtT0FFUFwiID09PSBuYW1lKSB7XG4gICAgYWxnLmhhc2ggPSB7XG4gICAgICBuYW1lOiBcIlNIQS0xXCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGFsZy5uYW1lID0gXCJSU0FFUy1QS0NTMS12MV81XCI7XG4gIH1cblxuICAvLyAjIyMgRmFsbGJhY2sgSW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIGNkYXRhKSB7XG4gICAgLy8gY29udmVydCBjZGF0YSB0byBieXRlIHN0cmluZ1xuICAgIGNkYXRhID0gbmV3IERhdGFCdWZmZXIoY2RhdGEpLmJ5dGVzKCk7XG5cbiAgICAvLyBkZWNyeXB0IGl0XG4gICAgdmFyIHBraSA9IHJzYVV0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCBmYWxzZSksXG4gICAgICAgIHBhcmFtcyA9IHt9O1xuICAgIGlmIChcIlJTQS1PQUVQXCIgPT09IGFsZy5uYW1lKSB7XG4gICAgICBwYXJhbXMubWQgPSBhbGcuaGFzaC5uYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLS9nLCBcIlwiKTtcbiAgICAgIHBhcmFtcy5tZCA9IGZvcmdlLm1kW3BhcmFtcy5tZF0uY3JlYXRlKCk7XG4gICAgfVxuICAgIHZhciBwZGF0YSA9IHBraS5kZWNyeXB0KGNkYXRhLCBhbGcubmFtZS50b1VwcGVyQ2FzZSgpLCBwYXJhbXMpO1xuXG4gICAgLy8gY29udmVydCBwZGF0YSB0byBCdWZmZXJcbiAgICBwZGF0YSA9IG5ldyBEYXRhQnVmZmVyKHBkYXRhKS5uYXRpdmUoKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGRhdGEpO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0bztcbiAgaWYgKFwiUlNBRVMtUEtDUzEtdjFfNVwiICE9PSBhbGcubmFtZSkge1xuICAgIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvSldLKGtleSwgZmFsc2UpO1xuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsIGtleSwgYWxnLCB0cnVlLCBbXCJkZWNyeXB0XCJdKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5kZWNyeXB0KGFsZywga2V5LCBwZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBwZGF0YSA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBwZGF0YTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHdlYmNyeXB0byA9IG51bGw7XG4gIH1cblxuICB2YXIgbm9kZWpzO1xuICBpZiAobm9kZVN1cHBvcnRDaGVjayhuYW1lKSkgeyAvLyBub2RlIF42LjEyLjAgfHwgPj0gOC4wLjBcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIGZhbHNlKTtcbiAgICAgIHJldHVybiBoZWxwZXJzLm5vZGVDcnlwdG8ucHJpdmF0ZURlY3J5cHQoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcGFkZGluZzogaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50c1tub2RlU3VwcG9ydFtuYW1lXV1cbiAgICAgIH0sIHBkYXRhKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGhlbHBlcnMubm9kZUNyeXB0byAmJiBuYW1lID09PSBcIlJTQS1PQUVQXCIpIHsgLy8gbm9kZSAoPj0gNi4wLjAgJiYgPCA2LjEyLjApIHx8IF43LjAuMFxuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIGhlbHBlcnMubm9kZUNyeXB0by5wcml2YXRlRGVjcnlwdChrZXksIHBkYXRhKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZW5jcnlwdFxuLy8gKiBbbmFtZV0uZGVjcnlwdFxudmFyIHJzYWVzID0ge307XG5bXG4gIFwiUlNBLU9BRVBcIixcbiAgXCJSU0EtT0FFUC0yNTZcIixcbiAgXCJSU0ExXzVcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgcnNhZXNbbmFtZV0gPSB7XG4gICAgZW5jcnlwdDogcnNhZXNFbmNyeXB0Rm4obmFtZSksXG4gICAgZGVjcnlwdDogcnNhZXNEZWNyeXB0Rm4obmFtZSlcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJzYWVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsassa.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsassa.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    rsaUtil = __webpack_require__(/*! ./rsa-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\");\n\nfunction nodePSSsupport() {\n  return helpers.nodeCrypto && helpers.nodeCrypto.constants && helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST;\n}\n\n// ### RSASSA-PKCS1-v1_5\n\nfunction rsassaV15SignFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  };\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n\n    // sign it\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, \"RSASSA-PKCS1-V1_5\");\n    sig = Buffer.from(sig, \"binary\");\n\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = \"RSA-\" + hash.replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      var sign = helpers.nodeCrypto.createSign(nodeHash);\n      sign.update(pdata);\n\n      return {\n        data: pdata,\n        mac: sign.sign(rsaUtil.convertToPem(key, false))\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaV15VerifyFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes();\n\n    // verify it\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, \"RSASSA-PKCS1-V1_5\");\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(md) > -1) {\n    nodejs = function(key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify(rsaUtil.convertToPem(key, true), mac);\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### RSA-PSS\nfunction rsassaPssSignFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSA-PSS\",\n    hash: {\n      name: hash\n    },\n    saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function (key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n\n    // setup padding\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    });\n\n    // sign it\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, pss);\n    sig = Buffer.from(sig, \"binary\");\n\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = \"RSA-\" + hash.replace(\"-\", \"\");\n  if (nodePSSsupport()) {\n    nodejs = function(key, pdata) {\n      var sign = helpers.nodeCrypto.createSign(nodeHash);\n      sign.update(pdata);\n\n      var sig = sign.sign({\n        key: rsaUtil.convertToPem(key, false),\n        padding: helpers.nodeCrypto.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST\n      });\n\n      return {\n        data: pdata,\n        mac: sig\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaPssVerifyFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSA-PSS\",\n    hash: {\n      name: hash\n    },\n    saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function (key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes();\n\n    // setup padding\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    });\n\n    // verify it\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, pss);\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  if (nodePSSsupport()) {\n    nodejs = function(key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify({\n        key: rsaUtil.convertToPem(key, true),\n        padding: helpers.nodeCrypto.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST\n      }, mac);\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].sign\n// * [name].verify\nvar rsassa = {};\n[\n  \"PS256\",\n  \"PS384\",\n  \"PS512\"\n].forEach(function(name) {\n  rsassa[name] = {\n    sign: rsassaPssSignFn(name),\n    verify: rsassaPssVerifyFn(name)\n  };\n});\n\n[\n  \"RS256\",\n  \"RS384\",\n  \"RS512\"\n].forEach(function(name) {\n  rsassa[name] = {\n    sign: rsassaV15SignFn(name),\n    verify: rsassaV15VerifyFn(name)\n  };\n});\n\nmodule.exports = rsassa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYXNzYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBYTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsOEVBQWM7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9yc2Fzc2EuanM/NjM1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvcnNhc3NhLmpzIC0gUlNBIFNpZ25hdHVyZXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICByc2FVdGlsID0gcmVxdWlyZShcIi4vcnNhLXV0aWwuanNcIik7XG5cbmZ1bmN0aW9uIG5vZGVQU1NzdXBwb3J0KCkge1xuICByZXR1cm4gaGVscGVycy5ub2RlQ3J5cHRvICYmIGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMgJiYgaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cy5SU0FfUFNTX1NBTFRMRU5fRElHRVNUO1xufVxuXG4vLyAjIyMgUlNBU1NBLVBLQ1MxLXYxXzVcblxuZnVuY3Rpb24gcnNhc3NhVjE1U2lnbkZuKG5hbWUpIHtcbiAgdmFyIG1kID0gbmFtZS5yZXBsYWNlKFwiUlNcIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJSU1wiLCBcIlNIQS1cIik7XG5cbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBcIlJTQVNTQS1QS0NTMS1WMV81XCIsXG4gICAgaGFzaDoge1xuICAgICAgbmFtZTogaGFzaFxuICAgIH1cbiAgfTtcblxuICAvLyAjIyMgRmFsbGJhY2sgSW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgLy8gY3JlYXRlIHRoZSBkaWdlc3RcbiAgICB2YXIgZGlnZXN0ID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICAgIGRpZ2VzdC5zdGFydCgpO1xuICAgIGRpZ2VzdC51cGRhdGUocGRhdGEpO1xuXG4gICAgLy8gc2lnbiBpdFxuICAgIHZhciBwa2kgPSByc2FVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgZmFsc2UpO1xuICAgIHZhciBzaWcgPSBwa2kuc2lnbihkaWdlc3QsIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIik7XG4gICAgc2lnID0gQnVmZmVyLmZyb20oc2lnLCBcImJpbmFyeVwiKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogcGRhdGEsXG4gICAgICBtYWM6IHNpZ1xuICAgIH0pO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb0pXSyhrZXksIGZhbHNlKTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsIGtleSwgYWxnLCB0cnVlLCBbXCJzaWduXCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnNpZ24oYWxnLCBrZXksIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdmFyIHNpZyA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWdcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzO1xuICB2YXIgbm9kZUhhc2ggPSBcIlJTQS1cIiArIGhhc2gucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gIGlmIChoZWxwZXJzLm5vZGVDcnlwdG8gJiYgaGVscGVycy5ub2RlQ3J5cHRvLmdldEhhc2hlcygpLmluZGV4T2Yobm9kZUhhc2gpID4gLTEpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICB2YXIgc2lnbiA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVTaWduKG5vZGVIYXNoKTtcbiAgICAgIHNpZ24udXBkYXRlKHBkYXRhKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnbi5zaWduKHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgZmFsc2UpKVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiByc2Fzc2FWMTVWZXJpZnlGbihuYW1lKSB7XG4gIHZhciBtZCA9IG5hbWUucmVwbGFjZShcIlJTXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICBoYXNoID0gbmFtZS5yZXBsYWNlKFwiUlNcIiwgXCJTSEEtXCIpO1xuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IFwiUlNBU1NBLVBLQ1MxLVYxXzVcIixcbiAgICBoYXNoOiB7XG4gICAgICBuYW1lOiBoYXNoXG4gICAgfVxuICB9O1xuXG4gIC8vICMjIyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYykge1xuICAgIC8vIGNyZWF0ZSB0aGUgZGlnZXN0XG4gICAgdmFyIGRpZ2VzdCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgICBkaWdlc3Quc3RhcnQoKTtcbiAgICBkaWdlc3QudXBkYXRlKHBkYXRhKTtcbiAgICBkaWdlc3QgPSBkaWdlc3QuZGlnZXN0KCkuYnl0ZXMoKTtcblxuICAgIC8vIHZlcmlmeSBpdFxuICAgIHZhciBwa2kgPSByc2FVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgdHJ1ZSk7XG4gICAgdmFyIHNpZyA9IG1hYy50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICB2YXIgcmVzdWx0ID0gcGtpLnZlcmlmeShkaWdlc3QsIHNpZywgXCJSU0FTU0EtUEtDUzEtVjFfNVwiKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgbWFjOiBtYWMsXG4gICAgICB2YWxpZDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYykge1xuICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvSldLKGtleSwgdHJ1ZSk7XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLCBrZXksIGFsZywgdHJ1ZSwgW1widmVyaWZ5XCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnZlcmlmeShhbGcsIGtleSwgbWFjLCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanM7XG4gIGlmIChoZWxwZXJzLm5vZGVDcnlwdG8gJiYgaGVscGVycy5ub2RlQ3J5cHRvLmdldEhhc2hlcygpLmluZGV4T2YobWQpID4gLTEpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMpIHtcbiAgICAgIHZhciB2ZXJpZnkgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlVmVyaWZ5KG1kKTtcbiAgICAgIHZlcmlmeS51cGRhdGUocGRhdGEpO1xuICAgICAgdmVyaWZ5LmVuZCgpO1xuICAgICAgdmFyIHJlc3VsdCA9IHZlcmlmeS52ZXJpZnkocnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCB0cnVlKSwgbWFjKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUlNBLVBTU1xuZnVuY3Rpb24gcnNhc3NhUHNzU2lnbkZuKG5hbWUpIHtcbiAgdmFyIG1kID0gbmFtZS5yZXBsYWNlKFwiUFNcIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJQU1wiLCBcIlNIQS1cIik7XG5cbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBcIlJTQS1QU1NcIixcbiAgICBoYXNoOiB7XG4gICAgICBuYW1lOiBoYXNoXG4gICAgfSxcbiAgICBzYWx0TGVuZ3RoOiBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSAvIDhcbiAgfTtcblxuICAvLyAjIyMgRmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbiAoa2V5LCBwZGF0YSkge1xuICAgIC8vIGNyZWF0ZSB0aGUgZGlnZXN0XG4gICAgdmFyIGRpZ2VzdCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgICBkaWdlc3Quc3RhcnQoKTtcbiAgICBkaWdlc3QudXBkYXRlKHBkYXRhKTtcblxuICAgIC8vIHNldHVwIHBhZGRpbmdcbiAgICB2YXIgcHNzID0gZm9yZ2UucHNzLmNyZWF0ZSh7XG4gICAgICBtZDogZm9yZ2UubWRbbWRdLmNyZWF0ZSgpLFxuICAgICAgbWdmOiBmb3JnZS5tZ2YubWdmMS5jcmVhdGUoZm9yZ2UubWRbbWRdLmNyZWF0ZSgpKSxcbiAgICAgIHNhbHRMZW5ndGg6IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdIC8gOFxuICAgIH0pO1xuXG4gICAgLy8gc2lnbiBpdFxuICAgIHZhciBwa2kgPSByc2FVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgZmFsc2UpO1xuICAgIHZhciBzaWcgPSBwa2kuc2lnbihkaWdlc3QsIHBzcyk7XG4gICAgc2lnID0gQnVmZmVyLmZyb20oc2lnLCBcImJpbmFyeVwiKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogcGRhdGEsXG4gICAgICBtYWM6IHNpZ1xuICAgIH0pO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICBrZXkgPSByc2FVdGlsLmNvbnZlcnRUb0pXSyhrZXksIGZhbHNlKTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsIGtleSwgYWxnLCB0cnVlLCBbXCJzaWduXCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5zaWduKGFsZywga2V5LCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICB2YXIgc2lnID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanM7XG4gIHZhciBub2RlSGFzaCA9IFwiUlNBLVwiICsgaGFzaC5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcbiAgaWYgKG5vZGVQU1NzdXBwb3J0KCkpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgICB2YXIgc2lnbiA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVTaWduKG5vZGVIYXNoKTtcbiAgICAgIHNpZ24udXBkYXRlKHBkYXRhKTtcblxuICAgICAgdmFyIHNpZyA9IHNpZ24uc2lnbih7XG4gICAgICAgIGtleTogcnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCBmYWxzZSksXG4gICAgICAgIHBhZGRpbmc6IGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BTU19QQURESU5HLFxuICAgICAgICBzYWx0TGVuZ3RoOiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1RcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWdcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcnNhc3NhUHNzVmVyaWZ5Rm4obmFtZSkge1xuICB2YXIgbWQgPSBuYW1lLnJlcGxhY2UoXCJQU1wiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgaGFzaCA9IG5hbWUucmVwbGFjZShcIlBTXCIsIFwiU0hBLVwiKTtcblxuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IFwiUlNBLVBTU1wiLFxuICAgIGhhc2g6IHtcbiAgICAgIG5hbWU6IGhhc2hcbiAgICB9LFxuICAgIHNhbHRMZW5ndGg6IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdIC8gOFxuICB9O1xuXG4gIC8vICMjIyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uIChrZXksIHBkYXRhLCBtYWMpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGRpZ2VzdFxuICAgIHZhciBkaWdlc3QgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gICAgZGlnZXN0LnN0YXJ0KCk7XG4gICAgZGlnZXN0LnVwZGF0ZShwZGF0YSk7XG4gICAgZGlnZXN0ID0gZGlnZXN0LmRpZ2VzdCgpLmJ5dGVzKCk7XG5cbiAgICAvLyBzZXR1cCBwYWRkaW5nXG4gICAgdmFyIHBzcyA9IGZvcmdlLnBzcy5jcmVhdGUoe1xuICAgICAgbWQ6IGZvcmdlLm1kW21kXS5jcmVhdGUoKSxcbiAgICAgIG1nZjogZm9yZ2UubWdmLm1nZjEuY3JlYXRlKGZvcmdlLm1kW21kXS5jcmVhdGUoKSksXG4gICAgICBzYWx0TGVuZ3RoOiBDT05TVEFOVFMuSEFTSExFTkdUSFtoYXNoXSAvIDhcbiAgICB9KTtcblxuICAgIC8vIHZlcmlmeSBpdFxuICAgIHZhciBwa2kgPSByc2FVdGlsLmNvbnZlcnRUb0ZvcmdlKGtleSwgdHJ1ZSk7XG4gICAgdmFyIHNpZyA9IG1hYy50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICB2YXIgcmVzdWx0ID0gcGtpLnZlcmlmeShkaWdlc3QsIHNpZywgcHNzKTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgbWFjOiBtYWMsXG4gICAgICB2YWxpZDogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYykge1xuICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvSldLKGtleSwgdHJ1ZSk7XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLCBrZXksIGFsZywgdHJ1ZSwgW1widmVyaWZ5XCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by52ZXJpZnkoYWxnLCBrZXksIG1hYywgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcztcbiAgaWYgKG5vZGVQU1NzdXBwb3J0KCkpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMpIHtcbiAgICAgIHZhciB2ZXJpZnkgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlVmVyaWZ5KG1kKTtcbiAgICAgIHZlcmlmeS51cGRhdGUocGRhdGEpO1xuICAgICAgdmVyaWZ5LmVuZCgpO1xuICAgICAgdmFyIHJlc3VsdCA9IHZlcmlmeS52ZXJpZnkoe1xuICAgICAgICBrZXk6IHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgdHJ1ZSksXG4gICAgICAgIHBhZGRpbmc6IGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BTU19QQURESU5HLFxuICAgICAgICBzYWx0TGVuZ3RoOiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1RcbiAgICAgIH0sIG1hYyk7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLnNpZ25cbi8vICogW25hbWVdLnZlcmlmeVxudmFyIHJzYXNzYSA9IHt9O1xuW1xuICBcIlBTMjU2XCIsXG4gIFwiUFMzODRcIixcbiAgXCJQUzUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICByc2Fzc2FbbmFtZV0gPSB7XG4gICAgc2lnbjogcnNhc3NhUHNzU2lnbkZuKG5hbWUpLFxuICAgIHZlcmlmeTogcnNhc3NhUHNzVmVyaWZ5Rm4obmFtZSlcbiAgfTtcbn0pO1xuXG5bXG4gIFwiUlMyNTZcIixcbiAgXCJSUzM4NFwiLFxuICBcIlJTNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHJzYXNzYVtuYW1lXSA9IHtcbiAgICBzaWduOiByc2Fzc2FWMTVTaWduRm4obmFtZSksXG4gICAgdmVyaWZ5OiByc2Fzc2FWMTVWZXJpZnlGbihuYW1lKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcnNhc3NhO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/sha.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/sha.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/sha.js - Cryptographic Secure Hash Algorithms, versions 1 and 2\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\");\n\nfunction hashDigestFN(hash) {\n  var md = hash.replace(\"SHA-\", \"SHA\").toLowerCase();\n\n  var alg = {\n    name: hash\n  };\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(pdata /* props */) {\n    var digest = forge.md[md].create();\n    digest.update(pdata.toString(\"binary\"));\n    digest = Buffer.from(digest.digest().bytes(), \"binary\");\n\n    return Promise.resolve(digest);\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(pdata /* props */) {\n    var promise;\n    promise = helpers.subtleCrypto.digest(alg, pdata);\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return promise;\n  };\n\n  // ### nodejs Implementation\n  var nodejs = function(pdata /* props */) {\n    var digest = helpers.nodeCrypto.createHash(md);\n    digest.update(pdata);\n    return digest.digest();\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// Public API\n// * [name].digest\nvar sha = {};\n[\n  \"SHA-1\",\n  \"SHA-256\",\n  \"SHA-384\",\n  \"SHA-512\"\n].forEach(function(name) {\n  sha[name] = {\n    digest: hashDigestFN(name)\n  };\n});\n\nmodule.exports = sha;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3NoYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxjQUFjLG1CQUFPLENBQUMsOEVBQWM7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9zaGEuanM/M2M1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvc2hhLmpzIC0gQ3J5cHRvZ3JhcGhpYyBTZWN1cmUgSGFzaCBBbGdvcml0aG1zLCB2ZXJzaW9ucyAxIGFuZCAyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKTtcblxuZnVuY3Rpb24gaGFzaERpZ2VzdEZOKGhhc2gpIHtcbiAgdmFyIG1kID0gaGFzaC5yZXBsYWNlKFwiU0hBLVwiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogaGFzaFxuICB9O1xuXG4gIC8vICMjIyBGYWxsYmFjayBJbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKHBkYXRhIC8qIHByb3BzICovKSB7XG4gICAgdmFyIGRpZ2VzdCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgICBkaWdlc3QudXBkYXRlKHBkYXRhLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbiAgICBkaWdlc3QgPSBCdWZmZXIuZnJvbShkaWdlc3QuZGlnZXN0KCkuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRpZ2VzdCk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24ocGRhdGEgLyogcHJvcHMgKi8pIHtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uZGlnZXN0KGFsZywgcGRhdGEpO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgbm9kZWpzIEltcGxlbWVudGF0aW9uXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihwZGF0YSAvKiBwcm9wcyAqLykge1xuICAgIHZhciBkaWdlc3QgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlSGFzaChtZCk7XG4gICAgZGlnZXN0LnVwZGF0ZShwZGF0YSk7XG4gICAgcmV0dXJuIGRpZ2VzdC5kaWdlc3QoKTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmRpZ2VzdFxudmFyIHNoYSA9IHt9O1xuW1xuICBcIlNIQS0xXCIsXG4gIFwiU0hBLTI1NlwiLFxuICBcIlNIQS0zODRcIixcbiAgXCJTSEEtNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHNoYVtuYW1lXSA9IHtcbiAgICBkaWdlc3Q6IGhhc2hEaWdlc3RGTihuYW1lKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/helpers.js - AES-GCM Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\"),\n    fill = __webpack_require__(/*! lodash/fill */ \"(ssr)/./node_modules/lodash/fill.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\nvar E1 = 0xe1000000,\n    E1B = 0xe1,\n    E1L = new Long(E1 >> 8);\n\nfunction generateLookup() {\n  var lookup = [];\n\n  for (var c = 0; c < 256; ++c) {\n    var v = 0;\n    for (var i = 7; i >= 0; --i) {\n      if ((c & (1 << i)) !== 0) {\n        v ^= (E1 >>> (7 - i));\n      }\n    }\n    lookup.push(v);\n  }\n\n  return lookup;\n}\n\nvar helpers = module.exports = {\n  // ### Constants\n  E1: E1,\n  E1B: E1B,\n  E1L: E1L,\n  LOOKUP: generateLookup(),\n\n  // ### Array Helpers\n  arrayCopy: function(src, srcPos, dest, destPos, length) {\n    // Start by checking for negatives since arrays in JS auto-expand\n    if (srcPos < 0 || destPos < 0 || length < 0) {\n      throw new TypeError(\"Invalid input.\");\n    }\n\n    if (dest instanceof Uint8Array) {\n      // Check for overflow if dest is a typed-array\n      if (destPos >= dest.length || (destPos + length) > dest.length) {\n        throw new TypeError(\"Invalid input.\");\n      }\n\n      if (srcPos !== 0 || length < src.length) {\n        if (src instanceof Uint8Array) {\n          src = src.subarray(srcPos, srcPos + length);\n        } else {\n          src = src.slice(srcPos, srcPos + length);\n        }\n      }\n\n      dest.set(src, destPos);\n    } else {\n      for (var i = 0; i < length; ++i) {\n        dest[destPos + i] = src[srcPos + i];\n      }\n    }\n  },\n  arrayEqual: function(a1, a2) {\n    a1 = a1 || [];\n    a2 = a2 || [];\n\n    var len = Math.min(a1.length, a2.length),\n        result = (a1.length === a2.length);\n\n    for (var idx = 0; idx < len; idx++) {\n      result = result &&\n               (\"undefined\" !== typeof a1[idx]) &&\n               (\"undefined\" !== typeof a2[idx]) &&\n               (a1[idx] === a2[idx]);\n    }\n\n    return result;\n  },\n\n  // ### Conversions\n  asBytes: function(x, z) {\n    switch (arguments.length) {\n      case 1:\n        z = Buffer.alloc(16);\n        pack.intToBigEndian(x, z, 0);\n        return z;\n      case 2:\n        pack.intToBigEndian(x, z, 0);\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  asInts: function(x, z) {\n    switch (arguments.length) {\n      case 1:\n        z = [];\n        fill(z, 0, 0, 4);\n        pack.bigEndianToInt(x, 0, z);\n        return z;\n      case 2:\n        pack.bigEndianToInt(x, 0, z);\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  oneAsInts: function() {\n    var tmp = [];\n    for (var c = 0; c < 4; ++c) {\n        tmp.push(1 << 31);\n    }\n    return tmp;\n  },\n\n  // ## Bit-wise\n  shiftRight: function(x, z) {\n    var b, c;\n    switch (arguments.length) {\n      case 1:\n        b = x[0];\n        x[0] = b >>> 1;\n        c = b << 31;\n        b = x[1];\n        x[1] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[2];\n        x[2] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[3];\n        x[3] = (b >>> 1) | c;\n        return (b << 31) & 0xffffffff;\n      case 2:\n        b = x[0];\n        z[0] = b >>> 1;\n        c = b << 31;\n        b = x[1];\n        z[1] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[2];\n        z[2] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[3];\n        z[3] = (b >>> 1) | c;\n        return (b << 31) & 0xffffffff;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  shiftRightN: function(x, n, z) {\n    var nInv, b, c;\n    switch (arguments.length) {\n      case 2:\n        b = x[0];\n        nInv = 32 - n;\n        x[0] = b >>> n;\n        c = b << nInv;\n        b = x[1];\n        x[1] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[2];\n        x[2] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[3];\n        x[3] = (b >>> n) | c;\n        return b << nInv;\n      case 3:\n        b = x[0];\n        nInv = 32 - n;\n        z[0] = b >>> n;\n        c = b << nInv;\n        b = x[1];\n        z[1] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[2];\n        z[2] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[3];\n        z[3] = (b >>> n) | c;\n        return b << nInv;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n  xor: function(x, y, z) {\n    switch (arguments.length) {\n      case 2:\n        x[0] ^= y[0];\n        x[1] ^= y[1];\n        x[2] ^= y[2];\n        x[3] ^= y[3];\n        break;\n      case 3:\n        z[0] = x[0] ^ y[0];\n        z[1] = x[1] ^ y[1];\n        z[2] = x[2] ^ y[2];\n        z[3] = x[3] ^ y[3];\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n\n  multiply: function(x, y) {\n    var r0 = x.slice();\n    var r1 = [];\n\n    for (var i = 0; i < 4; ++i) {\n      var bits = y[i];\n      for (var j = 31; j >= 0; --j) {\n        if ((bits & (1 << j)) !== 0) {\n          helpers.xor(r1, r0);\n        }\n\n        if (helpers.shiftRight(r0) !== 0) {\n          r0[0] ^= helpers.E1;\n        }\n      }\n    }\n\n    helpers.arrayCopy(r1, 0, x, 0, 4);\n  },\n  multiplyP: function(x, y) {\n    switch (arguments.length) {\n      case 1:\n        if (helpers.shiftRight(x) !== 0) {\n          x[0] ^= helpers.E1;\n        }\n        break;\n      case 2:\n        if (helpers.shiftRight(x, y) !== 0) {\n          y[0] ^= helpers.E1;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  multiplyP8: function(x, y) {\n    var c;\n    switch (arguments.length) {\n      case 1:\n        c = helpers.shiftRightN(x, 8);\n        x[0] ^= helpers.LOOKUP[c >>> 24];\n        break;\n      case 2:\n        c = helpers.shiftRightN(x, 8, y);\n        y[0] ^= helpers.LOOKUP[c >>> 24];\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLHdEQUFhO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9oZWxwZXJzLmpzPzdiZWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkZXBzL2NpcGhlcm1vZGVzL2djbS9oZWxwZXJzLmpzIC0gQUVTLUdDTSBIZWxwZXIgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpLFxuICAgIGZpbGwgPSByZXF1aXJlKFwibG9kYXNoL2ZpbGxcIiksXG4gICAgcGFjayA9IHJlcXVpcmUoXCIuLi9wYWNrLmpzXCIpO1xuXG52YXIgRTEgPSAweGUxMDAwMDAwLFxuICAgIEUxQiA9IDB4ZTEsXG4gICAgRTFMID0gbmV3IExvbmcoRTEgPj4gOCk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTG9va3VwKCkge1xuICB2YXIgbG9va3VwID0gW107XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCAyNTY7ICsrYykge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gNzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGlmICgoYyAmICgxIDw8IGkpKSAhPT0gMCkge1xuICAgICAgICB2IF49IChFMSA+Pj4gKDcgLSBpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxvb2t1cC5wdXNoKHYpO1xuICB9XG5cbiAgcmV0dXJuIGxvb2t1cDtcbn1cblxudmFyIGhlbHBlcnMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gIyMjIENvbnN0YW50c1xuICBFMTogRTEsXG4gIEUxQjogRTFCLFxuICBFMUw6IEUxTCxcbiAgTE9PS1VQOiBnZW5lcmF0ZUxvb2t1cCgpLFxuXG4gIC8vICMjIyBBcnJheSBIZWxwZXJzXG4gIGFycmF5Q29weTogZnVuY3Rpb24oc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICAgIC8vIFN0YXJ0IGJ5IGNoZWNraW5nIGZvciBuZWdhdGl2ZXMgc2luY2UgYXJyYXlzIGluIEpTIGF1dG8tZXhwYW5kXG4gICAgaWYgKHNyY1BvcyA8IDAgfHwgZGVzdFBvcyA8IDAgfHwgbGVuZ3RoIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXQuXCIpO1xuICAgIH1cblxuICAgIGlmIChkZXN0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJmbG93IGlmIGRlc3QgaXMgYSB0eXBlZC1hcnJheVxuICAgICAgaWYgKGRlc3RQb3MgPj0gZGVzdC5sZW5ndGggfHwgKGRlc3RQb3MgKyBsZW5ndGgpID4gZGVzdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgaW5wdXQuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3JjUG9zICE9PSAwIHx8IGxlbmd0aCA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBsZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNyYyA9IHNyYy5zbGljZShzcmNQb3MsIHNyY1BvcyArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVzdC5zZXQoc3JjLCBkZXN0UG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBkZXN0W2Rlc3RQb3MgKyBpXSA9IHNyY1tzcmNQb3MgKyBpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFycmF5RXF1YWw6IGZ1bmN0aW9uKGExLCBhMikge1xuICAgIGExID0gYTEgfHwgW107XG4gICAgYTIgPSBhMiB8fCBbXTtcblxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhMS5sZW5ndGgsIGEyLmxlbmd0aCksXG4gICAgICAgIHJlc3VsdCA9IChhMS5sZW5ndGggPT09IGEyLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQgJiZcbiAgICAgICAgICAgICAgIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYTFbaWR4XSkgJiZcbiAgICAgICAgICAgICAgIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgYTJbaWR4XSkgJiZcbiAgICAgICAgICAgICAgIChhMVtpZHhdID09PSBhMltpZHhdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8vICMjIyBDb252ZXJzaW9uc1xuICBhc0J5dGVzOiBmdW5jdGlvbih4LCB6KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHogPSBCdWZmZXIuYWxsb2MoMTYpO1xuICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKHgsIHosIDApO1xuICAgICAgICByZXR1cm4gejtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbih4LCB6LCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAyIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuICBhc0ludHM6IGZ1bmN0aW9uKHgsIHopIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeiA9IFtdO1xuICAgICAgICBmaWxsKHosIDAsIDAsIDQpO1xuICAgICAgICBwYWNrLmJpZ0VuZGlhblRvSW50KHgsIDAsIHopO1xuICAgICAgICByZXR1cm4gejtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcGFjay5iaWdFbmRpYW5Ub0ludCh4LCAwLCB6KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAyIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuICBvbmVBc0ludHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0bXAgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IDQ7ICsrYykge1xuICAgICAgICB0bXAucHVzaCgxIDw8IDMxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRtcDtcbiAgfSxcblxuICAvLyAjIyBCaXQtd2lzZVxuICBzaGlmdFJpZ2h0OiBmdW5jdGlvbih4LCB6KSB7XG4gICAgdmFyIGIsIGM7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGIgPSB4WzBdO1xuICAgICAgICB4WzBdID0gYiA+Pj4gMTtcbiAgICAgICAgYyA9IGIgPDwgMzE7XG4gICAgICAgIGIgPSB4WzFdO1xuICAgICAgICB4WzFdID0gKGIgPj4+IDEpIHwgYztcbiAgICAgICAgYyA9IGIgPDwgMzE7XG4gICAgICAgIGIgPSB4WzJdO1xuICAgICAgICB4WzJdID0gKGIgPj4+IDEpIHwgYztcbiAgICAgICAgYyA9IGIgPDwgMzE7XG4gICAgICAgIGIgPSB4WzNdO1xuICAgICAgICB4WzNdID0gKGIgPj4+IDEpIHwgYztcbiAgICAgICAgcmV0dXJuIChiIDw8IDMxKSAmIDB4ZmZmZmZmZmY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGIgPSB4WzBdO1xuICAgICAgICB6WzBdID0gYiA+Pj4gMTtcbiAgICAgICAgYyA9IGIgPDwgMzE7XG4gICAgICAgIGIgPSB4WzFdO1xuICAgICAgICB6WzFdID0gKGIgPj4+IDEpIHwgYztcbiAgICAgICAgYyA9IGIgPDwgMzE7XG4gICAgICAgIGIgPSB4WzJdO1xuICAgICAgICB6WzJdID0gKGIgPj4+IDEpIHwgYztcbiAgICAgICAgYyA9IGIgPDwgMzE7XG4gICAgICAgIGIgPSB4WzNdO1xuICAgICAgICB6WzNdID0gKGIgPj4+IDEpIHwgYztcbiAgICAgICAgcmV0dXJuIChiIDw8IDMxKSAmIDB4ZmZmZmZmZmY7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAyIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuICBzaGlmdFJpZ2h0TjogZnVuY3Rpb24oeCwgbiwgeikge1xuICAgIHZhciBuSW52LCBiLCBjO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICBiID0geFswXTtcbiAgICAgICAgbkludiA9IDMyIC0gbjtcbiAgICAgICAgeFswXSA9IGIgPj4+IG47XG4gICAgICAgIGMgPSBiIDw8IG5JbnY7XG4gICAgICAgIGIgPSB4WzFdO1xuICAgICAgICB4WzFdID0gKGIgPj4+IG4pIHwgYztcbiAgICAgICAgYyA9IGIgPDwgbkludjtcbiAgICAgICAgYiA9IHhbMl07XG4gICAgICAgIHhbMl0gPSAoYiA+Pj4gbikgfCBjO1xuICAgICAgICBjID0gYiA8PCBuSW52O1xuICAgICAgICBiID0geFszXTtcbiAgICAgICAgeFszXSA9IChiID4+PiBuKSB8IGM7XG4gICAgICAgIHJldHVybiBiIDw8IG5JbnY7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGIgPSB4WzBdO1xuICAgICAgICBuSW52ID0gMzIgLSBuO1xuICAgICAgICB6WzBdID0gYiA+Pj4gbjtcbiAgICAgICAgYyA9IGIgPDwgbkludjtcbiAgICAgICAgYiA9IHhbMV07XG4gICAgICAgIHpbMV0gPSAoYiA+Pj4gbikgfCBjO1xuICAgICAgICBjID0gYiA8PCBuSW52O1xuICAgICAgICBiID0geFsyXTtcbiAgICAgICAgelsyXSA9IChiID4+PiBuKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IG5JbnY7XG4gICAgICAgIGIgPSB4WzNdO1xuICAgICAgICB6WzNdID0gKGIgPj4+IG4pIHwgYztcbiAgICAgICAgcmV0dXJuIGIgPDwgbkludjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAyIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG4gIHhvcjogZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICB4WzBdIF49IHlbMF07XG4gICAgICAgIHhbMV0gXj0geVsxXTtcbiAgICAgICAgeFsyXSBePSB5WzJdO1xuICAgICAgICB4WzNdIF49IHlbM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB6WzBdID0geFswXSBeIHlbMF07XG4gICAgICAgIHpbMV0gPSB4WzFdIF4geVsxXTtcbiAgICAgICAgelsyXSA9IHhbMl0gXiB5WzJdO1xuICAgICAgICB6WzNdID0geFszXSBeIHlbM107XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDIgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcblxuICBtdWx0aXBseTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByMCA9IHguc2xpY2UoKTtcbiAgICB2YXIgcjEgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICB2YXIgYml0cyA9IHlbaV07XG4gICAgICBmb3IgKHZhciBqID0gMzE7IGogPj0gMDsgLS1qKSB7XG4gICAgICAgIGlmICgoYml0cyAmICgxIDw8IGopKSAhPT0gMCkge1xuICAgICAgICAgIGhlbHBlcnMueG9yKHIxLCByMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVscGVycy5zaGlmdFJpZ2h0KHIwKSAhPT0gMCkge1xuICAgICAgICAgIHIwWzBdIF49IGhlbHBlcnMuRTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBoZWxwZXJzLmFycmF5Q29weShyMSwgMCwgeCwgMCwgNCk7XG4gIH0sXG4gIG11bHRpcGx5UDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoaGVscGVycy5zaGlmdFJpZ2h0KHgpICE9PSAwKSB7XG4gICAgICAgICAgeFswXSBePSBoZWxwZXJzLkUxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAoaGVscGVycy5zaGlmdFJpZ2h0KHgsIHkpICE9PSAwKSB7XG4gICAgICAgICAgeVswXSBePSBoZWxwZXJzLkUxO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMiBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcbiAgbXVsdGlwbHlQODogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBjO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBjID0gaGVscGVycy5zaGlmdFJpZ2h0Tih4LCA4KTtcbiAgICAgICAgeFswXSBePSBoZWxwZXJzLkxPT0tVUFtjID4+PiAyNF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBjID0gaGVscGVycy5zaGlmdFJpZ2h0Tih4LCA4LCB5KTtcbiAgICAgICAgeVswXSBePSBoZWxwZXJzLkxPT0tVUFtjID4+PiAyNF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMiBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/index.js - AES-GCM implementation Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\"),\n    forge = __webpack_require__(/*! ../../../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    multipliers = __webpack_require__(/*! ./multipliers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\"),\n    DataBuffer = __webpack_require__(/*! ../../../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    cipherHelpers = __webpack_require__(/*! ../helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js\");\n\nvar BLOCK_SIZE = 16;\n\n// ### GCM Mode\n// ### Constructor\nfunction Gcm(options) {\n  options = options || {};\n\n  this.name = \"GCM\";\n  this.cipher = options.cipher;\n  this.blockSize = this.blockSize || 16;\n}\n\n// ### exports\nmodule.exports = {\n  createCipher: function(options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode.start(options);\n\n    return alg.mode;\n  },\n  createDecipher: function(options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode._decrypt = true;\n    alg.mode.start(options);\n\n    return alg.mode;\n  }\n};\n\n// ### Public API\nGcm.prototype.start = function(options) {\n  this.tag = null;\n\n  options = options || {};\n\n  if (!(\"iv\" in options)) {\n    throw new Error(\"Gcm needs ParametersWithIV or AEADParameters\");\n  }\n  this.nonce = options.iv;\n  if (this.nonce == null || this.nonce.length < 1) {\n    throw new Error(\"IV must be at least 1 byte\");\n  }\n\n  // TODO: variable tagLength?\n  this.tagLength = 16;\n\n  // TODO: validate tag\n  if (\"tag\" in options) {\n    this.tag = Buffer.from(options.tag);\n  }\n\n  var bufLength = !this._decrypt ?\n                  this.blockSize :\n                  (this.blockSize + this.tagLength);\n  this.bufBlock = Buffer.alloc(bufLength);\n\n  var multiplier = options.multiplier;\n  if (multiplier == null) {\n    multiplier = new (multipliers[\"8k\"])();\n  }\n  this.multiplier = multiplier;\n\n  this.H = this.zeroBlock();\n  cipherHelpers.encrypt(this.cipher, this.H, 0, this.H, 0);\n\n  // GcmMultiplier tables don\"t change unless the key changes\n  // (and are expensive to init)\n  this.multiplier.init(this.H);\n  this.exp = null;\n\n  this.J0 = this.zeroBlock();\n\n  if (this.nonce.length === 12) {\n    this.nonce.copy(this.J0, 0, 0, this.nonce.length);\n    this.J0[this.blockSize - 1] = 0x01;\n  } else {\n    this.gHASH(this.J0, this.nonce, this.nonce.length);\n    var X = this.zeroBlock();\n    pack.longToBigEndian(new Long(this.nonce.length).\n                         multiply(8), X, 8);\n    this.gHASHBlock(this.J0, X);\n  }\n\n  this.S = this.zeroBlock();\n  this.SAt = this.zeroBlock();\n  this.SAtPre = this.zeroBlock();\n  this.atBlock = this.zeroBlock();\n  this.atBlockPos = 0;\n  this.atLength = Long.ZERO;\n  this.atLengthPre = Long.ZERO;\n  this.counter = Buffer.from(this.J0);\n  this.bufOff = 0;\n  this.totalLength = Long.ZERO;\n\n  if (\"additionalData\" in options) {\n    this.processAADBytes(options.additionalData, 0, options.additionalData.length);\n  }\n};\n\nGcm.prototype.update = function(inV, inOff, len, out, outOff) {\n  var resultLen = 0;\n\n  while (len > 0) {\n    var inLen = Math.min(len, this.bufBlock.length - this.bufOff);\n    inV.copy(this.bufBlock, this.bufOff, inOff, inOff + inLen);\n    len -= inLen;\n    inOff += inLen;\n    this.bufOff += inLen;\n    if (this.bufOff === this.bufBlock.length) {\n      this.outputBlock(out, outOff + resultLen);\n      resultLen += this.blockSize;\n    }\n  }\n\n  return resultLen;\n};\nGcm.prototype.finish = function(out, outOff) {\n  var resultLen = 0;\n\n  if (this._decrypt) {\n    // append tag\n    resultLen += this.update(this.tag, 0, this.tag.length, out, outOff);\n  }\n\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n\n  var extra = this.bufOff;\n  if (this._decrypt) {\n    if (extra < this.tagLength) {\n      throw new Error(\"data too short\");\n    }\n    extra -= this.tagLength;\n  }\n\n  if (extra > 0) {\n    this.gCTRPartial(this.bufBlock, 0, extra, out, outOff + resultLen);\n    resultLen += extra;\n  }\n\n  this.atLength = this.atLength.add(this.atBlockPos);\n\n  // Final gHASH\n  var X = this.zeroBlock();\n  pack.longToBigEndian(this.atLength.multiply(8),\n                       X,\n                       0);\n  pack.longToBigEndian(this.totalLength.multiply(8),\n                       X,\n                       8);\n\n  this.gHASHBlock(this.S, X);\n\n  // TODO Fix this if tagLength becomes configurable\n  // T = MSBt(GCTRk(J0,S))\n  var tag = Buffer.alloc(this.blockSize);\n  cipherHelpers.encrypt(this.cipher, this.J0, 0, tag, 0);\n  this.xor(tag, this.S);\n\n  if (this._decrypt) {\n    if (!helpers.arrayEqual(this.tag, tag)) {\n      throw new Error(\"mac check in Gcm failed\");\n    }\n  } else {\n    // We place into tag our calculated value for T\n    this.tag = Buffer.alloc(this.tagLength);\n    tag.copy(this.tag, 0, 0, this.tagLength);\n  }\n\n  return resultLen;\n};\n\n// ### \"Internal\" Helper Functions\nGcm.prototype.initCipher = function() {\n  if (this.atLength.greaterThan(Long.ZERO)) {\n    this.SAt.copy(this.SAtPre, 0, 0, this.blockSize);\n    this.atLengthPre = this.atLength.add(Long.ZERO);\n  }\n\n  // Finish hash for partial AAD block\n  if (this.atBlockPos > 0) {\n    this.gHASHPartial(this.SAtPre, this.atBlock, 0, this.atBlockPos);\n    this.atLengthPre = this.atLengthPre.add(this.atBlockPos);\n  }\n\n  if (this.atLengthPre.greaterThan(Long.ZERO)) {\n    this.SAtPre.copy(this.S, 0, 0, this.blockSize);\n  }\n};\n\nGcm.prototype.outputBlock = function(output, offset) {\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n  this.gCTRBlock(this.bufBlock, output, offset);\n  if (!this._decrypt) {\n    this.bufOff = 0;\n  } else {\n    this.bufBlock.copy(this.bufBlock, 0, this.blockSize, this.blockSize + this.tagLength);\n    this.bufOff = this.tagLength;\n  }\n};\n\nGcm.prototype.processAADBytes = function(inV, inOff, len) {\n  for (var i = 0; i < len; ++i) {\n    this.atBlock[this.atBlockPos] = inV[inOff + i];\n    if (++this.atBlockPos === this.blockSize) {\n      // Hash each block as it fills\n      this.gHASHBlock(this.SAt, this.atBlock);\n      this.atBlockPos = 0;\n      this.atLength = this.atLength.add(this.blockSize);\n    }\n  }\n};\n\nGcm.prototype.getNextCounterBlock = function() {\n  for (var i = 15; i >= 12; --i) {\n    var b = ((this.counter[i] + 1) & 0xff);\n    this.counter[i] = b;\n\n    if (b !== 0) {\n      break;\n    }\n  }\n\n  // encrypt counter\n  var outb = Buffer.alloc(this.blockSize);\n  cipherHelpers.encrypt(this.cipher, this.counter, 0, outb, 0);\n\n  return outb;\n};\n\nGcm.prototype.gCTRBlock = function(block, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n\n  this.xor(tmp, block);\n  tmp.copy(out, outOff, 0, this.blockSize);\n\n  this.gHASHBlock(this.S, !this._decrypt ? tmp : block);\n\n  this.totalLength = this.totalLength.add(this.blockSize);\n};\nGcm.prototype.gCTRPartial = function(buf, off, len, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n\n  this.xor(tmp, buf, off, len);\n  tmp.copy(out, outOff, 0, len);\n\n  this.gHASHPartial(this.S, !this._decrypt ? tmp : buf, 0, len);\n\n  this.totalLength = this.totalLength.add(len);\n};\n\nGcm.prototype.gHASHBlock = function(Y, b) {\n  this.xor(Y, b);\n  this.multiplier.multiplyH(Y);\n};\nGcm.prototype.gHASHPartial = function(Y, b, off, len) {\n  this.xor(Y, b, off, len);\n  this.multiplier.multiplyH(Y);\n};\n\nGcm.prototype.xor = function(block, val, off, len) {\n  switch (arguments.length) {\n    case 2:\n      for (var i = 15; i >= 0; --i) {\n        block[i] ^= val[i];\n      }\n      break;\n    case 4:\n      while (len-- > 0) {\n        block[len] ^= val[off + len];\n      }\n      break;\n    default:\n      throw new TypeError(\"Expected 2 or 4 arguments.\");\n  }\n\n  return block;\n};\n\nGcm.prototype.zeroBlock = function() {\n  var block = Buffer.alloc(BLOCK_SIZE);\n  return block;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZCxXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLGdGQUF3QjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHdGQUFjO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywwRkFBNkI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWU7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvZ2NtL2luZGV4LmpzPzczNmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkZXBzL2NpcGhlcm1vZGVzL2djbS9pbmRleC5qcyAtIEFFUy1HQ00gaW1wbGVtZW50YXRpb24gRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuIFwidXNlIHN0cmljdFwiO1xuXG52YXIgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uLy4uLy4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgbXVsdGlwbGllcnMgPSByZXF1aXJlKFwiLi9tdWx0aXBsaWVycy5qc1wiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBwYWNrID0gcmVxdWlyZShcIi4uL3BhY2suanNcIiksXG4gICAgRGF0YUJ1ZmZlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL2RhdGFidWZmZXIuanNcIiksXG4gICAgY2lwaGVySGVscGVycyA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzLmpzXCIpO1xuXG52YXIgQkxPQ0tfU0laRSA9IDE2O1xuXG4vLyAjIyMgR0NNIE1vZGVcbi8vICMjIyBDb25zdHJ1Y3RvclxuZnVuY3Rpb24gR2NtKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5uYW1lID0gXCJHQ01cIjtcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmJsb2NrU2l6ZSB8fCAxNjtcbn1cblxuLy8gIyMjIGV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVDaXBoZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgYWxnID0gbmV3IGZvcmdlLmFlcy5BbGdvcml0aG0oXCJBRVMtR0NNXCIsIEdjbSk7XG4gICAgYWxnLmluaXRpYWxpemUoe1xuICAgICAga2V5OiBuZXcgRGF0YUJ1ZmZlcihvcHRpb25zLmtleSlcbiAgICB9KTtcbiAgICBhbGcubW9kZS5zdGFydChvcHRpb25zKTtcblxuICAgIHJldHVybiBhbGcubW9kZTtcbiAgfSxcbiAgY3JlYXRlRGVjaXBoZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgYWxnID0gbmV3IGZvcmdlLmFlcy5BbGdvcml0aG0oXCJBRVMtR0NNXCIsIEdjbSk7XG4gICAgYWxnLmluaXRpYWxpemUoe1xuICAgICAga2V5OiBuZXcgRGF0YUJ1ZmZlcihvcHRpb25zLmtleSlcbiAgICB9KTtcbiAgICBhbGcubW9kZS5fZGVjcnlwdCA9IHRydWU7XG4gICAgYWxnLm1vZGUuc3RhcnQob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gYWxnLm1vZGU7XG4gIH1cbn07XG5cbi8vICMjIyBQdWJsaWMgQVBJXG5HY20ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLnRhZyA9IG51bGw7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCEoXCJpdlwiIGluIG9wdGlvbnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiR2NtIG5lZWRzIFBhcmFtZXRlcnNXaXRoSVYgb3IgQUVBRFBhcmFtZXRlcnNcIik7XG4gIH1cbiAgdGhpcy5ub25jZSA9IG9wdGlvbnMuaXY7XG4gIGlmICh0aGlzLm5vbmNlID09IG51bGwgfHwgdGhpcy5ub25jZS5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSVYgbXVzdCBiZSBhdCBsZWFzdCAxIGJ5dGVcIik7XG4gIH1cblxuICAvLyBUT0RPOiB2YXJpYWJsZSB0YWdMZW5ndGg/XG4gIHRoaXMudGFnTGVuZ3RoID0gMTY7XG5cbiAgLy8gVE9ETzogdmFsaWRhdGUgdGFnXG4gIGlmIChcInRhZ1wiIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLnRhZyA9IEJ1ZmZlci5mcm9tKG9wdGlvbnMudGFnKTtcbiAgfVxuXG4gIHZhciBidWZMZW5ndGggPSAhdGhpcy5fZGVjcnlwdCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2l6ZSA6XG4gICAgICAgICAgICAgICAgICAodGhpcy5ibG9ja1NpemUgKyB0aGlzLnRhZ0xlbmd0aCk7XG4gIHRoaXMuYnVmQmxvY2sgPSBCdWZmZXIuYWxsb2MoYnVmTGVuZ3RoKTtcblxuICB2YXIgbXVsdGlwbGllciA9IG9wdGlvbnMubXVsdGlwbGllcjtcbiAgaWYgKG11bHRpcGxpZXIgPT0gbnVsbCkge1xuICAgIG11bHRpcGxpZXIgPSBuZXcgKG11bHRpcGxpZXJzW1wiOGtcIl0pKCk7XG4gIH1cbiAgdGhpcy5tdWx0aXBsaWVyID0gbXVsdGlwbGllcjtcblxuICB0aGlzLkggPSB0aGlzLnplcm9CbG9jaygpO1xuICBjaXBoZXJIZWxwZXJzLmVuY3J5cHQodGhpcy5jaXBoZXIsIHRoaXMuSCwgMCwgdGhpcy5ILCAwKTtcblxuICAvLyBHY21NdWx0aXBsaWVyIHRhYmxlcyBkb25cInQgY2hhbmdlIHVubGVzcyB0aGUga2V5IGNoYW5nZXNcbiAgLy8gKGFuZCBhcmUgZXhwZW5zaXZlIHRvIGluaXQpXG4gIHRoaXMubXVsdGlwbGllci5pbml0KHRoaXMuSCk7XG4gIHRoaXMuZXhwID0gbnVsbDtcblxuICB0aGlzLkowID0gdGhpcy56ZXJvQmxvY2soKTtcblxuICBpZiAodGhpcy5ub25jZS5sZW5ndGggPT09IDEyKSB7XG4gICAgdGhpcy5ub25jZS5jb3B5KHRoaXMuSjAsIDAsIDAsIHRoaXMubm9uY2UubGVuZ3RoKTtcbiAgICB0aGlzLkowW3RoaXMuYmxvY2tTaXplIC0gMV0gPSAweDAxO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ0hBU0godGhpcy5KMCwgdGhpcy5ub25jZSwgdGhpcy5ub25jZS5sZW5ndGgpO1xuICAgIHZhciBYID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgICBwYWNrLmxvbmdUb0JpZ0VuZGlhbihuZXcgTG9uZyh0aGlzLm5vbmNlLmxlbmd0aCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbHkoOCksIFgsIDgpO1xuICAgIHRoaXMuZ0hBU0hCbG9jayh0aGlzLkowLCBYKTtcbiAgfVxuXG4gIHRoaXMuUyA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gIHRoaXMuU0F0ID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgdGhpcy5TQXRQcmUgPSB0aGlzLnplcm9CbG9jaygpO1xuICB0aGlzLmF0QmxvY2sgPSB0aGlzLnplcm9CbG9jaygpO1xuICB0aGlzLmF0QmxvY2tQb3MgPSAwO1xuICB0aGlzLmF0TGVuZ3RoID0gTG9uZy5aRVJPO1xuICB0aGlzLmF0TGVuZ3RoUHJlID0gTG9uZy5aRVJPO1xuICB0aGlzLmNvdW50ZXIgPSBCdWZmZXIuZnJvbSh0aGlzLkowKTtcbiAgdGhpcy5idWZPZmYgPSAwO1xuICB0aGlzLnRvdGFsTGVuZ3RoID0gTG9uZy5aRVJPO1xuXG4gIGlmIChcImFkZGl0aW9uYWxEYXRhXCIgaW4gb3B0aW9ucykge1xuICAgIHRoaXMucHJvY2Vzc0FBREJ5dGVzKG9wdGlvbnMuYWRkaXRpb25hbERhdGEsIDAsIG9wdGlvbnMuYWRkaXRpb25hbERhdGEubGVuZ3RoKTtcbiAgfVxufTtcblxuR2NtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihpblYsIGluT2ZmLCBsZW4sIG91dCwgb3V0T2ZmKSB7XG4gIHZhciByZXN1bHRMZW4gPSAwO1xuXG4gIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgdmFyIGluTGVuID0gTWF0aC5taW4obGVuLCB0aGlzLmJ1ZkJsb2NrLmxlbmd0aCAtIHRoaXMuYnVmT2ZmKTtcbiAgICBpblYuY29weSh0aGlzLmJ1ZkJsb2NrLCB0aGlzLmJ1Zk9mZiwgaW5PZmYsIGluT2ZmICsgaW5MZW4pO1xuICAgIGxlbiAtPSBpbkxlbjtcbiAgICBpbk9mZiArPSBpbkxlbjtcbiAgICB0aGlzLmJ1Zk9mZiArPSBpbkxlbjtcbiAgICBpZiAodGhpcy5idWZPZmYgPT09IHRoaXMuYnVmQmxvY2subGVuZ3RoKSB7XG4gICAgICB0aGlzLm91dHB1dEJsb2NrKG91dCwgb3V0T2ZmICsgcmVzdWx0TGVuKTtcbiAgICAgIHJlc3VsdExlbiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0TGVuO1xufTtcbkdjbS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24ob3V0LCBvdXRPZmYpIHtcbiAgdmFyIHJlc3VsdExlbiA9IDA7XG5cbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICAvLyBhcHBlbmQgdGFnXG4gICAgcmVzdWx0TGVuICs9IHRoaXMudXBkYXRlKHRoaXMudGFnLCAwLCB0aGlzLnRhZy5sZW5ndGgsIG91dCwgb3V0T2ZmKTtcbiAgfVxuXG4gIGlmICh0aGlzLnRvdGFsTGVuZ3RoLmlzWmVybygpKSB7XG4gICAgdGhpcy5pbml0Q2lwaGVyKCk7XG4gIH1cblxuICB2YXIgZXh0cmEgPSB0aGlzLmJ1Zk9mZjtcbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICBpZiAoZXh0cmEgPCB0aGlzLnRhZ0xlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSB0b28gc2hvcnRcIik7XG4gICAgfVxuICAgIGV4dHJhIC09IHRoaXMudGFnTGVuZ3RoO1xuICB9XG5cbiAgaWYgKGV4dHJhID4gMCkge1xuICAgIHRoaXMuZ0NUUlBhcnRpYWwodGhpcy5idWZCbG9jaywgMCwgZXh0cmEsIG91dCwgb3V0T2ZmICsgcmVzdWx0TGVuKTtcbiAgICByZXN1bHRMZW4gKz0gZXh0cmE7XG4gIH1cblxuICB0aGlzLmF0TGVuZ3RoID0gdGhpcy5hdExlbmd0aC5hZGQodGhpcy5hdEJsb2NrUG9zKTtcblxuICAvLyBGaW5hbCBnSEFTSFxuICB2YXIgWCA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gIHBhY2subG9uZ1RvQmlnRW5kaWFuKHRoaXMuYXRMZW5ndGgubXVsdGlwbHkoOCksXG4gICAgICAgICAgICAgICAgICAgICAgIFgsXG4gICAgICAgICAgICAgICAgICAgICAgIDApO1xuICBwYWNrLmxvbmdUb0JpZ0VuZGlhbih0aGlzLnRvdGFsTGVuZ3RoLm11bHRpcGx5KDgpLFxuICAgICAgICAgICAgICAgICAgICAgICBYLFxuICAgICAgICAgICAgICAgICAgICAgICA4KTtcblxuICB0aGlzLmdIQVNIQmxvY2sodGhpcy5TLCBYKTtcblxuICAvLyBUT0RPIEZpeCB0aGlzIGlmIHRhZ0xlbmd0aCBiZWNvbWVzIGNvbmZpZ3VyYWJsZVxuICAvLyBUID0gTVNCdChHQ1RSayhKMCxTKSlcbiAgdmFyIHRhZyA9IEJ1ZmZlci5hbGxvYyh0aGlzLmJsb2NrU2l6ZSk7XG4gIGNpcGhlckhlbHBlcnMuZW5jcnlwdCh0aGlzLmNpcGhlciwgdGhpcy5KMCwgMCwgdGFnLCAwKTtcbiAgdGhpcy54b3IodGFnLCB0aGlzLlMpO1xuXG4gIGlmICh0aGlzLl9kZWNyeXB0KSB7XG4gICAgaWYgKCFoZWxwZXJzLmFycmF5RXF1YWwodGhpcy50YWcsIHRhZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hYyBjaGVjayBpbiBHY20gZmFpbGVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBwbGFjZSBpbnRvIHRhZyBvdXIgY2FsY3VsYXRlZCB2YWx1ZSBmb3IgVFxuICAgIHRoaXMudGFnID0gQnVmZmVyLmFsbG9jKHRoaXMudGFnTGVuZ3RoKTtcbiAgICB0YWcuY29weSh0aGlzLnRhZywgMCwgMCwgdGhpcy50YWdMZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdExlbjtcbn07XG5cbi8vICMjIyBcIkludGVybmFsXCIgSGVscGVyIEZ1bmN0aW9uc1xuR2NtLnByb3RvdHlwZS5pbml0Q2lwaGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmF0TGVuZ3RoLmdyZWF0ZXJUaGFuKExvbmcuWkVSTykpIHtcbiAgICB0aGlzLlNBdC5jb3B5KHRoaXMuU0F0UHJlLCAwLCAwLCB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgdGhpcy5hdExlbmd0aFByZSA9IHRoaXMuYXRMZW5ndGguYWRkKExvbmcuWkVSTyk7XG4gIH1cblxuICAvLyBGaW5pc2ggaGFzaCBmb3IgcGFydGlhbCBBQUQgYmxvY2tcbiAgaWYgKHRoaXMuYXRCbG9ja1BvcyA+IDApIHtcbiAgICB0aGlzLmdIQVNIUGFydGlhbCh0aGlzLlNBdFByZSwgdGhpcy5hdEJsb2NrLCAwLCB0aGlzLmF0QmxvY2tQb3MpO1xuICAgIHRoaXMuYXRMZW5ndGhQcmUgPSB0aGlzLmF0TGVuZ3RoUHJlLmFkZCh0aGlzLmF0QmxvY2tQb3MpO1xuICB9XG5cbiAgaWYgKHRoaXMuYXRMZW5ndGhQcmUuZ3JlYXRlclRoYW4oTG9uZy5aRVJPKSkge1xuICAgIHRoaXMuU0F0UHJlLmNvcHkodGhpcy5TLCAwLCAwLCB0aGlzLmJsb2NrU2l6ZSk7XG4gIH1cbn07XG5cbkdjbS5wcm90b3R5cGUub3V0cHV0QmxvY2sgPSBmdW5jdGlvbihvdXRwdXQsIG9mZnNldCkge1xuICBpZiAodGhpcy50b3RhbExlbmd0aC5pc1plcm8oKSkge1xuICAgIHRoaXMuaW5pdENpcGhlcigpO1xuICB9XG4gIHRoaXMuZ0NUUkJsb2NrKHRoaXMuYnVmQmxvY2ssIG91dHB1dCwgb2Zmc2V0KTtcbiAgaWYgKCF0aGlzLl9kZWNyeXB0KSB7XG4gICAgdGhpcy5idWZPZmYgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYnVmQmxvY2suY29weSh0aGlzLmJ1ZkJsb2NrLCAwLCB0aGlzLmJsb2NrU2l6ZSwgdGhpcy5ibG9ja1NpemUgKyB0aGlzLnRhZ0xlbmd0aCk7XG4gICAgdGhpcy5idWZPZmYgPSB0aGlzLnRhZ0xlbmd0aDtcbiAgfVxufTtcblxuR2NtLnByb3RvdHlwZS5wcm9jZXNzQUFEQnl0ZXMgPSBmdW5jdGlvbihpblYsIGluT2ZmLCBsZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHRoaXMuYXRCbG9ja1t0aGlzLmF0QmxvY2tQb3NdID0gaW5WW2luT2ZmICsgaV07XG4gICAgaWYgKCsrdGhpcy5hdEJsb2NrUG9zID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgLy8gSGFzaCBlYWNoIGJsb2NrIGFzIGl0IGZpbGxzXG4gICAgICB0aGlzLmdIQVNIQmxvY2sodGhpcy5TQXQsIHRoaXMuYXRCbG9jayk7XG4gICAgICB0aGlzLmF0QmxvY2tQb3MgPSAwO1xuICAgICAgdGhpcy5hdExlbmd0aCA9IHRoaXMuYXRMZW5ndGguYWRkKHRoaXMuYmxvY2tTaXplKTtcbiAgICB9XG4gIH1cbn07XG5cbkdjbS5wcm90b3R5cGUuZ2V0TmV4dENvdW50ZXJCbG9jayA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMTU7IGkgPj0gMTI7IC0taSkge1xuICAgIHZhciBiID0gKCh0aGlzLmNvdW50ZXJbaV0gKyAxKSAmIDB4ZmYpO1xuICAgIHRoaXMuY291bnRlcltpXSA9IGI7XG5cbiAgICBpZiAoYiAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5jcnlwdCBjb3VudGVyXG4gIHZhciBvdXRiID0gQnVmZmVyLmFsbG9jKHRoaXMuYmxvY2tTaXplKTtcbiAgY2lwaGVySGVscGVycy5lbmNyeXB0KHRoaXMuY2lwaGVyLCB0aGlzLmNvdW50ZXIsIDAsIG91dGIsIDApO1xuXG4gIHJldHVybiBvdXRiO1xufTtcblxuR2NtLnByb3RvdHlwZS5nQ1RSQmxvY2sgPSBmdW5jdGlvbihibG9jaywgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHRtcCA9IHRoaXMuZ2V0TmV4dENvdW50ZXJCbG9jaygpO1xuXG4gIHRoaXMueG9yKHRtcCwgYmxvY2spO1xuICB0bXAuY29weShvdXQsIG91dE9mZiwgMCwgdGhpcy5ibG9ja1NpemUpO1xuXG4gIHRoaXMuZ0hBU0hCbG9jayh0aGlzLlMsICF0aGlzLl9kZWNyeXB0ID8gdG1wIDogYmxvY2spO1xuXG4gIHRoaXMudG90YWxMZW5ndGggPSB0aGlzLnRvdGFsTGVuZ3RoLmFkZCh0aGlzLmJsb2NrU2l6ZSk7XG59O1xuR2NtLnByb3RvdHlwZS5nQ1RSUGFydGlhbCA9IGZ1bmN0aW9uKGJ1Ziwgb2ZmLCBsZW4sIG91dCwgb3V0T2ZmKSB7XG4gIHZhciB0bXAgPSB0aGlzLmdldE5leHRDb3VudGVyQmxvY2soKTtcblxuICB0aGlzLnhvcih0bXAsIGJ1Ziwgb2ZmLCBsZW4pO1xuICB0bXAuY29weShvdXQsIG91dE9mZiwgMCwgbGVuKTtcblxuICB0aGlzLmdIQVNIUGFydGlhbCh0aGlzLlMsICF0aGlzLl9kZWNyeXB0ID8gdG1wIDogYnVmLCAwLCBsZW4pO1xuXG4gIHRoaXMudG90YWxMZW5ndGggPSB0aGlzLnRvdGFsTGVuZ3RoLmFkZChsZW4pO1xufTtcblxuR2NtLnByb3RvdHlwZS5nSEFTSEJsb2NrID0gZnVuY3Rpb24oWSwgYikge1xuICB0aGlzLnhvcihZLCBiKTtcbiAgdGhpcy5tdWx0aXBsaWVyLm11bHRpcGx5SChZKTtcbn07XG5HY20ucHJvdG90eXBlLmdIQVNIUGFydGlhbCA9IGZ1bmN0aW9uKFksIGIsIG9mZiwgbGVuKSB7XG4gIHRoaXMueG9yKFksIGIsIG9mZiwgbGVuKTtcbiAgdGhpcy5tdWx0aXBsaWVyLm11bHRpcGx5SChZKTtcbn07XG5cbkdjbS5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24oYmxvY2ssIHZhbCwgb2ZmLCBsZW4pIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAyOlxuICAgICAgZm9yICh2YXIgaSA9IDE1OyBpID49IDA7IC0taSkge1xuICAgICAgICBibG9ja1tpXSBePSB2YWxbaV07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICAgIGJsb2NrW2xlbl0gXj0gdmFsW29mZiArIGxlbl07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDIgb3IgNCBhcmd1bWVudHMuXCIpO1xuICB9XG5cbiAgcmV0dXJuIGJsb2NrO1xufTtcblxuR2NtLnByb3RvdHlwZS56ZXJvQmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJsb2NrID0gQnVmZmVyLmFsbG9jKEJMT0NLX1NJWkUpO1xuICByZXR1cm4gYmxvY2s7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/multipliers.js - AES-GCM Multipliers\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\n\n// ### 8K Table Multiplier\nfunction Gcm8KMultiplier() {\n  this.H = [];\n  this.M = null;\n}\n\nGcm8KMultiplier.prototype.init = function(H) {\n  var i, j, k;\n  if (this.M == null) {\n    // sc: I realize this UGLY...\n    //M = new int[32][16][4];\n    this.M = [];\n    for (i = 0; i < 32; ++i) {\n      this.M[i] = [];\n      for (j = 0; j < 16; ++j) {\n        this.M[i][j] = [];\n        for (k = 0; k < 4; ++k) {\n          this.M[i][j][k] = 0;\n        }\n      }\n    }\n  } else if (helpers.arrayEqual(this.H, H)) {\n    return;\n  }\n\n  this.H = H.slice();\n\n  // M[0][0] is ZEROES;\n  // M[1][0] is ZEROES;\n  helpers.asInts(H, this.M[1][8]);\n\n  for (j = 4; j >= 1; j >>= 1) {\n    helpers.multiplyP(this.M[1][j + j], this.M[1][j]);\n  }\n  helpers.multiplyP(this.M[1][1], this.M[0][8]);\n\n  for (j = 4; j >= 1; j >>= 1) {\n    helpers.multiplyP(this.M[0][j + j], this.M[0][j]);\n  }\n\n  i = 0;\n  for (;;) {\n    for (j = 2; j < 16; j += j) {\n      for (k = 1; k < j; ++k) {\n        helpers.xor(this.M[i][j], this.M[i][k], this.M[i][j + k]);\n      }\n    }\n\n    if (++i === 32) {\n      return;\n    }\n\n    if (i > 1) {\n      // M[i][0] is ZEROES;\n      for (j = 8; j > 0; j >>= 1) {\n        helpers.multiplyP8(this.M[i - 2][j], this.M[i][j]);\n      }\n    }\n  }\n};\nGcm8KMultiplier.prototype.multiplyH = function(x) {\n  var z = [];\n  for (var i = 15; i >= 0; --i) {\n    var m = this.M[i + i][x[i] & 0x0f];\n    z[0] ^= m[0];\n    z[1] ^= m[1];\n    z[2] ^= m[2];\n    z[3] ^= m[3];\n    m = this.M[i + i + 1][(x[i] & 0xf0) >>> 4];\n    z[0] ^= m[0];\n    z[1] ^= m[1];\n    z[2] ^= m[2];\n    z[3] ^= m[3];\n  }\n\n  pack.intToBigEndian(z, x, 0);\n};\n\n\nmodule.exports = {\n  \"8k\": Gcm8KMultiplier\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9tdWx0aXBsaWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZCxjQUFjLG1CQUFPLENBQUMsd0ZBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLCtFQUFZOzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsUUFBUTtBQUN4QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvZ2NtL211bHRpcGxpZXJzLmpzPzE0Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkZXBzL2NpcGhlcm1vZGVzL2djbS9tdWx0aXBsaWVycy5qcyAtIEFFUy1HQ00gTXVsdGlwbGllcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuIFwidXNlIHN0cmljdFwiO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgcGFjayA9IHJlcXVpcmUoXCIuLi9wYWNrLmpzXCIpO1xuXG5cbi8vICMjIyA4SyBUYWJsZSBNdWx0aXBsaWVyXG5mdW5jdGlvbiBHY204S011bHRpcGxpZXIoKSB7XG4gIHRoaXMuSCA9IFtdO1xuICB0aGlzLk0gPSBudWxsO1xufVxuXG5HY204S011bHRpcGxpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihIKSB7XG4gIHZhciBpLCBqLCBrO1xuICBpZiAodGhpcy5NID09IG51bGwpIHtcbiAgICAvLyBzYzogSSByZWFsaXplIHRoaXMgVUdMWS4uLlxuICAgIC8vTSA9IG5ldyBpbnRbMzJdWzE2XVs0XTtcbiAgICB0aGlzLk0gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgdGhpcy5NW2ldID0gW107XG4gICAgICBmb3IgKGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgICB0aGlzLk1baV1bal0gPSBbXTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IDQ7ICsraykge1xuICAgICAgICAgIHRoaXMuTVtpXVtqXVtrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaGVscGVycy5hcnJheUVxdWFsKHRoaXMuSCwgSCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLkggPSBILnNsaWNlKCk7XG5cbiAgLy8gTVswXVswXSBpcyBaRVJPRVM7XG4gIC8vIE1bMV1bMF0gaXMgWkVST0VTO1xuICBoZWxwZXJzLmFzSW50cyhILCB0aGlzLk1bMV1bOF0pO1xuXG4gIGZvciAoaiA9IDQ7IGogPj0gMTsgaiA+Pj0gMSkge1xuICAgIGhlbHBlcnMubXVsdGlwbHlQKHRoaXMuTVsxXVtqICsgal0sIHRoaXMuTVsxXVtqXSk7XG4gIH1cbiAgaGVscGVycy5tdWx0aXBseVAodGhpcy5NWzFdWzFdLCB0aGlzLk1bMF1bOF0pO1xuXG4gIGZvciAoaiA9IDQ7IGogPj0gMTsgaiA+Pj0gMSkge1xuICAgIGhlbHBlcnMubXVsdGlwbHlQKHRoaXMuTVswXVtqICsgal0sIHRoaXMuTVswXVtqXSk7XG4gIH1cblxuICBpID0gMDtcbiAgZm9yICg7Oykge1xuICAgIGZvciAoaiA9IDI7IGogPCAxNjsgaiArPSBqKSB7XG4gICAgICBmb3IgKGsgPSAxOyBrIDwgajsgKytrKSB7XG4gICAgICAgIGhlbHBlcnMueG9yKHRoaXMuTVtpXVtqXSwgdGhpcy5NW2ldW2tdLCB0aGlzLk1baV1baiArIGtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKytpID09PSAzMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpID4gMSkge1xuICAgICAgLy8gTVtpXVswXSBpcyBaRVJPRVM7XG4gICAgICBmb3IgKGogPSA4OyBqID4gMDsgaiA+Pj0gMSkge1xuICAgICAgICBoZWxwZXJzLm11bHRpcGx5UDgodGhpcy5NW2kgLSAyXVtqXSwgdGhpcy5NW2ldW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5HY204S011bHRpcGxpZXIucHJvdG90eXBlLm11bHRpcGx5SCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHogPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE1OyBpID49IDA7IC0taSkge1xuICAgIHZhciBtID0gdGhpcy5NW2kgKyBpXVt4W2ldICYgMHgwZl07XG4gICAgelswXSBePSBtWzBdO1xuICAgIHpbMV0gXj0gbVsxXTtcbiAgICB6WzJdIF49IG1bMl07XG4gICAgelszXSBePSBtWzNdO1xuICAgIG0gPSB0aGlzLk1baSArIGkgKyAxXVsoeFtpXSAmIDB4ZjApID4+PiA0XTtcbiAgICB6WzBdIF49IG1bMF07XG4gICAgelsxXSBePSBtWzFdO1xuICAgIHpbMl0gXj0gbVsyXTtcbiAgICB6WzNdIF49IG1bM107XG4gIH1cblxuICBwYWNrLmludFRvQmlnRW5kaWFuKHosIHgsIDApO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCI4a1wiOiBHY204S011bHRpcGxpZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/helpers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/helpers.js - Cipher Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar pack = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\nfunction doEncrypt(cipher, inb, inOff, outb, outOff) {\n  var input = new Array(4),\n      output = new Array(4);\n\n  pack.bigEndianToInt(inb, inOff, input);\n  cipher.encrypt(input, output);\n  pack.intToBigEndian(output, outb, outOff);\n}\n\nmodule.exports = {\n  encrypt: doEncrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyw4RUFBVzs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2hlbHBlcnMuanM/YzgxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRlcHMvY2lwaGVybW9kZXMvaGVscGVycy5qcyAtIENpcGhlciBIZWxwZXIgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcGFjayA9IHJlcXVpcmUoXCIuL3BhY2suanNcIik7XG5cbmZ1bmN0aW9uIGRvRW5jcnlwdChjaXBoZXIsIGluYiwgaW5PZmYsIG91dGIsIG91dE9mZikge1xuICB2YXIgaW5wdXQgPSBuZXcgQXJyYXkoNCksXG4gICAgICBvdXRwdXQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgcGFjay5iaWdFbmRpYW5Ub0ludChpbmIsIGluT2ZmLCBpbnB1dCk7XG4gIGNpcGhlci5lbmNyeXB0KGlucHV0LCBvdXRwdXQpO1xuICBwYWNrLmludFRvQmlnRW5kaWFuKG91dHB1dCwgb3V0Yiwgb3V0T2ZmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY3J5cHQ6IGRvRW5jcnlwdFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/pack.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/pack.js - Pack/Unpack Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\n\nvar pack = module.exports = {\n  intToBigEndian: function(n, bs, off) {\n    if (typeof n === \"number\") {\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(4);\n          pack.intToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          bs[off] = 0xff & (n >>> 24);\n          bs[++off] = 0xff & (n >>> 16);\n          bs[++off] = 0xff & (n >>> 8);\n          bs[++off] = 0xff & (n);\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(4 * n.length);\n          pack.intToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          for (var i = 0; i < n.length; ++i) {\n            pack.intToBigEndian(n[i], bs, off);\n            off += 4;\n          }\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    }\n\n    return bs;\n  },\n  longToBigEndian: function(n, bs, off) {\n    if (!Array.isArray(n)) {\n      // Single\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(8);\n          pack.longToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          var lo = n.low,\n              hi = n.high;\n          pack.intToBigEndian(hi, bs, off);\n          pack.intToBigEndian(lo, bs, off + 4);\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    } else {\n      // Array\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(8 * n.length);\n          pack.longToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          for (var i = 0; i < n.length; ++i) {\n            pack.longToBigEndian(n[i], bs, off);\n            off += 8;\n          }\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    }\n\n    return bs;\n  },\n\n  bigEndianToInt: function(bs, off, ns) {\n    switch (arguments.length) {\n      case 2:\n        var n = bs[off] << 24;\n        n |= (bs[++off] & 0xff) << 16;\n        n |= (bs[++off] & 0xff) << 8;\n        n |= (bs[++off] & 0xff);\n        return n;\n      case 3:\n        for (var i = 0; i < ns.length; ++i) {\n          ns[i] = pack.bigEndianToInt(bs, off);\n          off += 4;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n  bigEndianToLong: function(bs, off, ns) {\n    switch (arguments.length) {\n      case 2:\n        var hi = pack.bigEndianToInt(bs, off);\n        var lo = pack.bigEndianToInt(bs, off + 4);\n        var num = new Long(lo, hi);\n        return num;\n      case 3:\n        for (var i = 0; i < ns.length; ++i) {\n          ns[i] = pack.bigEndianToLong(bs, off);\n          off += 8;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL3BhY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvcGFjay5qcz9jOGQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZGVwcy9jaXBoZXJtb2Rlcy9wYWNrLmpzIC0gUGFjay9VbnBhY2sgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpO1xuXG52YXIgcGFjayA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBpbnRUb0JpZ0VuZGlhbjogZnVuY3Rpb24obiwgYnMsIG9mZikge1xuICAgIGlmICh0eXBlb2YgbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBicyA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKG4sIGJzLCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGJzW29mZl0gPSAweGZmICYgKG4gPj4+IDI0KTtcbiAgICAgICAgICBic1srK29mZl0gPSAweGZmICYgKG4gPj4+IDE2KTtcbiAgICAgICAgICBic1srK29mZl0gPSAweGZmICYgKG4gPj4+IDgpO1xuICAgICAgICAgIGJzWysrb2ZmXSA9IDB4ZmYgJiAobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJzID0gQnVmZmVyLmFsbG9jKDQgKiBuLmxlbmd0aCk7XG4gICAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbihuLCBicywgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4obltpXSwgYnMsIG9mZik7XG4gICAgICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDEgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBicztcbiAgfSxcbiAgbG9uZ1RvQmlnRW5kaWFuOiBmdW5jdGlvbihuLCBicywgb2ZmKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG4pKSB7XG4gICAgICAvLyBTaW5nbGVcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnMgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgICAgICAgcGFjay5sb25nVG9CaWdFbmRpYW4obiwgYnMsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIGxvID0gbi5sb3csXG4gICAgICAgICAgICAgIGhpID0gbi5oaWdoO1xuICAgICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4oaGksIGJzLCBvZmYpO1xuICAgICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4obG8sIGJzLCBvZmYgKyA0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFycmF5XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJzID0gQnVmZmVyLmFsbG9jKDggKiBuLmxlbmd0aCk7XG4gICAgICAgICAgcGFjay5sb25nVG9CaWdFbmRpYW4obiwgYnMsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwYWNrLmxvbmdUb0JpZ0VuZGlhbihuW2ldLCBicywgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJzO1xuICB9LFxuXG4gIGJpZ0VuZGlhblRvSW50OiBmdW5jdGlvbihicywgb2ZmLCBucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICB2YXIgbiA9IGJzW29mZl0gPDwgMjQ7XG4gICAgICAgIG4gfD0gKGJzWysrb2ZmXSAmIDB4ZmYpIDw8IDE2O1xuICAgICAgICBuIHw9IChic1srK29mZl0gJiAweGZmKSA8PCA4O1xuICAgICAgICBuIHw9IChic1srK29mZl0gJiAweGZmKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBuc1tpXSA9IHBhY2suYmlnRW5kaWFuVG9JbnQoYnMsIG9mZik7XG4gICAgICAgICAgb2ZmICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMiBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuICBiaWdFbmRpYW5Ub0xvbmc6IGZ1bmN0aW9uKGJzLCBvZmYsIG5zKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHZhciBoaSA9IHBhY2suYmlnRW5kaWFuVG9JbnQoYnMsIG9mZik7XG4gICAgICAgIHZhciBsbyA9IHBhY2suYmlnRW5kaWFuVG9JbnQoYnMsIG9mZiArIDQpO1xuICAgICAgICB2YXIgbnVtID0gbmV3IExvbmcobG8sIGhpKTtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG5zW2ldID0gcGFjay5iaWdFbmRpYW5Ub0xvbmcoYnMsIG9mZik7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMiBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/curves.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * deps/ecc/curves.js - Elliptic Curve NIST/SECG/X9.62 Parameters\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\n\n// Named EC curves\n\nvar BigInteger = (__webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\").jsbn).BigInteger,\n    ec = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\");\n\n// ----------------\n// X9ECParameters\n\n// constructor\nfunction X9ECParameters(curve, g, n, h) {\n  this.curve = curve;\n  this.g = g;\n  this.n = n;\n  this.h = h;\n}\n\nfunction x9getCurve() {\n  return this.curve;\n}\n\nfunction x9getG() {\n  return this.g;\n}\n\nfunction x9getN() {\n  return this.n;\n}\n\nfunction x9getH() {\n  return this.h;\n}\n\nX9ECParameters.prototype.getCurve = x9getCurve;\nX9ECParameters.prototype.getG = x9getG;\nX9ECParameters.prototype.getN = x9getN;\nX9ECParameters.prototype.getH = x9getH;\n\n// ----------------\n// SECNamedCurves\n\nfunction fromHex(s) { return new BigInteger(s, 16); }\n\nfunction secp256r1() {\n  // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1\n  var p = fromHex(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\");\n  var a = fromHex(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\");\n  var b = fromHex(\"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\");\n  var n = fromHex(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n              + \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\"\n              + \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\nfunction secp384r1() {\n  // p = 2^384 - 2^128 - 2^96 + 2^32 - 1\n  var p = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\");\n  var a = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\");\n  var b = fromHex(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\");\n  var n = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n              + \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\"\n              + \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\nfunction secp521r1() {\n  // p = 2^521 - 1\n  var p = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n  var a = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\");\n  var b = fromHex(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\");\n  var n = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n                + \"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\"\n                + \"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\n// ----------------\n// Public API\n\nvar CURVES = module.exports = {\n  \"secp256r1\": secp256r1(),\n  \"secp384r1\": secp384r1(),\n  \"secp521r1\": secp521r1()\n};\n\n// also export NIST names\nCURVES[\"P-256\"] = CURVES.secp256r1;\nCURVES[\"P-384\"] = CURVES.secp384r1;\nCURVES[\"P-521\"] = CURVES.secp521r1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9jdXJ2ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjs7QUFFQSxpQkFBaUIsc0dBQWdDO0FBQ2pELFNBQVMsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9jdXJ2ZXMuanM/YjhmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRlcHMvZWNjL2N1cnZlcy5qcyAtIEVsbGlwdGljIEN1cnZlIE5JU1QvU0VDRy9YOS42MiBQYXJhbWV0ZXJzXG4gKiBPcmlnaW5hbCBDb3B5cmlnaHQgKGMpIDIwMDMtMjAwNSAgVG9tIFd1LlxuICogTW9kaWZpY2F0aW9ucyBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqXG4gKiBQb3J0ZWQgZnJvbSBUb20gV3UsIHdoaWNoIGlzIHBvcnRlZCBmcm9tIEJvdW5jeUNhc3RsZVxuICogTW9kaWZpZWQgdG8gcmV1c2UgZXhpc3RpbmcgZXh0ZXJuYWwgTlBNIG1vZHVsZXMsIHJlc3RyaWN0ZWQgdG8gdGhlXG4gKiBOSVNULy9TRUNHL1g5LjYyIHByaW1lIGN1cnZlcyBvbmx5LCBhbmQgZm9ybWF0dGVkIHRvIG1hdGNoIHByb2plY3RcbiAqIGNvZGluZyBzdHlsZXMuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG4vLyBOYW1lZCBFQyBjdXJ2ZXNcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKFwiLi4vLi4vZGVwcy9mb3JnZVwiKS5qc2JuLkJpZ0ludGVnZXIsXG4gICAgZWMgPSByZXF1aXJlKFwiLi9tYXRoLmpzXCIpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBYOUVDUGFyYW1ldGVyc1xuXG4vLyBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gWDlFQ1BhcmFtZXRlcnMoY3VydmUsIGcsIG4sIGgpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLmcgPSBnO1xuICB0aGlzLm4gPSBuO1xuICB0aGlzLmggPSBoO1xufVxuXG5mdW5jdGlvbiB4OWdldEN1cnZlKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZTtcbn1cblxuZnVuY3Rpb24geDlnZXRHKCkge1xuICByZXR1cm4gdGhpcy5nO1xufVxuXG5mdW5jdGlvbiB4OWdldE4oKSB7XG4gIHJldHVybiB0aGlzLm47XG59XG5cbmZ1bmN0aW9uIHg5Z2V0SCgpIHtcbiAgcmV0dXJuIHRoaXMuaDtcbn1cblxuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEN1cnZlID0geDlnZXRDdXJ2ZTtcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRHID0geDlnZXRHO1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldE4gPSB4OWdldE47XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0SCA9IHg5Z2V0SDtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gU0VDTmFtZWRDdXJ2ZXNcblxuZnVuY3Rpb24gZnJvbUhleChzKSB7IHJldHVybiBuZXcgQmlnSW50ZWdlcihzLCAxNik7IH1cblxuZnVuY3Rpb24gc2VjcDI1NnIxKCkge1xuICAvLyBwID0gMl4yMjQgKDJeMzIgLSAxKSArIDJeMTkyICsgMl45NiAtIDFcbiAgdmFyIHAgPSBmcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgdmFyIGEgPSBmcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQ1wiKTtcbiAgdmFyIGIgPSBmcm9tSGV4KFwiNUFDNjM1RDhBQTNBOTNFN0IzRUJCRDU1NzY5ODg2QkM2NTFEMDZCMENDNTNCMEY2M0JDRTNDM0UyN0QyNjA0QlwiKTtcbiAgdmFyIG4gPSBmcm9tSGV4KFwiRkZGRkZGRkYwMDAwMDAwMEZGRkZGRkZGRkZGRkZGRkZCQ0U2RkFBREE3MTc5RTg0RjNCOUNBQzJGQzYzMjU1MVwiKTtcbiAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgdmFyIGN1cnZlID0gbmV3IGVjLkVDQ3VydmVGcChwLCBhLCBiKTtcbiAgdmFyIEcgPSBjdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCJcbiAgICAgICAgICAgICAgKyBcIjZCMTdEMUYyRTEyQzQyNDdGOEJDRTZFNTYzQTQ0MEYyNzcwMzdEODEyREVCMzNBMEY0QTEzOTQ1RDg5OEMyOTZcIlxuICAgICAgICAgICAgICArIFwiNEZFMzQyRTJGRTFBN0Y5QjhFRTdFQjRBN0MwRjlFMTYyQkNFMzM1NzZCMzE1RUNFQ0JCNjQwNjgzN0JGNTFGNVwiKTtcbiAgcmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgRywgbiwgaCk7XG59XG5cbmZ1bmN0aW9uIHNlY3AzODRyMSgpIHtcbiAgLy8gcCA9IDJeMzg0IC0gMl4xMjggLSAyXjk2ICsgMl4zMiAtIDFcbiAgdmFyIHAgPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRUZGRkZGRkZGMDAwMDAwMDAwMDAwMDAwMEZGRkZGRkZGXCIpO1xuICB2YXIgYSA9IGZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZGRkYwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkNcIik7XG4gIHZhciBiID0gZnJvbUhleChcIkIzMzEyRkE3RTIzRUU3RTQ5ODhFMDU2QkUzRjgyRDE5MTgxRDlDNkVGRTgxNDExMjAzMTQwODhGNTAxMzg3NUFDNjU2Mzk4RDhBMkVEMTlEMkE4NUM4RUREM0VDMkFFRlwiKTtcbiAgdmFyIG4gPSBmcm9tSGV4KFwiRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQzc2MzREODFGNDM3MkRERjU4MUEwREIyNDhCMEE3N0FFQ0VDMTk2QUNDQzUyOTczXCIpO1xuICB2YXIgaCA9IEJpZ0ludGVnZXIuT05FO1xuICB2YXIgY3VydmUgPSBuZXcgZWMuRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICB2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIlxuICAgICAgICAgICAgICArIFwiQUE4N0NBMjJCRThCMDUzNzhFQjFDNzFFRjMyMEFENzQ2RTFEM0I2MjhCQTc5Qjk4NTlGNzQxRTA4MjU0MkEzODU1MDJGMjVEQkY1NTI5NkMzQTU0NUUzODcyNzYwQUI3XCJcbiAgICAgICAgICAgICAgKyBcIjM2MTdERTRBOTYyNjJDNkY1RDlFOThCRjkyOTJEQzI5RjhGNDFEQkQyODlBMTQ3Q0U5REEzMTEzQjVGMEI4QzAwQTYwQjFDRTFEN0U4MTlEN0E0MzFEN0M5MEVBMEU1RlwiKTtcbiAgcmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgRywgbiwgaCk7XG59XG5cbmZ1bmN0aW9uIHNlY3A1MjFyMSgpIHtcbiAgLy8gcCA9IDJeNTIxIC0gMVxuICB2YXIgcCA9IGZyb21IZXgoXCIwMUZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZcIik7XG4gIHZhciBhID0gZnJvbUhleChcIjAxRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQ1wiKTtcbiAgdmFyIGIgPSBmcm9tSGV4KFwiMDA1MTk1M0VCOTYxOEUxQzlBMUY5MjlBMjFBMEI2ODU0MEVFQTJEQTcyNUI5OUIzMTVGM0I4QjQ4OTkxOEVGMTA5RTE1NjE5Mzk1MUVDN0U5MzdCMTY1MkMwQkQzQkIxQkYwNzM1NzNERjg4M0QyQzM0RjFFRjQ1MUZENDZCNTAzRjAwXCIpO1xuICB2YXIgbiA9IGZyb21IZXgoXCIwMUZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGQTUxODY4NzgzQkYyRjk2NkI3RkNDMDE0OEY3MDlBNUQwM0JCNUM5Qjg4OTlDNDdBRUJCNkZCNzFFOTEzODY0MDlcIik7XG4gIHZhciBoID0gQmlnSW50ZWdlci5PTkU7XG4gIHZhciBjdXJ2ZSA9IG5ldyBlYy5FQ0N1cnZlRnAocCwgYSwgYik7XG4gIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG4gICAgICAgICAgICAgICAgKyBcIjAwQzY4NThFMDZCNzA0MDRFOUNEOUUzRUNCNjYyMzk1QjQ0MjlDNjQ4MTM5MDUzRkI1MjFGODI4QUY2MDZCNEQzREJBQTE0QjVFNzdFRkU3NTkyOEZFMURDMTI3QTJGRkE4REUzMzQ4QjNDMTg1NkE0MjlCRjk3RTdFMzFDMkU1QkQ2NlwiXG4gICAgICAgICAgICAgICAgKyBcIjAxMTgzOTI5NkE3ODlBM0JDMDA0NUM4QTVGQjQyQzdEMUJEOTk4RjU0NDQ5NTc5QjQ0NjgxN0FGQkQxNzI3M0U2NjJDOTdFRTcyOTk1RUY0MjY0MEM1NTBCOTAxM0ZBRDA3NjEzNTNDNzA4NkEyNzJDMjQwODhCRTk0NzY5RkQxNjY1MFwiKTtcbiAgcmV0dXJuIG5ldyBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgRywgbiwgaCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpYyBBUElcblxudmFyIENVUlZFUyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBcInNlY3AyNTZyMVwiOiBzZWNwMjU2cjEoKSxcbiAgXCJzZWNwMzg0cjFcIjogc2VjcDM4NHIxKCksXG4gIFwic2VjcDUyMXIxXCI6IHNlY3A1MjFyMSgpXG59O1xuXG4vLyBhbHNvIGV4cG9ydCBOSVNUIG5hbWVzXG5DVVJWRVNbXCJQLTI1NlwiXSA9IENVUlZFUy5zZWNwMjU2cjE7XG5DVVJWRVNbXCJQLTM4NFwiXSA9IENVUlZFUy5zZWNwMzg0cjE7XG5DVVJWRVNbXCJQLTUyMVwiXSA9IENVUlZFUy5zZWNwNTIxcjE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * deps/ecc/index.js - Elliptic Curve Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    BigInteger = forge.jsbn.BigInteger,\n    ec = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\"),\n    CURVES = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js\");\n\n// ### Helpers\nfunction hex2bn(s) {\n  return new BigInteger(s, 16);\n}\n\nfunction bn2bin(bn, len) {\n  if (!len) {\n    len = Math.ceil(bn.bitLength() / 8);\n  }\n  len = len * 2;\n\n  var hex = bn.toString(16);\n  // truncate-left if too large\n  hex = hex.substring(Math.max(hex.length - len, 0));\n  // pad-left if too small\n  while (len > hex.length) {\n    hex = \"0\" + hex;\n  }\n\n  return Buffer.from(hex, \"hex\");\n}\nfunction bin2bn(s) {\n  if (\"string\" === typeof s) {\n    s = Buffer.from(s, \"binary\");\n  }\n  return hex2bn(s.toString(\"hex\"));\n}\n\nfunction keySizeBytes(params) {\n  return Math.ceil(params.getN().bitLength() / 8);\n}\n\nfunction namedCurve(curve) {\n  var params = CURVES[curve];\n  if (!params) {\n    throw new TypeError(\"unsupported named curve: \" + curve);\n  }\n\n  return params;\n}\n\nfunction normalizeEcdsa(params, md) {\n  var log2n = params.getN().bitLength(),\n      mdLen = md.length * 8;\n\n  var e = bin2bn(md);\n  if (log2n < mdLen) {\n    e = e.shiftRight(mdLen - log2n);\n  }\n\n  return e;\n}\n\n// ### EC Public Key\n\n/**\n *\n * @param {String} curve The named curve\n * @param {BigInteger} x The X coordinate\n * @param {BigInteger} y The Y coordinate\n */\nfunction ECPublicKey(curve, x, y) {\n  var params = namedCurve(curve),\n      c = params.getCurve();\n  var key = new ec.ECPointFp(c,\n                             c.fromBigInteger(x),\n                             c.fromBigInteger(y));\n\n  this.curve = curve;\n  this.params = params;\n  this.point = key;\n\n  var size = keySizeBytes(params);\n  this.x = bn2bin(x, size);\n  this.y = bn2bin(y, size);\n}\n\n// basics\nECPublicKey.prototype.isValid = function() {\n  return this.params.curve.contains(this.point);\n}\n\n// ECDSA\nECPublicKey.prototype.verify = function(md, sig) {\n  var N = this.params.getN(),\n      G = this.params.getG();\n\n  // prepare and validate (r, s)\n  var r = bin2bn(sig.r),\n      s = bin2bn(sig.s);\n  if (r.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n  if (s.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n\n  // normalize input\n  var e = normalizeEcdsa(this.params, md);\n  // verify (r, s)\n  var w = s.modInverse(N),\n      u1 = e.multiply(w).mod(N),\n      u2 = r.multiply(w).mod(N);\n\n  var v = G.multiplyTwo(u1, this.point, u2).getX().toBigInteger();\n  v = v.mod(N);\n\n  return v.equals(r);\n};\n\n// ### EC Private Key\n\n/**\n * @param {String} curve The named curve\n * @param {Buffer} key The private key value\n */\nfunction ECPrivateKey(curve, key) {\n  var params = namedCurve(curve);\n  this.curve = curve;\n  this.params = params;\n\n  var size = keySizeBytes(params);\n  this.d = bn2bin(key, size);\n}\n\nECPrivateKey.prototype.toPublicKey = function() {\n  var d = bin2bn(this.d);\n  var P = this.params.getG().multiply(d);\n  return new ECPublicKey(this.curve,\n                         P.getX().toBigInteger(),\n                         P.getY().toBigInteger());\n};\n\n// ECDSA\nECPrivateKey.prototype.sign = function(md) {\n  var keysize = keySizeBytes(this.params),\n      N = this.params.getN(),\n      G = this.params.getG(),\n      e = normalizeEcdsa(this.params, md),\n      d = bin2bn(this.d);\n\n  var r, s;\n  var k, x1, z;\n  do {\n    do {\n      // determine random nonce\n      do {\n        k = bin2bn(forge.random.getBytes(keysize));\n      } while (k.equals(BigInteger.ZERO) || k.compareTo(N) >= 0);\n      // (x1, y1) = k * G\n      x1 = G.multiply(k).getX().toBigInteger();\n      // r = x1 mod N\n      r = x1.mod(N);\n    } while (r.equals(BigInteger.ZERO));\n    // s = (k^-1 * (e + r * d)) mod N\n    z = d.multiply(r);\n    z = e.add(z);\n    s = k.modInverse(N).multiply(z).mod(N);\n  } while (s.equals(BigInteger.ONE));\n\n  // convert (r, s) to bytes\n  var len = keySizeBytes(this.params);\n  r = bn2bin(r, len);\n  s = bn2bin(s, len);\n\n  return {\n    r: r,\n    s: s\n  };\n};\n\n// basics\nECPrivateKey.prototype.isValid = function() {\n  var d = bin2bn(this.d),\n      n1 = this.params.getN().subtract(BigInteger.ONE);\n\n  return (d.compareTo(BigInteger.ONE) >= 0) &&\n         (d.compareTo(n1) < 0);\n}\n\n// ECDH\nECPrivateKey.prototype.computeSecret = function(pubkey) {\n  var d = bin2bn(this.d);\n  var S = pubkey.point.multiply(d).getX().toBigInteger();\n  S = bn2bin(S, keySizeBytes(this.params));\n  return S;\n};\n\n// ### Public API\nexports.generateKeyPair = function(curve) {\n  var params = namedCurve(curve),\n      n = params.getN();\n\n  // generate random within range [1, N-1)\n  var r = forge.random.getBytes(keySizeBytes(params));\n  r = bin2bn(r);\n\n  var n1 = n.subtract(BigInteger.ONE);\n  var d = r.mod(n1).add(BigInteger.ONE);\n\n  var privkey = new ECPrivateKey(curve, d),\n      pubkey = privkey.toPublicKey();\n\n  return {\n    \"private\": privkey,\n    \"public\": pubkey\n  };\n};\n\nexports.asPublicKey = function(curve, x, y) {\n  if (\"string\" === typeof x) {\n    x = hex2bn(x);\n  } else if (Buffer.isBuffer(x)) {\n    x = bin2bn(x);\n  }\n\n  if (\"string\" === typeof y) {\n    y = hex2bn(y);\n  } else if (Buffer.isBuffer(y)) {\n    y = bin2bn(y);\n  }\n\n  var pubkey = new ECPublicKey(curve, x, y);\n  return pubkey;\n};\nexports.asPrivateKey = function(curve, d) {\n  // Elaborate way to get to a Buffer from a (String|Buffer|BigInteger)\n  if (\"string\" === typeof d) {\n    d = hex2bn(d);\n  } else if (Buffer.isBuffer(d)) {\n    d = bin2bn(d);\n  }\n\n  var privkey = new ECPrivateKey(curve, d);\n  return privkey;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QztBQUNBLFNBQVMsbUJBQU8sQ0FBQyxzRUFBVztBQUM1QixhQUFhLG1CQUFPLENBQUMsMEVBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvZWNjL2luZGV4LmpzPzg5ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZXBzL2VjYy9pbmRleC5qcyAtIEVsbGlwdGljIEN1cnZlIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vLi4vZGVwcy9mb3JnZVwiKSxcbiAgICBCaWdJbnRlZ2VyID0gZm9yZ2UuanNibi5CaWdJbnRlZ2VyLFxuICAgIGVjID0gcmVxdWlyZShcIi4vbWF0aC5qc1wiKSxcbiAgICBDVVJWRVMgPSByZXF1aXJlKFwiLi9jdXJ2ZXMuanNcIik7XG5cbi8vICMjIyBIZWxwZXJzXG5mdW5jdGlvbiBoZXgyYm4ocykge1xuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIocywgMTYpO1xufVxuXG5mdW5jdGlvbiBibjJiaW4oYm4sIGxlbikge1xuICBpZiAoIWxlbikge1xuICAgIGxlbiA9IE1hdGguY2VpbChibi5iaXRMZW5ndGgoKSAvIDgpO1xuICB9XG4gIGxlbiA9IGxlbiAqIDI7XG5cbiAgdmFyIGhleCA9IGJuLnRvU3RyaW5nKDE2KTtcbiAgLy8gdHJ1bmNhdGUtbGVmdCBpZiB0b28gbGFyZ2VcbiAgaGV4ID0gaGV4LnN1YnN0cmluZyhNYXRoLm1heChoZXgubGVuZ3RoIC0gbGVuLCAwKSk7XG4gIC8vIHBhZC1sZWZ0IGlmIHRvbyBzbWFsbFxuICB3aGlsZSAobGVuID4gaGV4Lmxlbmd0aCkge1xuICAgIGhleCA9IFwiMFwiICsgaGV4O1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCwgXCJoZXhcIik7XG59XG5mdW5jdGlvbiBiaW4yYm4ocykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHMpIHtcbiAgICBzID0gQnVmZmVyLmZyb20ocywgXCJiaW5hcnlcIik7XG4gIH1cbiAgcmV0dXJuIGhleDJibihzLnRvU3RyaW5nKFwiaGV4XCIpKTtcbn1cblxuZnVuY3Rpb24ga2V5U2l6ZUJ5dGVzKHBhcmFtcykge1xuICByZXR1cm4gTWF0aC5jZWlsKHBhcmFtcy5nZXROKCkuYml0TGVuZ3RoKCkgLyA4KTtcbn1cblxuZnVuY3Rpb24gbmFtZWRDdXJ2ZShjdXJ2ZSkge1xuICB2YXIgcGFyYW1zID0gQ1VSVkVTW2N1cnZlXTtcbiAgaWYgKCFwYXJhbXMpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidW5zdXBwb3J0ZWQgbmFtZWQgY3VydmU6IFwiICsgY3VydmUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRWNkc2EocGFyYW1zLCBtZCkge1xuICB2YXIgbG9nMm4gPSBwYXJhbXMuZ2V0TigpLmJpdExlbmd0aCgpLFxuICAgICAgbWRMZW4gPSBtZC5sZW5ndGggKiA4O1xuXG4gIHZhciBlID0gYmluMmJuKG1kKTtcbiAgaWYgKGxvZzJuIDwgbWRMZW4pIHtcbiAgICBlID0gZS5zaGlmdFJpZ2h0KG1kTGVuIC0gbG9nMm4pO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbi8vICMjIyBFQyBQdWJsaWMgS2V5XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjdXJ2ZSBUaGUgbmFtZWQgY3VydmVcbiAqIEBwYXJhbSB7QmlnSW50ZWdlcn0geCBUaGUgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge0JpZ0ludGVnZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZVxuICovXG5mdW5jdGlvbiBFQ1B1YmxpY0tleShjdXJ2ZSwgeCwgeSkge1xuICB2YXIgcGFyYW1zID0gbmFtZWRDdXJ2ZShjdXJ2ZSksXG4gICAgICBjID0gcGFyYW1zLmdldEN1cnZlKCk7XG4gIHZhciBrZXkgPSBuZXcgZWMuRUNQb2ludEZwKGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZnJvbUJpZ0ludGVnZXIoeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuZnJvbUJpZ0ludGVnZXIoeSkpO1xuXG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIHRoaXMucG9pbnQgPSBrZXk7XG5cbiAgdmFyIHNpemUgPSBrZXlTaXplQnl0ZXMocGFyYW1zKTtcbiAgdGhpcy54ID0gYm4yYmluKHgsIHNpemUpO1xuICB0aGlzLnkgPSBibjJiaW4oeSwgc2l6ZSk7XG59XG5cbi8vIGJhc2ljc1xuRUNQdWJsaWNLZXkucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucGFyYW1zLmN1cnZlLmNvbnRhaW5zKHRoaXMucG9pbnQpO1xufVxuXG4vLyBFQ0RTQVxuRUNQdWJsaWNLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uKG1kLCBzaWcpIHtcbiAgdmFyIE4gPSB0aGlzLnBhcmFtcy5nZXROKCksXG4gICAgICBHID0gdGhpcy5wYXJhbXMuZ2V0RygpO1xuXG4gIC8vIHByZXBhcmUgYW5kIHZhbGlkYXRlIChyLCBzKVxuICB2YXIgciA9IGJpbjJibihzaWcuciksXG4gICAgICBzID0gYmluMmJuKHNpZy5zKTtcbiAgaWYgKHIuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA8IDAgfHwgci5jb21wYXJlVG8oTikgPj0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocy5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpIDwgMCB8fCByLmNvbXBhcmVUbyhOKSA+PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGlucHV0XG4gIHZhciBlID0gbm9ybWFsaXplRWNkc2EodGhpcy5wYXJhbXMsIG1kKTtcbiAgLy8gdmVyaWZ5IChyLCBzKVxuICB2YXIgdyA9IHMubW9kSW52ZXJzZShOKSxcbiAgICAgIHUxID0gZS5tdWx0aXBseSh3KS5tb2QoTiksXG4gICAgICB1MiA9IHIubXVsdGlwbHkodykubW9kKE4pO1xuXG4gIHZhciB2ID0gRy5tdWx0aXBseVR3byh1MSwgdGhpcy5wb2ludCwgdTIpLmdldFgoKS50b0JpZ0ludGVnZXIoKTtcbiAgdiA9IHYubW9kKE4pO1xuXG4gIHJldHVybiB2LmVxdWFscyhyKTtcbn07XG5cbi8vICMjIyBFQyBQcml2YXRlIEtleVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBjdXJ2ZSBUaGUgbmFtZWQgY3VydmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBrZXkgVGhlIHByaXZhdGUga2V5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIEVDUHJpdmF0ZUtleShjdXJ2ZSwga2V5KSB7XG4gIHZhciBwYXJhbXMgPSBuYW1lZEN1cnZlKGN1cnZlKTtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcblxuICB2YXIgc2l6ZSA9IGtleVNpemVCeXRlcyhwYXJhbXMpO1xuICB0aGlzLmQgPSBibjJiaW4oa2V5LCBzaXplKTtcbn1cblxuRUNQcml2YXRlS2V5LnByb3RvdHlwZS50b1B1YmxpY0tleSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZCA9IGJpbjJibih0aGlzLmQpO1xuICB2YXIgUCA9IHRoaXMucGFyYW1zLmdldEcoKS5tdWx0aXBseShkKTtcbiAgcmV0dXJuIG5ldyBFQ1B1YmxpY0tleSh0aGlzLmN1cnZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFAuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFAuZ2V0WSgpLnRvQmlnSW50ZWdlcigpKTtcbn07XG5cbi8vIEVDRFNBXG5FQ1ByaXZhdGVLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbihtZCkge1xuICB2YXIga2V5c2l6ZSA9IGtleVNpemVCeXRlcyh0aGlzLnBhcmFtcyksXG4gICAgICBOID0gdGhpcy5wYXJhbXMuZ2V0TigpLFxuICAgICAgRyA9IHRoaXMucGFyYW1zLmdldEcoKSxcbiAgICAgIGUgPSBub3JtYWxpemVFY2RzYSh0aGlzLnBhcmFtcywgbWQpLFxuICAgICAgZCA9IGJpbjJibih0aGlzLmQpO1xuXG4gIHZhciByLCBzO1xuICB2YXIgaywgeDEsIHo7XG4gIGRvIHtcbiAgICBkbyB7XG4gICAgICAvLyBkZXRlcm1pbmUgcmFuZG9tIG5vbmNlXG4gICAgICBkbyB7XG4gICAgICAgIGsgPSBiaW4yYm4oZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGtleXNpemUpKTtcbiAgICAgIH0gd2hpbGUgKGsuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykgfHwgay5jb21wYXJlVG8oTikgPj0gMCk7XG4gICAgICAvLyAoeDEsIHkxKSA9IGsgKiBHXG4gICAgICB4MSA9IEcubXVsdGlwbHkoaykuZ2V0WCgpLnRvQmlnSW50ZWdlcigpO1xuICAgICAgLy8gciA9IHgxIG1vZCBOXG4gICAgICByID0geDEubW9kKE4pO1xuICAgIH0gd2hpbGUgKHIuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykpO1xuICAgIC8vIHMgPSAoa14tMSAqIChlICsgciAqIGQpKSBtb2QgTlxuICAgIHogPSBkLm11bHRpcGx5KHIpO1xuICAgIHogPSBlLmFkZCh6KTtcbiAgICBzID0gay5tb2RJbnZlcnNlKE4pLm11bHRpcGx5KHopLm1vZChOKTtcbiAgfSB3aGlsZSAocy5lcXVhbHMoQmlnSW50ZWdlci5PTkUpKTtcblxuICAvLyBjb252ZXJ0IChyLCBzKSB0byBieXRlc1xuICB2YXIgbGVuID0ga2V5U2l6ZUJ5dGVzKHRoaXMucGFyYW1zKTtcbiAgciA9IGJuMmJpbihyLCBsZW4pO1xuICBzID0gYm4yYmluKHMsIGxlbik7XG5cbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIHM6IHNcbiAgfTtcbn07XG5cbi8vIGJhc2ljc1xuRUNQcml2YXRlS2V5LnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gYmluMmJuKHRoaXMuZCksXG4gICAgICBuMSA9IHRoaXMucGFyYW1zLmdldE4oKS5zdWJ0cmFjdChCaWdJbnRlZ2VyLk9ORSk7XG5cbiAgcmV0dXJuIChkLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPj0gMCkgJiZcbiAgICAgICAgIChkLmNvbXBhcmVUbyhuMSkgPCAwKTtcbn1cblxuLy8gRUNESFxuRUNQcml2YXRlS2V5LnByb3RvdHlwZS5jb21wdXRlU2VjcmV0ID0gZnVuY3Rpb24ocHVia2V5KSB7XG4gIHZhciBkID0gYmluMmJuKHRoaXMuZCk7XG4gIHZhciBTID0gcHVia2V5LnBvaW50Lm11bHRpcGx5KGQpLmdldFgoKS50b0JpZ0ludGVnZXIoKTtcbiAgUyA9IGJuMmJpbihTLCBrZXlTaXplQnl0ZXModGhpcy5wYXJhbXMpKTtcbiAgcmV0dXJuIFM7XG59O1xuXG4vLyAjIyMgUHVibGljIEFQSVxuZXhwb3J0cy5nZW5lcmF0ZUtleVBhaXIgPSBmdW5jdGlvbihjdXJ2ZSkge1xuICB2YXIgcGFyYW1zID0gbmFtZWRDdXJ2ZShjdXJ2ZSksXG4gICAgICBuID0gcGFyYW1zLmdldE4oKTtcblxuICAvLyBnZW5lcmF0ZSByYW5kb20gd2l0aGluIHJhbmdlIFsxLCBOLTEpXG4gIHZhciByID0gZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGtleVNpemVCeXRlcyhwYXJhbXMpKTtcbiAgciA9IGJpbjJibihyKTtcblxuICB2YXIgbjEgPSBuLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcbiAgdmFyIGQgPSByLm1vZChuMSkuYWRkKEJpZ0ludGVnZXIuT05FKTtcblxuICB2YXIgcHJpdmtleSA9IG5ldyBFQ1ByaXZhdGVLZXkoY3VydmUsIGQpLFxuICAgICAgcHVia2V5ID0gcHJpdmtleS50b1B1YmxpY0tleSgpO1xuXG4gIHJldHVybiB7XG4gICAgXCJwcml2YXRlXCI6IHByaXZrZXksXG4gICAgXCJwdWJsaWNcIjogcHVia2V5XG4gIH07XG59O1xuXG5leHBvcnRzLmFzUHVibGljS2V5ID0gZnVuY3Rpb24oY3VydmUsIHgsIHkpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB4KSB7XG4gICAgeCA9IGhleDJibih4KTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoeCkpIHtcbiAgICB4ID0gYmluMmJuKHgpO1xuICB9XG5cbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB5KSB7XG4gICAgeSA9IGhleDJibih5KTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoeSkpIHtcbiAgICB5ID0gYmluMmJuKHkpO1xuICB9XG5cbiAgdmFyIHB1YmtleSA9IG5ldyBFQ1B1YmxpY0tleShjdXJ2ZSwgeCwgeSk7XG4gIHJldHVybiBwdWJrZXk7XG59O1xuZXhwb3J0cy5hc1ByaXZhdGVLZXkgPSBmdW5jdGlvbihjdXJ2ZSwgZCkge1xuICAvLyBFbGFib3JhdGUgd2F5IHRvIGdldCB0byBhIEJ1ZmZlciBmcm9tIGEgKFN0cmluZ3xCdWZmZXJ8QmlnSW50ZWdlcilcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkKSB7XG4gICAgZCA9IGhleDJibihkKTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoZCkpIHtcbiAgICBkID0gYmluMmJuKGQpO1xuICB9XG5cbiAgdmFyIHByaXZrZXkgPSBuZXcgRUNQcml2YXRlS2V5KGN1cnZlLCBkKTtcbiAgcmV0dXJuIHByaXZrZXk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/math.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * deps/ecc/math.js - Elliptic Curve Math\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\n\n// Basic Javascript Elliptic Curve implementation\n// Ported loosely from BouncyCastle's Java EC code\n// Only Fp curves implemented for now\n\nvar BigInteger = (__webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\").jsbn).BigInteger;\n\n// ----------------\n// Helpers\n\nfunction nbi() {\n  return new BigInteger(null);\n}\n\n// ----------------\n// Barrett modular reduction\n\n// constructor\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  if (x.s < 0) { throw Error(\"Barrett reduction on negative input\"); }\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// ----------------\n// ECFieldElementFp\n\n// constructor\nfunction ECFieldElementFp(q, x) {\n  this.x = x;\n  // TODO if(x.compareTo(q) >= 0) error\n  this.p = q;\n}\n\nfunction feFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.x.equals(other.x));\n}\n\nfunction feFpToBigInteger() {\n  return this.x;\n}\n\nfunction feFpNegate() {\n  return new ECFieldElementFp(this.p, this.x.negate().mod(this.p));\n}\n\nfunction feFpAdd(b) {\n  return new ECFieldElementFp(this.p, this.x.add(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSubtract(b) {\n  return new ECFieldElementFp(this.p, this.x.subtract(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpMultiply(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSquare() {\n  return new ECFieldElementFp(this.p, this.x.pow(2).mod(this.p));\n}\n\nfunction feFpDivide(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger().modInverse(this.p)).mod(this.p));\n}\n\nECFieldElementFp.prototype.equals = feFpEquals;\nECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;\nECFieldElementFp.prototype.negate = feFpNegate;\nECFieldElementFp.prototype.add = feFpAdd;\nECFieldElementFp.prototype.subtract = feFpSubtract;\nECFieldElementFp.prototype.multiply = feFpMultiply;\nECFieldElementFp.prototype.square = feFpSquare;\nECFieldElementFp.prototype.divide = feFpDivide;\n\n// ----------------\n// ECPointFp\n\n// constructor\nfunction ECPointFp(curve, x, y, z) {\n  this.curve = curve;\n  this.x = x;\n  this.y = y;\n  // Projective coordinates: either zinv == null or z * zinv == 1\n  // z and zinv are just BigIntegers, not fieldElements\n  if (!z) {\n    this.z = BigInteger.ONE;\n  } else {\n    this.z = z;\n  }\n  this.zinv = null;\n  //TODO: compression flag\n}\n\nfunction pointFpGetX() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.x.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpGetY() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.y.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  if (this.isInfinity()) {\n    return other.isInfinity();\n  }\n  if (other.isInfinity()) {\n    return this.isInfinity();\n  }\n  var u, v;\n  // u = Y2 * Z1 - Y1 * Z2\n  u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  if (!u.equals(BigInteger.ZERO)) {\n    return false;\n  }\n  // v = X2 * Z1 - X1 * Z2\n  v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  return v.equals(BigInteger.ZERO);\n}\n\nfunction pointFpIsInfinity() {\n  if ((this.x == null) && (this.y == null)) {\n    return true;\n  }\n  return (this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO));\n}\n\nfunction pointFpNegate() {\n    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);\n}\n\nfunction pointFpAdd(b) {\n  if (this.isInfinity()) {\n    return b;\n  }\n  if (b.isInfinity()) {\n    return this;\n  }\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.p);\n  // v = X2 * Z1 - X1 * Z2\n  var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.p);\n\n  if (BigInteger.ZERO.equals(v)) {\n    if (BigInteger.ZERO.equals(u)) {\n      return this.twice(); // this == b, so double\n    }\n    return this.curve.getInfinity(); // this = -b, so infinity\n  }\n\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var v2 = v.pow(2);\n  var v3 = v2.multiply(v);\n  var x1v2 = x1.multiply(v2);\n  var zu2 = u.pow(2).multiply(this.z);\n\n  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p);\n  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p);\n  // z3 = v^3 * z1 * z2\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\nfunction pointFpTwice() {\n  if(this.isInfinity()) {\n    return this;\n  }\n  if (this.y.toBigInteger().signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  // TODO: optimized handling of constants\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var y1z1 = y1.multiply(this.z);\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);\n  var a = this.curve.a.toBigInteger();\n\n  // w = 3 * x1^2 + a * z1^2\n  var w = x1.pow(2).multiply(THREE);\n  if (!BigInteger.ZERO.equals(a)) {\n    w = w.add(this.z.pow(2).multiply(a));\n  }\n  w = w.mod(this.curve.p);\n  //this.curve.reduce(w);\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n  var x3 = w.pow(2).subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p);\n  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(2).multiply(w)).mod(this.curve.p);\n  // z3 = 8 * (y1 * z1)^3\n  var z3 = y1z1.pow(2).multiply(y1z1).shiftLeft(3).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\n// Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\nfunction pointFpMultiply(k) {\n  if (this.isInfinity()) {\n    return this;\n  }\n  if (k.signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  var e = k;\n  var h = e.multiply(new BigInteger(\"3\"));\n\n  var neg = this.negate();\n  var R = this;\n\n  var i;\n  for(i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice();\n\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg);\n    }\n  }\n\n  return R;\n}\n\n// Compute this*j + x*k (simultaneous multiplication)\nfunction pointFpMultiplyTwo(j, x, k) {\n  var i;\n  if (j.bitLength() > k.bitLength()) {\n    i = j.bitLength() - 1;\n  } else {\n    i = k.bitLength() - 1;\n  }\n\n  var R = this.curve.getInfinity();\n  var both = this.add(x);\n  while (i >= 0) {\n    R = R.twice();\n    if (j.testBit(i)) {\n      if (k.testBit(i)) {\n        R = R.add(both);\n      }\n      else {\n        R = R.add(this);\n      }\n    }\n    else {\n      if (k.testBit(i)) {\n        R = R.add(x);\n      }\n    }\n    --i;\n  }\n\n  return R;\n}\n\nECPointFp.prototype.getX = pointFpGetX;\nECPointFp.prototype.getY = pointFpGetY;\nECPointFp.prototype.equals = pointFpEquals;\nECPointFp.prototype.isInfinity = pointFpIsInfinity;\nECPointFp.prototype.negate = pointFpNegate;\nECPointFp.prototype.add = pointFpAdd;\nECPointFp.prototype.twice = pointFpTwice;\nECPointFp.prototype.multiply = pointFpMultiply;\nECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;\n\n// ----------------\n// ECCurveFp\n\n// constructor\nfunction ECCurveFp(p, a, b) {\n  this.p = p;\n  this.a = this.fromBigInteger(a);\n  this.b = this.fromBigInteger(b);\n  this.infinity = new ECPointFp(this, null, null);\n  this.reducer = new Barrett(this.p);\n}\n\nfunction curveFpgetP() {\n  return this.p;\n}\n\nfunction curveFpGetA() {\n  return this.a;\n}\n\nfunction curveFpGetB() {\n  return this.b;\n}\n\nfunction curveFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.a.equals(other.a) && this.b.equals(other.b));\n}\n\nfunction curveFpContains(pt) {\n  // y^2 = x^3 + a*x + b mod p\n  var x = pt.getX().toBigInteger(),\n      y = pt.getY().toBigInteger(),\n      a = this.a.toBigInteger(),\n      b = this.b.toBigInteger(),\n      p = this.p;\n\n  var left = y.pow(2).mod(p),\n      right = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n\n  return left.equals(right);\n}\n\nfunction curveFpGetInfinity() {\n  return this.infinity;\n}\n\nfunction curveFpFromBigInteger(x) {\n  return new ECFieldElementFp(this.p, x);\n}\n\nfunction curveReduce(x) {\n  this.reducer.reduce(x);\n}\n\n// for now, work with hex strings because they're easier in JS\nfunction curveFpDecodePointHex(s) {\n  switch (parseInt(s.substring(0, 2), 16)) {\n    // first byte\n    case 0:\n      return this.infinity;\n    case 2:\n    case 3:\n      // point compression not supported yet\n      return null;\n    case 4:\n    case 6:\n    case 7:\n      var len = (s.length - 2) / 2;\n      var xHex = s.substr(2, len);\n      var yHex = s.substr(len + 2, len);\n\n      return new ECPointFp(this,\n                           this.fromBigInteger(new BigInteger(xHex, 16)),\n                           this.fromBigInteger(new BigInteger(yHex, 16)));\n\n    default: // unsupported\n      return null;\n    }\n}\n\nfunction curveFpEncodePointHex(p) {\n  if (p.isInfinity()) {\n    return \"00\";\n  }\n  var xHex = p.getX().toBigInteger().toString(16);\n  var yHex = p.getY().toBigInteger().toString(16);\n  var oLen = this.getP().toString(16).length;\n  if ((oLen % 2) !== 0) {\n    oLen++;\n  }\n  while (xHex.length < oLen) {\n    xHex = \"0\" + xHex;\n  }\n  while (yHex.length < oLen) {\n    yHex = \"0\" + yHex;\n  }\n  return \"04\" + xHex + yHex;\n}\n\nECCurveFp.prototype.getP = curveFpgetP;\nECCurveFp.prototype.getA = curveFpGetA;\nECCurveFp.prototype.getB = curveFpGetB;\nECCurveFp.prototype.equals = curveFpEquals;\nECCurveFp.prototype.contains = curveFpContains;\nECCurveFp.prototype.getInfinity = curveFpGetInfinity;\nECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;\nECCurveFp.prototype.reduce = curveReduce;\nECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;\nECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;\n\n// Exports\nmodule.exports = {\n  ECFieldElementFp: ECFieldElementFp,\n  ECPointFp: ECPointFp,\n  ECCurveFp: ECCurveFp\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9tYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzR0FBZ0M7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZSxhQUFhLGdCQUFnQjtBQUNyRDs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsNkJBQTZCLGVBQWU7O0FBRTVDLGtCQUFrQjtBQUNsQiwrQkFBK0IsbUJBQW1COztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9lY2MvbWF0aC5qcz9hZjVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGVwcy9lY2MvbWF0aC5qcyAtIEVsbGlwdGljIEN1cnZlIE1hdGhcbiAqIE9yaWdpbmFsIENvcHlyaWdodCAoYykgMjAwMy0yMDA1ICBUb20gV3UuXG4gKiBNb2RpZmljYXRpb25zIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICpcbiAqIFBvcnRlZCBmcm9tIFRvbSBXdSwgd2hpY2ggaXMgcG9ydGVkIGZyb20gQm91bmN5Q2FzdGxlXG4gKiBNb2RpZmllZCB0byByZXVzZSBleGlzdGluZyBleHRlcm5hbCBOUE0gbW9kdWxlcywgcmVzdHJpY3RlZCB0byB0aGVcbiAqIE5JU1QvL1NFQ0cvWDkuNjIgcHJpbWUgY3VydmVzIG9ubHksIGFuZCBmb3JtYXR0ZWQgdG8gbWF0Y2ggcHJvamVjdFxuICogY29kaW5nIHN0eWxlcy5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEJhc2ljIEphdmFzY3JpcHQgRWxsaXB0aWMgQ3VydmUgaW1wbGVtZW50YXRpb25cbi8vIFBvcnRlZCBsb29zZWx5IGZyb20gQm91bmN5Q2FzdGxlJ3MgSmF2YSBFQyBjb2RlXG4vLyBPbmx5IEZwIGN1cnZlcyBpbXBsZW1lbnRlZCBmb3Igbm93XG5cbnZhciBCaWdJbnRlZ2VyID0gcmVxdWlyZShcIi4uLy4uL2RlcHMvZm9yZ2VcIikuanNibi5CaWdJbnRlZ2VyO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG5cbmZ1bmN0aW9uIG5iaSgpIHtcbiAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG51bGwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBCYXJyZXR0IG1vZHVsYXIgcmVkdWN0aW9uXG5cbi8vIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBCYXJyZXR0KG0pIHtcbiAgLy8gc2V0dXAgQmFycmV0dFxuICB0aGlzLnIyID0gbmJpKCk7XG4gIHRoaXMucTMgPSBuYmkoKTtcbiAgQmlnSW50ZWdlci5PTkUuZGxTaGlmdFRvKDIqbS50LHRoaXMucjIpO1xuICB0aGlzLm11ID0gdGhpcy5yMi5kaXZpZGUobSk7XG4gIHRoaXMubSA9IG07XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRDb252ZXJ0KHgpIHtcbiAgaWYoeC5zIDwgMCB8fCB4LnQgPiAyKnRoaXMubS50KSByZXR1cm4geC5tb2QodGhpcy5tKTtcbiAgZWxzZSBpZih4LmNvbXBhcmVUbyh0aGlzLm0pIDwgMCkgcmV0dXJuIHg7XG4gIGVsc2UgeyB2YXIgciA9IG5iaSgpOyB4LmNvcHlUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IHJldHVybiByOyB9XG59XG5cbmZ1bmN0aW9uIGJhcnJldHRSZXZlcnQoeCkgeyByZXR1cm4geDsgfVxuXG4vLyB4ID0geCBtb2QgbSAoSEFDIDE0LjQyKVxuZnVuY3Rpb24gYmFycmV0dFJlZHVjZSh4KSB7XG4gIGlmICh4LnMgPCAwKSB7IHRocm93IEVycm9yKFwiQmFycmV0dCByZWR1Y3Rpb24gb24gbmVnYXRpdmUgaW5wdXRcIik7IH1cbiAgeC5kclNoaWZ0VG8odGhpcy5tLnQtMSx0aGlzLnIyKTtcbiAgaWYoeC50ID4gdGhpcy5tLnQrMSkgeyB4LnQgPSB0aGlzLm0udCsxOyB4LmNsYW1wKCk7IH1cbiAgdGhpcy5tdS5tdWx0aXBseVVwcGVyVG8odGhpcy5yMix0aGlzLm0udCsxLHRoaXMucTMpO1xuICB0aGlzLm0ubXVsdGlwbHlMb3dlclRvKHRoaXMucTMsdGhpcy5tLnQrMSx0aGlzLnIyKTtcbiAgd2hpbGUoeC5jb21wYXJlVG8odGhpcy5yMikgPCAwKSB4LmRBZGRPZmZzZXQoMSx0aGlzLm0udCsxKTtcbiAgeC5zdWJUbyh0aGlzLnIyLHgpO1xuICB3aGlsZSh4LmNvbXBhcmVUbyh0aGlzLm0pID49IDApIHguc3ViVG8odGhpcy5tLHgpO1xufVxuXG4vLyByID0geF4yIG1vZCBtOyB4ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRTcXJUbyh4LHIpIHsgeC5zcXVhcmVUbyhyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuLy8gciA9IHgqeSBtb2QgbTsgeCx5ICE9IHJcbmZ1bmN0aW9uIGJhcnJldHRNdWxUbyh4LHkscikgeyB4Lm11bHRpcGx5VG8oeSxyKTsgdGhpcy5yZWR1Y2Uocik7IH1cblxuQmFycmV0dC5wcm90b3R5cGUuY29udmVydCA9IGJhcnJldHRDb252ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmV2ZXJ0ID0gYmFycmV0dFJldmVydDtcbkJhcnJldHQucHJvdG90eXBlLnJlZHVjZSA9IGJhcnJldHRSZWR1Y2U7XG5CYXJyZXR0LnByb3RvdHlwZS5tdWxUbyA9IGJhcnJldHRNdWxUbztcbkJhcnJldHQucHJvdG90eXBlLnNxclRvID0gYmFycmV0dFNxclRvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBFQ0ZpZWxkRWxlbWVudEZwXG5cbi8vIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBFQ0ZpZWxkRWxlbWVudEZwKHEsIHgpIHtcbiAgdGhpcy54ID0geDtcbiAgLy8gVE9ETyBpZih4LmNvbXBhcmVUbyhxKSA+PSAwKSBlcnJvclxuICB0aGlzLnAgPSBxO1xufVxuXG5mdW5jdGlvbiBmZUZwRXF1YWxzKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiAodGhpcy5wLmVxdWFscyhvdGhlci5wKSAmJiB0aGlzLnguZXF1YWxzKG90aGVyLngpKTtcbn1cblxuZnVuY3Rpb24gZmVGcFRvQmlnSW50ZWdlcigpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn1cblxuZnVuY3Rpb24gZmVGcE5lZ2F0ZSgpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgdGhpcy54Lm5lZ2F0ZSgpLm1vZCh0aGlzLnApKTtcbn1cblxuZnVuY3Rpb24gZmVGcEFkZChiKSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHRoaXMueC5hZGQoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwU3VidHJhY3QoYikge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB0aGlzLnguc3VidHJhY3QoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwTXVsdGlwbHkoYikge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB0aGlzLngubXVsdGlwbHkoYi50b0JpZ0ludGVnZXIoKSkubW9kKHRoaXMucCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwU3F1YXJlKCkge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB0aGlzLngucG93KDIpLm1vZCh0aGlzLnApKTtcbn1cblxuZnVuY3Rpb24gZmVGcERpdmlkZShiKSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHRoaXMueC5tdWx0aXBseShiLnRvQmlnSW50ZWdlcigpLm1vZEludmVyc2UodGhpcy5wKSkubW9kKHRoaXMucCkpO1xufVxuXG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5lcXVhbHMgPSBmZUZwRXF1YWxzO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUudG9CaWdJbnRlZ2VyID0gZmVGcFRvQmlnSW50ZWdlcjtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLm5lZ2F0ZSA9IGZlRnBOZWdhdGU7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5hZGQgPSBmZUZwQWRkO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuc3VidHJhY3QgPSBmZUZwU3VidHJhY3Q7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5tdWx0aXBseSA9IGZlRnBNdWx0aXBseTtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLnNxdWFyZSA9IGZlRnBTcXVhcmU7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5kaXZpZGUgPSBmZUZwRGl2aWRlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBFQ1BvaW50RnBcblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIEVDUG9pbnRGcChjdXJ2ZSwgeCwgeSwgeikge1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIC8vIFByb2plY3RpdmUgY29vcmRpbmF0ZXM6IGVpdGhlciB6aW52ID09IG51bGwgb3IgeiAqIHppbnYgPT0gMVxuICAvLyB6IGFuZCB6aW52IGFyZSBqdXN0IEJpZ0ludGVnZXJzLCBub3QgZmllbGRFbGVtZW50c1xuICBpZiAoIXopIHtcbiAgICB0aGlzLnogPSBCaWdJbnRlZ2VyLk9ORTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnogPSB6O1xuICB9XG4gIHRoaXMuemludiA9IG51bGw7XG4gIC8vVE9ETzogY29tcHJlc3Npb24gZmxhZ1xufVxuXG5mdW5jdGlvbiBwb2ludEZwR2V0WCgpIHtcbiAgaWYoIXRoaXMuemludikge1xuICAgIHRoaXMuemludiA9IHRoaXMuei5tb2RJbnZlcnNlKHRoaXMuY3VydmUucCk7XG4gIH1cbiAgdmFyIHIgPSB0aGlzLngudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56aW52KTtcbiAgdGhpcy5jdXJ2ZS5yZWR1Y2Uocik7XG4gIHJldHVybiB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHIpO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwR2V0WSgpIHtcbiAgaWYoIXRoaXMuemludikge1xuICAgIHRoaXMuemludiA9IHRoaXMuei5tb2RJbnZlcnNlKHRoaXMuY3VydmUucCk7XG4gIH1cbiAgdmFyIHIgPSB0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56aW52KTtcbiAgdGhpcy5jdXJ2ZS5yZWR1Y2Uocik7XG4gIHJldHVybiB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHIpO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwRXF1YWxzKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gdGhpcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiBvdGhlci5pc0luZmluaXR5KCk7XG4gIH1cbiAgaWYgKG90aGVyLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiB0aGlzLmlzSW5maW5pdHkoKTtcbiAgfVxuICB2YXIgdSwgdjtcbiAgLy8gdSA9IFkyICogWjEgLSBZMSAqIFoyXG4gIHUgPSBvdGhlci55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy55LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgaWYgKCF1LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICB2ID0gb3RoZXIueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShvdGhlci56KSkubW9kKHRoaXMuY3VydmUucCk7XG4gIHJldHVybiB2LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwSXNJbmZpbml0eSgpIHtcbiAgaWYgKCh0aGlzLnggPT0gbnVsbCkgJiYgKHRoaXMueSA9PSBudWxsKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiAodGhpcy56LmVxdWFscyhCaWdJbnRlZ2VyLlpFUk8pICYmICF0aGlzLnkudG9CaWdJbnRlZ2VyKCkuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykpO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwTmVnYXRlKCkge1xuICAgIHJldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsIHRoaXMueCwgdGhpcy55Lm5lZ2F0ZSgpLCB0aGlzLnopO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwQWRkKGIpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIGI7XG4gIH1cbiAgaWYgKGIuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgdmFyIHUgPSBiLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkoYi56KSkubW9kKHRoaXMuY3VydmUucCk7XG4gIC8vIHYgPSBYMiAqIFoxIC0gWDEgKiBaMlxuICB2YXIgdiA9IGIueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5wKTtcblxuICBpZiAoQmlnSW50ZWdlci5aRVJPLmVxdWFscyh2KSkge1xuICAgIGlmIChCaWdJbnRlZ2VyLlpFUk8uZXF1YWxzKHUpKSB7XG4gICAgICByZXR1cm4gdGhpcy50d2ljZSgpOyAvLyB0aGlzID09IGIsIHNvIGRvdWJsZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpOyAvLyB0aGlzID0gLWIsIHNvIGluZmluaXR5XG4gIH1cblxuICB2YXIgVEhSRUUgPSBuZXcgQmlnSW50ZWdlcihcIjNcIik7XG4gIHZhciB4MSA9IHRoaXMueC50b0JpZ0ludGVnZXIoKTtcbiAgdmFyIHkxID0gdGhpcy55LnRvQmlnSW50ZWdlcigpO1xuXG4gIHZhciB2MiA9IHYucG93KDIpO1xuICB2YXIgdjMgPSB2Mi5tdWx0aXBseSh2KTtcbiAgdmFyIHgxdjIgPSB4MS5tdWx0aXBseSh2Mik7XG4gIHZhciB6dTIgPSB1LnBvdygyKS5tdWx0aXBseSh0aGlzLnopO1xuXG4gIC8vIHgzID0gdiAqICh6MiAqICh6MSAqIHVeMiAtIDIgKiB4MSAqIHZeMikgLSB2XjMpXG4gIHZhciB4MyA9IHp1Mi5zdWJ0cmFjdCh4MXYyLnNoaWZ0TGVmdCgxKSkubXVsdGlwbHkoYi56KS5zdWJ0cmFjdCh2MykubXVsdGlwbHkodikubW9kKHRoaXMuY3VydmUucCk7XG4gIC8vIHkzID0gejIgKiAoMyAqIHgxICogdSAqIHZeMiAtIHkxICogdl4zIC0gejEgKiB1XjMpICsgdSAqIHZeM1xuICB2YXIgeTMgPSB4MXYyLm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh1KS5zdWJ0cmFjdCh5MS5tdWx0aXBseSh2MykpLnN1YnRyYWN0KHp1Mi5tdWx0aXBseSh1KSkubXVsdGlwbHkoYi56KS5hZGQodS5tdWx0aXBseSh2MykpLm1vZCh0aGlzLmN1cnZlLnApO1xuICAvLyB6MyA9IHZeMyAqIHoxICogejJcbiAgdmFyIHozID0gdjMubXVsdGlwbHkodGhpcy56KS5tdWx0aXBseShiLnopLm1vZCh0aGlzLmN1cnZlLnApO1xuXG4gIHJldHVybiBuZXcgRUNQb2ludEZwKHRoaXMuY3VydmUsIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeDMpLCB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHkzKSwgejMpO1xufVxuXG5mdW5jdGlvbiBwb2ludEZwVHdpY2UoKSB7XG4gIGlmKHRoaXMuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHRoaXMueS50b0JpZ0ludGVnZXIoKS5zaWdudW0oKSA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7XG4gIH1cblxuICAvLyBUT0RPOiBvcHRpbWl6ZWQgaGFuZGxpbmcgb2YgY29uc3RhbnRzXG4gIHZhciBUSFJFRSA9IG5ldyBCaWdJbnRlZ2VyKFwiM1wiKTtcbiAgdmFyIHgxID0gdGhpcy54LnRvQmlnSW50ZWdlcigpO1xuICB2YXIgeTEgPSB0aGlzLnkudG9CaWdJbnRlZ2VyKCk7XG5cbiAgdmFyIHkxejEgPSB5MS5tdWx0aXBseSh0aGlzLnopO1xuICB2YXIgeTFzcXoxID0geTF6MS5tdWx0aXBseSh5MSkubW9kKHRoaXMuY3VydmUucCk7XG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hLnRvQmlnSW50ZWdlcigpO1xuXG4gIC8vIHcgPSAzICogeDFeMiArIGEgKiB6MV4yXG4gIHZhciB3ID0geDEucG93KDIpLm11bHRpcGx5KFRIUkVFKTtcbiAgaWYgKCFCaWdJbnRlZ2VyLlpFUk8uZXF1YWxzKGEpKSB7XG4gICAgdyA9IHcuYWRkKHRoaXMuei5wb3coMikubXVsdGlwbHkoYSkpO1xuICB9XG4gIHcgPSB3Lm1vZCh0aGlzLmN1cnZlLnApO1xuICAvL3RoaXMuY3VydmUucmVkdWNlKHcpO1xuICAvLyB4MyA9IDIgKiB5MSAqIHoxICogKHdeMiAtIDggKiB4MSAqIHkxXjIgKiB6MSlcbiAgdmFyIHgzID0gdy5wb3coMikuc3VidHJhY3QoeDEuc2hpZnRMZWZ0KDMpLm11bHRpcGx5KHkxc3F6MSkpLnNoaWZ0TGVmdCgxKS5tdWx0aXBseSh5MXoxKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgLy8geTMgPSA0ICogeTFeMiAqIHoxICogKDMgKiB3ICogeDEgLSAyICogeTFeMiAqIHoxKSAtIHdeM1xuICB2YXIgeTMgPSB3Lm11bHRpcGx5KFRIUkVFKS5tdWx0aXBseSh4MSkuc3VidHJhY3QoeTFzcXoxLnNoaWZ0TGVmdCgxKSkuc2hpZnRMZWZ0KDIpLm11bHRpcGx5KHkxc3F6MSkuc3VidHJhY3Qody5wb3coMikubXVsdGlwbHkodykpLm1vZCh0aGlzLmN1cnZlLnApO1xuICAvLyB6MyA9IDggKiAoeTEgKiB6MSleM1xuICB2YXIgejMgPSB5MXoxLnBvdygyKS5tdWx0aXBseSh5MXoxKS5zaGlmdExlZnQoMykubW9kKHRoaXMuY3VydmUucCk7XG5cbiAgcmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSwgdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih4MyksIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeTMpLCB6Myk7XG59XG5cbi8vIFNpbXBsZSBOQUYgKE5vbi1BZGphY2VudCBGb3JtKSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG1cbi8vIFRPRE86IG1vZHVsYXJpemUgdGhlIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobVxuZnVuY3Rpb24gcG9pbnRGcE11bHRpcGx5KGspIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKGsuc2lnbnVtKCkgPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO1xuICB9XG5cbiAgdmFyIGUgPSBrO1xuICB2YXIgaCA9IGUubXVsdGlwbHkobmV3IEJpZ0ludGVnZXIoXCIzXCIpKTtcblxuICB2YXIgbmVnID0gdGhpcy5uZWdhdGUoKTtcbiAgdmFyIFIgPSB0aGlzO1xuXG4gIHZhciBpO1xuICBmb3IoaSA9IGguYml0TGVuZ3RoKCkgLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgUiA9IFIudHdpY2UoKTtcblxuICAgIHZhciBoQml0ID0gaC50ZXN0Qml0KGkpO1xuICAgIHZhciBlQml0ID0gZS50ZXN0Qml0KGkpO1xuXG4gICAgaWYgKGhCaXQgIT09IGVCaXQpIHtcbiAgICAgIFIgPSBSLmFkZChoQml0ID8gdGhpcyA6IG5lZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFI7XG59XG5cbi8vIENvbXB1dGUgdGhpcypqICsgeCprIChzaW11bHRhbmVvdXMgbXVsdGlwbGljYXRpb24pXG5mdW5jdGlvbiBwb2ludEZwTXVsdGlwbHlUd28oaiwgeCwgaykge1xuICB2YXIgaTtcbiAgaWYgKGouYml0TGVuZ3RoKCkgPiBrLmJpdExlbmd0aCgpKSB7XG4gICAgaSA9IGouYml0TGVuZ3RoKCkgLSAxO1xuICB9IGVsc2Uge1xuICAgIGkgPSBrLmJpdExlbmd0aCgpIC0gMTtcbiAgfVxuXG4gIHZhciBSID0gdGhpcy5jdXJ2ZS5nZXRJbmZpbml0eSgpO1xuICB2YXIgYm90aCA9IHRoaXMuYWRkKHgpO1xuICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgUiA9IFIudHdpY2UoKTtcbiAgICBpZiAoai50ZXN0Qml0KGkpKSB7XG4gICAgICBpZiAoay50ZXN0Qml0KGkpKSB7XG4gICAgICAgIFIgPSBSLmFkZChib3RoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBSID0gUi5hZGQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGsudGVzdEJpdChpKSkge1xuICAgICAgICBSID0gUi5hZGQoeCk7XG4gICAgICB9XG4gICAgfVxuICAgIC0taTtcbiAgfVxuXG4gIHJldHVybiBSO1xufVxuXG5FQ1BvaW50RnAucHJvdG90eXBlLmdldFggPSBwb2ludEZwR2V0WDtcbkVDUG9pbnRGcC5wcm90b3R5cGUuZ2V0WSA9IHBvaW50RnBHZXRZO1xuRUNQb2ludEZwLnByb3RvdHlwZS5lcXVhbHMgPSBwb2ludEZwRXF1YWxzO1xuRUNQb2ludEZwLnByb3RvdHlwZS5pc0luZmluaXR5ID0gcG9pbnRGcElzSW5maW5pdHk7XG5FQ1BvaW50RnAucHJvdG90eXBlLm5lZ2F0ZSA9IHBvaW50RnBOZWdhdGU7XG5FQ1BvaW50RnAucHJvdG90eXBlLmFkZCA9IHBvaW50RnBBZGQ7XG5FQ1BvaW50RnAucHJvdG90eXBlLnR3aWNlID0gcG9pbnRGcFR3aWNlO1xuRUNQb2ludEZwLnByb3RvdHlwZS5tdWx0aXBseSA9IHBvaW50RnBNdWx0aXBseTtcbkVDUG9pbnRGcC5wcm90b3R5cGUubXVsdGlwbHlUd28gPSBwb2ludEZwTXVsdGlwbHlUd287XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIEVDQ3VydmVGcFxuXG4vLyBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gRUNDdXJ2ZUZwKHAsIGEsIGIpIHtcbiAgdGhpcy5wID0gcDtcbiAgdGhpcy5hID0gdGhpcy5mcm9tQmlnSW50ZWdlcihhKTtcbiAgdGhpcy5iID0gdGhpcy5mcm9tQmlnSW50ZWdlcihiKTtcbiAgdGhpcy5pbmZpbml0eSA9IG5ldyBFQ1BvaW50RnAodGhpcywgbnVsbCwgbnVsbCk7XG4gIHRoaXMucmVkdWNlciA9IG5ldyBCYXJyZXR0KHRoaXMucCk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBnZXRQKCkge1xuICByZXR1cm4gdGhpcy5wO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwR2V0QSgpIHtcbiAgcmV0dXJuIHRoaXMuYTtcbn1cblxuZnVuY3Rpb24gY3VydmVGcEdldEIoKSB7XG4gIHJldHVybiB0aGlzLmI7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBFcXVhbHMob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICh0aGlzLnAuZXF1YWxzKG90aGVyLnApICYmIHRoaXMuYS5lcXVhbHMob3RoZXIuYSkgJiYgdGhpcy5iLmVxdWFscyhvdGhlci5iKSk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBDb250YWlucyhwdCkge1xuICAvLyB5XjIgPSB4XjMgKyBhKnggKyBiIG1vZCBwXG4gIHZhciB4ID0gcHQuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLFxuICAgICAgeSA9IHB0LmdldFkoKS50b0JpZ0ludGVnZXIoKSxcbiAgICAgIGEgPSB0aGlzLmEudG9CaWdJbnRlZ2VyKCksXG4gICAgICBiID0gdGhpcy5iLnRvQmlnSW50ZWdlcigpLFxuICAgICAgcCA9IHRoaXMucDtcblxuICB2YXIgbGVmdCA9IHkucG93KDIpLm1vZChwKSxcbiAgICAgIHJpZ2h0ID0geC5wb3coMykuYWRkKGEubXVsdGlwbHkoeCkpLmFkZChiKS5tb2QocClcblxuICByZXR1cm4gbGVmdC5lcXVhbHMocmlnaHQpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwR2V0SW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZmluaXR5O1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwRnJvbUJpZ0ludGVnZXIoeCkge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB4KTtcbn1cblxuZnVuY3Rpb24gY3VydmVSZWR1Y2UoeCkge1xuICB0aGlzLnJlZHVjZXIucmVkdWNlKHgpO1xufVxuXG4vLyBmb3Igbm93LCB3b3JrIHdpdGggaGV4IHN0cmluZ3MgYmVjYXVzZSB0aGV5J3JlIGVhc2llciBpbiBKU1xuZnVuY3Rpb24gY3VydmVGcERlY29kZVBvaW50SGV4KHMpIHtcbiAgc3dpdGNoIChwYXJzZUludChzLnN1YnN0cmluZygwLCAyKSwgMTYpKSB7XG4gICAgLy8gZmlyc3QgYnl0ZVxuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB0aGlzLmluZmluaXR5O1xuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgICAvLyBwb2ludCBjb21wcmVzc2lvbiBub3Qgc3VwcG9ydGVkIHlldFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNjpcbiAgICBjYXNlIDc6XG4gICAgICB2YXIgbGVuID0gKHMubGVuZ3RoIC0gMikgLyAyO1xuICAgICAgdmFyIHhIZXggPSBzLnN1YnN0cigyLCBsZW4pO1xuICAgICAgdmFyIHlIZXggPSBzLnN1YnN0cihsZW4gKyAyLCBsZW4pO1xuXG4gICAgICByZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tQmlnSW50ZWdlcihuZXcgQmlnSW50ZWdlcih4SGV4LCAxNikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tQmlnSW50ZWdlcihuZXcgQmlnSW50ZWdlcih5SGV4LCAxNikpKTtcblxuICAgIGRlZmF1bHQ6IC8vIHVuc3VwcG9ydGVkXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBFbmNvZGVQb2ludEhleChwKSB7XG4gIGlmIChwLmlzSW5maW5pdHkoKSkge1xuICAgIHJldHVybiBcIjAwXCI7XG4gIH1cbiAgdmFyIHhIZXggPSBwLmdldFgoKS50b0JpZ0ludGVnZXIoKS50b1N0cmluZygxNik7XG4gIHZhciB5SGV4ID0gcC5nZXRZKCkudG9CaWdJbnRlZ2VyKCkudG9TdHJpbmcoMTYpO1xuICB2YXIgb0xlbiA9IHRoaXMuZ2V0UCgpLnRvU3RyaW5nKDE2KS5sZW5ndGg7XG4gIGlmICgob0xlbiAlIDIpICE9PSAwKSB7XG4gICAgb0xlbisrO1xuICB9XG4gIHdoaWxlICh4SGV4Lmxlbmd0aCA8IG9MZW4pIHtcbiAgICB4SGV4ID0gXCIwXCIgKyB4SGV4O1xuICB9XG4gIHdoaWxlICh5SGV4Lmxlbmd0aCA8IG9MZW4pIHtcbiAgICB5SGV4ID0gXCIwXCIgKyB5SGV4O1xuICB9XG4gIHJldHVybiBcIjA0XCIgKyB4SGV4ICsgeUhleDtcbn1cblxuRUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRQID0gY3VydmVGcGdldFA7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmdldEEgPSBjdXJ2ZUZwR2V0QTtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0QiA9IGN1cnZlRnBHZXRCO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5lcXVhbHMgPSBjdXJ2ZUZwRXF1YWxzO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5jb250YWlucyA9IGN1cnZlRnBDb250YWlucztcbkVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0SW5maW5pdHkgPSBjdXJ2ZUZwR2V0SW5maW5pdHk7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmZyb21CaWdJbnRlZ2VyID0gY3VydmVGcEZyb21CaWdJbnRlZ2VyO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5yZWR1Y2UgPSBjdXJ2ZVJlZHVjZTtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZGVjb2RlUG9pbnRIZXggPSBjdXJ2ZUZwRGVjb2RlUG9pbnRIZXg7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmVuY29kZVBvaW50SGV4ID0gY3VydmVGcEVuY29kZVBvaW50SGV4O1xuXG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRUNGaWVsZEVsZW1lbnRGcDogRUNGaWVsZEVsZW1lbnRGcCxcbiAgRUNQb2ludEZwOiBFQ1BvaW50RnAsXG4gIEVDQ3VydmVGcDogRUNDdXJ2ZUZwXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/forge.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/forge.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/forge.js - Forge Package Customization\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! node-forge/lib/forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! node-forge/lib/aes */ \"(ssr)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! node-forge/lib/asn1 */ \"(ssr)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! node-forge/lib/cipher */ \"(ssr)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! node-forge/lib/hmac */ \"(ssr)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! node-forge/lib/mgf1 */ \"(ssr)/./node_modules/node-forge/lib/mgf1.js\");\n__webpack_require__(/*! node-forge/lib/pbkdf2 */ \"(ssr)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! node-forge/lib/pem */ \"(ssr)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! node-forge/lib/pkcs1 */ \"(ssr)/./node_modules/node-forge/lib/pkcs1.js\");\n__webpack_require__(/*! node-forge/lib/pkcs7 */ \"(ssr)/./node_modules/node-forge/lib/pkcs7.js\");\n__webpack_require__(/*! node-forge/lib/pki */ \"(ssr)/./node_modules/node-forge/lib/pki.js\");\n__webpack_require__(/*! node-forge/lib/prime */ \"(ssr)/./node_modules/node-forge/lib/prime.js\");\n__webpack_require__(/*! node-forge/lib/prng */ \"(ssr)/./node_modules/node-forge/lib/prng.js\");\n__webpack_require__(/*! node-forge/lib/pss */ \"(ssr)/./node_modules/node-forge/lib/pss.js\");\n__webpack_require__(/*! node-forge/lib/random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! node-forge/lib/sha1 */ \"(ssr)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! node-forge/lib/sha256 */ \"(ssr)/./node_modules/node-forge/lib/sha256.js\");\n__webpack_require__(/*! node-forge/lib/sha512 */ \"(ssr)/./node_modules/node-forge/lib/sha512.js\");\n__webpack_require__(/*! node-forge/lib/util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n\n// Define AES \"raw\" cipher mode\nfunction modeRaw(options) {\n  options = options || {};\n  this.name = \"\";\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._blocks = this.blockSize / 4;\n  this._inBlock = new Array(this._blocks);\n  this._outBlock = new Array(this._blocks);\n}\n\nmodeRaw.prototype.start = function() {};\n\nmodeRaw.prototype.encrypt = function(input, output, finish) {\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  var i;\n\n  // get next block\n  for(i = 0; i < this._blocks; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(i = 0; i < this._blocks; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodeRaw.prototype.decrypt = function(input, output, finish) {\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  var i;\n\n  // get next block\n  for(i = 0; i < this._blocks; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(i = 0; i < this._blocks; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\n(function() {\n  var name = \"AES\",\n      mode = modeRaw,\n      factory;\n  factory = function() { return new forge.aes.Algorithm(name, mode); };\n  forge.cipher.registerAlgorithm(name, factory);\n})();\n\n// Ensure that the jsbn modInverse function always returns a positive result\nconst originalModInverse = forge.jsbn.BigInteger.prototype.modInverse;\nconst positiveModInverse = function(m) {\n  const inv = originalModInverse.apply(this, [m]);\n  return inv.mod(m);\n}\n\nforge.jsbn.BigInteger.prototype.modInverse = positiveModInverse;\n\nmodule.exports = forge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2ZvcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQXNCO0FBQzFDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvZm9yZ2UuanM/Mzg3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRlcHMvZm9yZ2UuanMgLSBGb3JnZSBQYWNrYWdlIEN1c3RvbWl6YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9mb3JnZVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9hZXNcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvYXNuMVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9jaXBoZXJcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvaG1hY1wiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9tZ2YxXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3Bia2RmMlwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wZW1cIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcGtjczFcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcGtjczdcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcGtpXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3ByaW1lXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3BybmdcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcHNzXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3JhbmRvbVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9zaGExXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3NoYTI1NlwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9zaGE1MTJcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvdXRpbFwiKTtcblxuLy8gRGVmaW5lIEFFUyBcInJhd1wiIGNpcGhlciBtb2RlXG5mdW5jdGlvbiBtb2RlUmF3KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmFtZSA9IFwiXCI7XG4gIHRoaXMuY2lwaGVyID0gb3B0aW9ucy5jaXBoZXI7XG4gIHRoaXMuYmxvY2tTaXplID0gb3B0aW9ucy5ibG9ja1NpemUgfHwgMTY7XG4gIHRoaXMuX2Jsb2NrcyA9IHRoaXMuYmxvY2tTaXplIC8gNDtcbiAgdGhpcy5faW5CbG9jayA9IG5ldyBBcnJheSh0aGlzLl9ibG9ja3MpO1xuICB0aGlzLl9vdXRCbG9jayA9IG5ldyBBcnJheSh0aGlzLl9ibG9ja3MpO1xufVxuXG5tb2RlUmF3LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge307XG5cbm1vZGVSYXcucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaTtcblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IoaSA9IDA7IGkgPCB0aGlzLl9ibG9ja3M7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZW5jcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5lbmNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXRcbiAgZm9yKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG5tb2RlUmF3LnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCwgZmluaXNoKSB7XG4gIGlmKGlucHV0Lmxlbmd0aCgpIDwgdGhpcy5ibG9ja1NpemUgJiYgIShmaW5pc2ggJiYgaW5wdXQubGVuZ3RoKCkgPiAwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGk7XG5cbiAgLy8gZ2V0IG5leHQgYmxvY2tcbiAgZm9yKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tzOyArK2kpIHtcbiAgICB0aGlzLl9pbkJsb2NrW2ldID0gaW5wdXQuZ2V0SW50MzIoKTtcbiAgfVxuXG4gIC8vIGRlY3J5cHQgYmxvY2tcbiAgdGhpcy5jaXBoZXIuZGVjcnlwdCh0aGlzLl9pbkJsb2NrLCB0aGlzLl9vdXRCbG9jayk7XG5cbiAgLy8gd3JpdGUgb3V0cHV0XG4gIGZvcihpID0gMDsgaSA8IHRoaXMuX2Jsb2NrczsgKytpKSB7XG4gICAgb3V0cHV0LnB1dEludDMyKHRoaXMuX291dEJsb2NrW2ldKTtcbiAgfVxufTtcblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IFwiQUVTXCIsXG4gICAgICBtb2RlID0gbW9kZVJhdyxcbiAgICAgIGZhY3Rvcnk7XG4gIGZhY3RvcnkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBmb3JnZS5hZXMuQWxnb3JpdGhtKG5hbWUsIG1vZGUpOyB9O1xuICBmb3JnZS5jaXBoZXIucmVnaXN0ZXJBbGdvcml0aG0obmFtZSwgZmFjdG9yeSk7XG59KSgpO1xuXG4vLyBFbnN1cmUgdGhhdCB0aGUganNibiBtb2RJbnZlcnNlIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgcG9zaXRpdmUgcmVzdWx0XG5jb25zdCBvcmlnaW5hbE1vZEludmVyc2UgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2U7XG5jb25zdCBwb3NpdGl2ZU1vZEludmVyc2UgPSBmdW5jdGlvbihtKSB7XG4gIGNvbnN0IGludiA9IG9yaWdpbmFsTW9kSW52ZXJzZS5hcHBseSh0aGlzLCBbbV0pO1xuICByZXR1cm4gaW52Lm1vZChtKTtcbn1cblxuZm9yZ2UuanNibi5CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnZlcnNlID0gcG9zaXRpdmVNb2RJbnZlcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcmdlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/forge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/node-jose/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * index.js - Main Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nif (typeof Promise === \"undefined\") {\n  (__webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\").polyfill)();\n}\n\nif (typeof Buffer === \"undefined\") {\n  (global || window).Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n}\n\nif (typeof process === \"undefined\") {\n  (global || window).process = __webpack_require__(/*! process */ \"process\");\n}\n\nif (!process.version) {\n  process.version = \"\";\n}\n\nvar JWS = __webpack_require__(/*! ./jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\");\n\nmodule.exports = {\n  JWA: __webpack_require__(/*! ./algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\"),\n  JWE: __webpack_require__(/*! ./jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWK: __webpack_require__(/*! ./jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n  JWS: JWS,\n  util: __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n  parse: __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/node-jose/lib/parse/index.js\"),\n  canYouSee: JWS.createVerify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxFQUFFLHlHQUErQjtBQUNqQzs7QUFFQTtBQUNBLDhCQUE4QixvREFBd0I7QUFDdEQ7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyx3QkFBUztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDhEQUFPOztBQUV6QjtBQUNBLE9BQU8sbUJBQU8sQ0FBQyw0RUFBYztBQUM3QixPQUFPLG1CQUFPLENBQUMsOERBQU87QUFDdEIsT0FBTyxtQkFBTyxDQUFDLDhEQUFPO0FBQ3RCO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLGdFQUFRO0FBQ3hCLFNBQVMsbUJBQU8sQ0FBQyxrRUFBUztBQUMxQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2luZGV4LmpzPzc3YmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBpbmRleC5qcyAtIE1haW4gRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZiBQcm9taXNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlcXVpcmUoXCJlczYtcHJvbWlzZVwiKS5wb2x5ZmlsbCgpO1xufVxuXG5pZiAodHlwZW9mIEJ1ZmZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZ2xvYmFsIHx8IHdpbmRvdykuQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG59XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZ2xvYmFsIHx8IHdpbmRvdykucHJvY2VzcyA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xufVxuXG5pZiAoIXByb2Nlc3MudmVyc2lvbikge1xuICBwcm9jZXNzLnZlcnNpb24gPSBcIlwiO1xufVxuXG52YXIgSldTID0gcmVxdWlyZShcIi4vandzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSldBOiByZXF1aXJlKFwiLi9hbGdvcml0aG1zXCIpLFxuICBKV0U6IHJlcXVpcmUoXCIuL2p3ZVwiKSxcbiAgSldLOiByZXF1aXJlKFwiLi9qd2tcIiksXG4gIEpXUzogSldTLFxuICB1dGlsOiByZXF1aXJlKFwiLi91dGlsXCIpLFxuICBwYXJzZTogcmVxdWlyZShcIi4vcGFyc2VcIiksXG4gIGNhbllvdVNlZTogSldTLmNyZWF0ZVZlcmlmeVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/decrypt.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/decrypt.js - Decrypt from a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar base64url = __webpack_require__(/*! ../util/base64url */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n    AlgConfig = __webpack_require__(/*! ../util/algconfig */ \"(ssr)/./node_modules/node-jose/lib/util/algconfig.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\"\n};\n\n/**\n * @class JWE.Decrypter\n * @classdesc Processor of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead\n * call {@link JWE.createDecrypt}.\n */\nfunction JWEDecrypter(ks, globalOpts) {\n  var assumedKey,\n    keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    throw new TypeError(\"Keystore must be provided\");\n  }\n\n  globalOpts = merge({}, DEFAULT_OPTIONS, globalOpts);\n\n  /**\n   * Decrypts the given input.\n   *\n   * {opts}, if provided, is used to customize this specific decrypt operation.\n   * This argument has the same semantics as {JWE.createDecrypt}, and takes\n   * precedence over those options.\n   *\n   * The returned PRomise, when fulfilled, returns an object with the\n   * following members:\n   *\n   * - `header` - The JOSE Header, combined from the relevant \"header\" and\n   *            \"protected\" fields from the original JWE object.\n   * - `protected` - An array containing the names of the protected fields\n   * - `key` - The used to decrypt the content\n   * - `payload` - The decrypted content (as a Buffer)\n   * - `plaintext` - An alias for `payload`\n   *\n   * @param {Object|String} input The encrypted content\n   * @param {Object} [opts] The options for this decryption operation.\n   * @returns {Promise} A promise for the decyprted plaintext\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      /* eslint camelcase: [0] */\n      if (typeof input === \"string\") {\n        input = input.split(\".\");\n        input = {\n          protected: input[0],\n          recipients: [\n            {\n              encrypted_key: input[1]\n            }\n          ],\n          iv: input[2],\n          ciphertext: input[3],\n          tag: input[4]\n        };\n      } else if (!input || typeof input !== \"object\") {\n        throw new Error(\"invalid input\");\n      }\n      if (\"encrypted_key\" in input) {\n        input.recipients = [\n          {\n            encrypted_key: input.encrypted_key\n          }\n        ];\n      }\n\n      var promise;\n\n      // ensure recipients exists\n      var rcptList = input.recipients || [{}];\n      promise = Promise.resolve(rcptList);\n\n      //combine fields\n      var fields,\n          protect;\n      promise = promise.then(function(rcptList) {\n        if (input.protected) {\n          protect = base64url.decode(input.protected).toString(\"utf8\");\n          protect = JSON.parse(protect);\n\n          // verify \"crit\" field first\n          var crit = protect.crit;\n          if (crit) {\n            if (!Array.isArray(crit)) {\n              return Promise.reject(new Error(\"Invalid 'crit' header\"));\n            }\n            for (var idx = 0; crit.length > idx; idx++) {\n              if (-1 === handlerKeys.indexOf(crit[idx])) {\n                return Promise.reject(new Error(\n                    \"Critical extension is not supported: \" + crit[idx]\n                ));\n              }\n            }\n          }\n\n          fields = protect;\n          protect = Object.keys(protect);\n        } else {\n          fields = {};\n          protect = [];\n        }\n        fields = merge(input.unprotected || {}, fields);\n\n        rcptList = rcptList.map(function(r) {\n          var promise = Promise.resolve();\n          var header = r.header || {};\n          header = merge(header, fields);\n          r.header = header;\n          r.protected = protect;\n\n          // check on allowed algorithms\n          if (!algSpec.match(header.alg)) {\n            promise = promise.then(function() {\n              return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n            });\n          }\n          if (!algSpec.match(header.enc)) {\n            promise = promise.then(function () {\n              return Promise.reject(new Error(\"Algorithm not allowed: \" + header.enc));\n            });\n          }\n\n          if (header.epk) {\n            promise = promise.then(function() {\n              return JWK.asKey(header.epk);\n            });\n            promise = promise.then(function(epk) {\n              header.epk = epk.toObject(false);\n            });\n          }\n          return promise.then(function() {\n            return r;\n          });\n        });\n\n        return Promise.all(rcptList);\n      });\n\n      // decrypt with first key found\n      var algKey,\n        encKey,\n        kdata;\n      promise = promise.then(function(rcptList) {\n        var jwe = {};\n        return new Promise(function(resolve, reject) {\n          var processKey = function() {\n            var rcpt = rcptList.shift();\n            if (!rcpt) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            var algPromise = Promise.resolve(rcpt);\n            algPromise = algPromise.then(function(rcpt) {\n              // try to unwrap encrypted key\n              var prekey = kdata = rcpt.encrypted_key || \"\";\n              prekey = base64url.decode(prekey);\n              algKey = assumedKey || keystore.get({\n                use: \"enc\",\n                alg: rcpt.header.alg,\n                kid: rcpt.header.kid\n              });\n              if (algKey) {\n                return algKey.unwrap(rcpt.header.alg, prekey, rcpt.header);\n              } else {\n                return Promise.reject();\n              }\n            });\n            algPromise = algPromise.then(function(key) {\n              encKey = {\n                \"kty\": \"oct\",\n                \"k\": base64url.encode(key)\n              };\n              encKey = JWK.asKey(encKey);\n              jwe.key = algKey;\n              jwe.header = rcpt.header;\n              jwe.protected = rcpt.protected;\n              resolve(jwe);\n            });\n            algPromise.catch(processKey);\n          };\n          processKey();\n        });\n      });\n\n      // assign decipher inputs\n      promise = promise.then(function(jwe) {\n        jwe.iv = input.iv;\n        jwe.tag = input.tag;\n        jwe.ciphertext = input.ciphertext;\n\n        return jwe;\n      });\n\n      // process any prepare-decrypt handlers\n      promise = promise.then(function(jwe) {\n        var processing = [];\n        handlerKeys.forEach(function(h) {\n          h = extraHandlers[h];\n          var p;\n          if (\"function\" === typeof h) {\n            p = h(jwe);\n          } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n            p = h.prepare(jwe);\n          }\n          if (p) {\n            processing.push(Promise.resolve(p));\n          }\n        });\n        return Promise.all(processing).then(function() {\n          // don't actually care about individual handler results\n          // assume {jwe} is updated\n          return jwe;\n        });\n      });\n\n      // prepare decrypt inputs\n      promise = promise.then(function(jwe) {\n        if (!Buffer.isBuffer(jwe.ciphertext)) {\n          jwe.ciphertext = base64url.decode(jwe.ciphertext);\n        }\n\n        return jwe;\n      });\n\n      // decrypt it!\n      promise = promise.then(function(jwe) {\n        var adata = input.protected;\n        if (\"aad\" in input && null != input.aad) {\n          adata += \".\" + input.aad;\n        }\n\n        var params = {\n          iv: jwe.iv,\n          adata: adata,\n          tag: jwe.tag,\n          kdata: kdata,\n          epu: jwe.epu,\n          epv: jwe.epv\n        };\n        var cdata = jwe.ciphertext;\n\n        delete jwe.iv;\n        delete jwe.tag;\n        delete jwe.ciphertext;\n\n        return encKey.\n          then(function(enkKey) {\n            return enkKey.decrypt(jwe.header.enc, cdata, params).\n              then(function(pdata) {\n                jwe.payload = jwe.plaintext = pdata;\n                return jwe;\n              });\n          });\n      });\n\n      // (OPTIONAL) decompress plaintext\n      promise = promise.then(function(jwe) {\n        if (\"DEF\" === jwe.header.zip) {\n          return new Promise(function(resolve, reject) {\n            try {\n              var data = pako.inflateRaw(Buffer.from(jwe.plaintext))\n\n              jwe.payload = jwe.plaintext = Buffer.from(data);\n              resolve(jwe);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        }\n\n        return jwe;\n      });\n\n      // process any post-decrypt handlers\n      promise = promise.then(function(jwe) {\n        var processing = [];\n        handlerKeys.forEach(function(h) {\n          h = extraHandlers[h];\n          var p;\n          if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n            p = h.complete(jwe);\n          }\n          if (p) {\n            processing.push(Promise.resolve(p));\n          }\n        });\n        return Promise.all(processing).then(function() {\n          // don't actually care about individual handler results\n          // assume {jwe} is updated\n          return jwe;\n        });\n      });\n\n      return promise;\n    }\n  });\n}\n\n/**\n * @description\n * Creates a new Decrypter for the given Key or KeyStore.\n *\n * {opts}, when provided, is used to customize decryption processes. The\n * following options are currently supported:\n *\n * - `handlers` - An object where each name is a JOSE header member name and\n *   the value can be a boolean, function, or an object.\n *\n * Handlers are intended to support 'crit' extensions. When a boolean value,\n * the member is expected to be processed once decryption is fully complete.\n * When a function, it is called just before the ciphertext is decrypted\n * (processed as if it were a `prepare` handler, as decribed below). When an\n * object, it can contain any of the following members:\n *\n * - `recipient` - A function called after a valid key is determined; it takes\n *   an object describing the recipient, and returns a Promise that is\n *   fulfilled once the handler's processing is complete.\n * - `prepare` - A function called just prior to decrypting the ciphertext;\n *   it takes an object describing the decryption result (but containing\n *   `ciphertext` and `tag' instead of `payload` and `plaintext`), and\n *   returns a Promise that is fulfilled once the handler's processing is\n *   complete.\n * - `complete` - A function called once decryption is complete, just prior\n *   to fulfilling the Promise returned by `decrypt()`; it takes the object\n *   that will be returned by `decrypt()`'s fulfilled Promise, and returns\n *   a Promise that is fulfilled once the handler's processing is complete.\n *\n * Note that normal processing of `decrypt()` does not continue until all\n * relevant handlers have completed. Any changes handlers make to the\n * provided objects affects `decrypt()`'s processing.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for decryption.\n * @param {Object} [opts] The options for this Decrypter.\n * @returns {JWE.Decrypter} The new Decrypter.\n */\nfunction createDecrypt(ks, opts) {\n  var dec = new JWEDecrypter(ks, opts);\n  return dec;\n}\n\nmodule.exports = {\n  decrypter: JWEDecrypter,\n  createDecrypt: createDecrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVjcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxVQUFVLG1CQUFPLENBQUMsK0RBQVE7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxnREFBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQ1gsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixXQUFXO0FBQ1gsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVjcnlwdC5qcz80YjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandlL2RlY3J5cHQuanMgLSBEZWNyeXB0IGZyb20gYSBKV0VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGJhc2U2NHVybCA9IHJlcXVpcmUoXCIuLi91dGlsL2Jhc2U2NHVybFwiKSxcbiAgICBBbGdDb25maWcgPSByZXF1aXJlKFwiLi4vdXRpbC9hbGdjb25maWdcIiksXG4gICAgSldLID0gcmVxdWlyZShcIi4uL2p3a1wiKSxcbiAgICBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpLFxuICAgIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgYWxnb3JpdGhtczogXCIqXCJcbn07XG5cbi8qKlxuICogQGNsYXNzIEpXRS5EZWNyeXB0ZXJcbiAqIEBjbGFzc2Rlc2MgUHJvY2Vzc29yIG9mIGVuY3J5cHRlZCBkYXRhLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIFRoaXMgY2xhc3MgY2Fubm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gSW5zdGVhZFxuICogY2FsbCB7QGxpbmsgSldFLmNyZWF0ZURlY3J5cHR9LlxuICovXG5mdW5jdGlvbiBKV0VEZWNyeXB0ZXIoa3MsIGdsb2JhbE9wdHMpIHtcbiAgdmFyIGFzc3VtZWRLZXksXG4gICAga2V5c3RvcmU7XG5cbiAgaWYgKEpXSy5pc0tleShrcykpIHtcbiAgICBhc3N1bWVkS2V5ID0ga3M7XG4gICAga2V5c3RvcmUgPSBhc3N1bWVkS2V5LmtleXN0b3JlO1xuICB9IGVsc2UgaWYgKEpXSy5pc0tleVN0b3JlKGtzKSkge1xuICAgIGtleXN0b3JlID0ga3M7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleXN0b3JlIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gIH1cblxuICBnbG9iYWxPcHRzID0gbWVyZ2Uoe30sIERFRkFVTFRfT1BUSU9OUywgZ2xvYmFsT3B0cyk7XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBpbnB1dC5cbiAgICpcbiAgICoge29wdHN9LCBpZiBwcm92aWRlZCwgaXMgdXNlZCB0byBjdXN0b21pemUgdGhpcyBzcGVjaWZpYyBkZWNyeXB0IG9wZXJhdGlvbi5cbiAgICogVGhpcyBhcmd1bWVudCBoYXMgdGhlIHNhbWUgc2VtYW50aWNzIGFzIHtKV0UuY3JlYXRlRGVjcnlwdH0sIGFuZCB0YWtlc1xuICAgKiBwcmVjZWRlbmNlIG92ZXIgdGhvc2Ugb3B0aW9ucy5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIFBSb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgKiBmb2xsb3dpbmcgbWVtYmVyczpcbiAgICpcbiAgICogLSBgaGVhZGVyYCAtIFRoZSBKT1NFIEhlYWRlciwgY29tYmluZWQgZnJvbSB0aGUgcmVsZXZhbnQgXCJoZWFkZXJcIiBhbmRcbiAgICogICAgICAgICAgICBcInByb3RlY3RlZFwiIGZpZWxkcyBmcm9tIHRoZSBvcmlnaW5hbCBKV0Ugb2JqZWN0LlxuICAgKiAtIGBwcm90ZWN0ZWRgIC0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgdGhlIHByb3RlY3RlZCBmaWVsZHNcbiAgICogLSBga2V5YCAtIFRoZSB1c2VkIHRvIGRlY3J5cHQgdGhlIGNvbnRlbnRcbiAgICogLSBgcGF5bG9hZGAgLSBUaGUgZGVjcnlwdGVkIGNvbnRlbnQgKGFzIGEgQnVmZmVyKVxuICAgKiAtIGBwbGFpbnRleHRgIC0gQW4gYWxpYXMgZm9yIGBwYXlsb2FkYFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IFRoZSBlbmNyeXB0ZWQgY29udGVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIFRoZSBvcHRpb25zIGZvciB0aGlzIGRlY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIGZvciB0aGUgZGVjeXBydGVkIHBsYWludGV4dFxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVjcnlwdFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGlucHV0LCBvcHRzKSB7XG4gICAgICBvcHRzID0gbWVyZ2Uoe30sIGdsb2JhbE9wdHMsIG9wdHMgfHwge30pO1xuICAgICAgdmFyIGV4dHJhSGFuZGxlcnMgPSBvcHRzLmhhbmRsZXJzIHx8IHt9O1xuICAgICAgdmFyIGhhbmRsZXJLZXlzID0gT2JqZWN0LmtleXMoZXh0cmFIYW5kbGVycyk7XG4gICAgICB2YXIgYWxnU3BlYyA9IG5ldyBBbGdDb25maWcob3B0cy5hbGdvcml0aG1zKTtcblxuICAgICAgLyogZXNsaW50IGNhbWVsY2FzZTogWzBdICovXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpbnB1dCA9IHtcbiAgICAgICAgICBwcm90ZWN0ZWQ6IGlucHV0WzBdLFxuICAgICAgICAgIHJlY2lwaWVudHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZW5jcnlwdGVkX2tleTogaW5wdXRbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGl2OiBpbnB1dFsyXSxcbiAgICAgICAgICBjaXBoZXJ0ZXh0OiBpbnB1dFszXSxcbiAgICAgICAgICB0YWc6IGlucHV0WzRdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChcImVuY3J5cHRlZF9rZXlcIiBpbiBpbnB1dCkge1xuICAgICAgICBpbnB1dC5yZWNpcGllbnRzID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVuY3J5cHRlZF9rZXk6IGlucHV0LmVuY3J5cHRlZF9rZXlcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAvLyBlbnN1cmUgcmVjaXBpZW50cyBleGlzdHNcbiAgICAgIHZhciByY3B0TGlzdCA9IGlucHV0LnJlY2lwaWVudHMgfHwgW3t9XTtcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocmNwdExpc3QpO1xuXG4gICAgICAvL2NvbWJpbmUgZmllbGRzXG4gICAgICB2YXIgZmllbGRzLFxuICAgICAgICAgIHByb3RlY3Q7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJjcHRMaXN0KSB7XG4gICAgICAgIGlmIChpbnB1dC5wcm90ZWN0ZWQpIHtcbiAgICAgICAgICBwcm90ZWN0ID0gYmFzZTY0dXJsLmRlY29kZShpbnB1dC5wcm90ZWN0ZWQpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICBwcm90ZWN0ID0gSlNPTi5wYXJzZShwcm90ZWN0KTtcblxuICAgICAgICAgIC8vIHZlcmlmeSBcImNyaXRcIiBmaWVsZCBmaXJzdFxuICAgICAgICAgIHZhciBjcml0ID0gcHJvdGVjdC5jcml0O1xuICAgICAgICAgIGlmIChjcml0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3JpdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgJ2NyaXQnIGhlYWRlclwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBjcml0Lmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgaWYgKC0xID09PSBoYW5kbGVyS2V5cy5pbmRleE9mKGNyaXRbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkNyaXRpY2FsIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiBcIiArIGNyaXRbaWR4XVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmllbGRzID0gcHJvdGVjdDtcbiAgICAgICAgICBwcm90ZWN0ID0gT2JqZWN0LmtleXMocHJvdGVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzID0ge307XG4gICAgICAgICAgcHJvdGVjdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcyA9IG1lcmdlKGlucHV0LnVucHJvdGVjdGVkIHx8IHt9LCBmaWVsZHMpO1xuXG4gICAgICAgIHJjcHRMaXN0ID0gcmNwdExpc3QubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIHZhciBoZWFkZXIgPSByLmhlYWRlciB8fCB7fTtcbiAgICAgICAgICBoZWFkZXIgPSBtZXJnZShoZWFkZXIsIGZpZWxkcyk7XG4gICAgICAgICAgci5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgci5wcm90ZWN0ZWQgPSBwcm90ZWN0O1xuXG4gICAgICAgICAgLy8gY2hlY2sgb24gYWxsb3dlZCBhbGdvcml0aG1zXG4gICAgICAgICAgaWYgKCFhbGdTcGVjLm1hdGNoKGhlYWRlci5hbGcpKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQWxnb3JpdGhtIG5vdCBhbGxvd2VkOiBcIiArIGhlYWRlci5hbGcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWFsZ1NwZWMubWF0Y2goaGVhZGVyLmVuYykpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQWxnb3JpdGhtIG5vdCBhbGxvd2VkOiBcIiArIGhlYWRlci5lbmMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoZWFkZXIuZXBrKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gSldLLmFzS2V5KGhlYWRlci5lcGspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGVwaykge1xuICAgICAgICAgICAgICBoZWFkZXIuZXBrID0gZXBrLnRvT2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyY3B0TGlzdCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZGVjcnlwdCB3aXRoIGZpcnN0IGtleSBmb3VuZFxuICAgICAgdmFyIGFsZ0tleSxcbiAgICAgICAgZW5jS2V5LFxuICAgICAgICBrZGF0YTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmNwdExpc3QpIHtcbiAgICAgICAgdmFyIGp3ZSA9IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHByb2Nlc3NLZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByY3B0ID0gcmNwdExpc3Quc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghcmNwdCkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibm8ga2V5IGZvdW5kXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWxnUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyY3B0KTtcbiAgICAgICAgICAgIGFsZ1Byb21pc2UgPSBhbGdQcm9taXNlLnRoZW4oZnVuY3Rpb24ocmNwdCkge1xuICAgICAgICAgICAgICAvLyB0cnkgdG8gdW53cmFwIGVuY3J5cHRlZCBrZXlcbiAgICAgICAgICAgICAgdmFyIHByZWtleSA9IGtkYXRhID0gcmNwdC5lbmNyeXB0ZWRfa2V5IHx8IFwiXCI7XG4gICAgICAgICAgICAgIHByZWtleSA9IGJhc2U2NHVybC5kZWNvZGUocHJla2V5KTtcbiAgICAgICAgICAgICAgYWxnS2V5ID0gYXNzdW1lZEtleSB8fCBrZXlzdG9yZS5nZXQoe1xuICAgICAgICAgICAgICAgIHVzZTogXCJlbmNcIixcbiAgICAgICAgICAgICAgICBhbGc6IHJjcHQuaGVhZGVyLmFsZyxcbiAgICAgICAgICAgICAgICBraWQ6IHJjcHQuaGVhZGVyLmtpZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFsZ0tleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGdLZXkudW53cmFwKHJjcHQuaGVhZGVyLmFsZywgcHJla2V5LCByY3B0LmhlYWRlcik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWxnUHJvbWlzZSA9IGFsZ1Byb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgZW5jS2V5ID0ge1xuICAgICAgICAgICAgICAgIFwia3R5XCI6IFwib2N0XCIsXG4gICAgICAgICAgICAgICAgXCJrXCI6IGJhc2U2NHVybC5lbmNvZGUoa2V5KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBlbmNLZXkgPSBKV0suYXNLZXkoZW5jS2V5KTtcbiAgICAgICAgICAgICAgandlLmtleSA9IGFsZ0tleTtcbiAgICAgICAgICAgICAgandlLmhlYWRlciA9IHJjcHQuaGVhZGVyO1xuICAgICAgICAgICAgICBqd2UucHJvdGVjdGVkID0gcmNwdC5wcm90ZWN0ZWQ7XG4gICAgICAgICAgICAgIHJlc29sdmUoandlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWxnUHJvbWlzZS5jYXRjaChwcm9jZXNzS2V5KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByb2Nlc3NLZXkoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYXNzaWduIGRlY2lwaGVyIGlucHV0c1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgandlLml2ID0gaW5wdXQuaXY7XG4gICAgICAgIGp3ZS50YWcgPSBpbnB1dC50YWc7XG4gICAgICAgIGp3ZS5jaXBoZXJ0ZXh0ID0gaW5wdXQuY2lwaGVydGV4dDtcblxuICAgICAgICByZXR1cm4gandlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2Nlc3MgYW55IHByZXBhcmUtZGVjcnlwdCBoYW5kbGVyc1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NpbmcgPSBbXTtcbiAgICAgICAgaGFuZGxlcktleXMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgaCA9IGV4dHJhSGFuZGxlcnNbaF07XG4gICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGgpIHtcbiAgICAgICAgICAgIHAgPSBoKGp3ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgaCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoLnByZXBhcmUpIHtcbiAgICAgICAgICAgIHAgPSBoLnByZXBhcmUoandlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChQcm9taXNlLnJlc29sdmUocCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIGRvbid0IGFjdHVhbGx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCBoYW5kbGVyIHJlc3VsdHNcbiAgICAgICAgICAvLyBhc3N1bWUge2p3ZX0gaXMgdXBkYXRlZFxuICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXBhcmUgZGVjcnlwdCBpbnB1dHNcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGp3ZS5jaXBoZXJ0ZXh0KSkge1xuICAgICAgICAgIGp3ZS5jaXBoZXJ0ZXh0ID0gYmFzZTY0dXJsLmRlY29kZShqd2UuY2lwaGVydGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gandlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGRlY3J5cHQgaXQhXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICB2YXIgYWRhdGEgPSBpbnB1dC5wcm90ZWN0ZWQ7XG4gICAgICAgIGlmIChcImFhZFwiIGluIGlucHV0ICYmIG51bGwgIT0gaW5wdXQuYWFkKSB7XG4gICAgICAgICAgYWRhdGEgKz0gXCIuXCIgKyBpbnB1dC5hYWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICAgIGl2OiBqd2UuaXYsXG4gICAgICAgICAgYWRhdGE6IGFkYXRhLFxuICAgICAgICAgIHRhZzogandlLnRhZyxcbiAgICAgICAgICBrZGF0YToga2RhdGEsXG4gICAgICAgICAgZXB1OiBqd2UuZXB1LFxuICAgICAgICAgIGVwdjogandlLmVwdlxuICAgICAgICB9O1xuICAgICAgICB2YXIgY2RhdGEgPSBqd2UuY2lwaGVydGV4dDtcblxuICAgICAgICBkZWxldGUgandlLml2O1xuICAgICAgICBkZWxldGUgandlLnRhZztcbiAgICAgICAgZGVsZXRlIGp3ZS5jaXBoZXJ0ZXh0O1xuXG4gICAgICAgIHJldHVybiBlbmNLZXkuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbihlbmtLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmtLZXkuZGVjcnlwdChqd2UuaGVhZGVyLmVuYywgY2RhdGEsIHBhcmFtcykuXG4gICAgICAgICAgICAgIHRoZW4oZnVuY3Rpb24ocGRhdGEpIHtcbiAgICAgICAgICAgICAgICBqd2UucGF5bG9hZCA9IGp3ZS5wbGFpbnRleHQgPSBwZGF0YTtcbiAgICAgICAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyAoT1BUSU9OQUwpIGRlY29tcHJlc3MgcGxhaW50ZXh0XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICBpZiAoXCJERUZcIiA9PT0gandlLmhlYWRlci56aXApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHBha28uaW5mbGF0ZVJhdyhCdWZmZXIuZnJvbShqd2UucGxhaW50ZXh0KSlcblxuICAgICAgICAgICAgICBqd2UucGF5bG9hZCA9IGp3ZS5wbGFpbnRleHQgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShqd2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcm9jZXNzIGFueSBwb3N0LWRlY3J5cHQgaGFuZGxlcnNcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHZhciBwcm9jZXNzaW5nID0gW107XG4gICAgICAgIGhhbmRsZXJLZXlzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgIGggPSBleHRyYUhhbmRsZXJzW2hdO1xuICAgICAgICAgIHZhciBwO1xuICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgaCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICBwID0gaC5jb21wbGV0ZShqd2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcHJvY2Vzc2luZy5wdXNoKFByb21pc2UucmVzb2x2ZShwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb2Nlc3NpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgY2FyZSBhYm91dCBpbmRpdmlkdWFsIGhhbmRsZXIgcmVzdWx0c1xuICAgICAgICAgIC8vIGFzc3VtZSB7andlfSBpcyB1cGRhdGVkXG4gICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBuZXcgRGVjcnlwdGVyIGZvciB0aGUgZ2l2ZW4gS2V5IG9yIEtleVN0b3JlLlxuICpcbiAqIHtvcHRzfSwgd2hlbiBwcm92aWRlZCwgaXMgdXNlZCB0byBjdXN0b21pemUgZGVjcnlwdGlvbiBwcm9jZXNzZXMuIFRoZVxuICogZm9sbG93aW5nIG9wdGlvbnMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQ6XG4gKlxuICogLSBgaGFuZGxlcnNgIC0gQW4gb2JqZWN0IHdoZXJlIGVhY2ggbmFtZSBpcyBhIEpPU0UgaGVhZGVyIG1lbWJlciBuYW1lIGFuZFxuICogICB0aGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiwgZnVuY3Rpb24sIG9yIGFuIG9iamVjdC5cbiAqXG4gKiBIYW5kbGVycyBhcmUgaW50ZW5kZWQgdG8gc3VwcG9ydCAnY3JpdCcgZXh0ZW5zaW9ucy4gV2hlbiBhIGJvb2xlYW4gdmFsdWUsXG4gKiB0aGUgbWVtYmVyIGlzIGV4cGVjdGVkIHRvIGJlIHByb2Nlc3NlZCBvbmNlIGRlY3J5cHRpb24gaXMgZnVsbHkgY29tcGxldGUuXG4gKiBXaGVuIGEgZnVuY3Rpb24sIGl0IGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgY2lwaGVydGV4dCBpcyBkZWNyeXB0ZWRcbiAqIChwcm9jZXNzZWQgYXMgaWYgaXQgd2VyZSBhIGBwcmVwYXJlYCBoYW5kbGVyLCBhcyBkZWNyaWJlZCBiZWxvdykuIFdoZW4gYW5cbiAqIG9iamVjdCwgaXQgY2FuIGNvbnRhaW4gYW55IG9mIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqXG4gKiAtIGByZWNpcGllbnRgIC0gQSBmdW5jdGlvbiBjYWxsZWQgYWZ0ZXIgYSB2YWxpZCBrZXkgaXMgZGV0ZXJtaW5lZDsgaXQgdGFrZXNcbiAqICAgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHJlY2lwaWVudCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHRoYXQgaXNcbiAqICAgZnVsZmlsbGVkIG9uY2UgdGhlIGhhbmRsZXIncyBwcm9jZXNzaW5nIGlzIGNvbXBsZXRlLlxuICogLSBgcHJlcGFyZWAgLSBBIGZ1bmN0aW9uIGNhbGxlZCBqdXN0IHByaW9yIHRvIGRlY3J5cHRpbmcgdGhlIGNpcGhlcnRleHQ7XG4gKiAgIGl0IHRha2VzIGFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBkZWNyeXB0aW9uIHJlc3VsdCAoYnV0IGNvbnRhaW5pbmdcbiAqICAgYGNpcGhlcnRleHRgIGFuZCBgdGFnJyBpbnN0ZWFkIG9mIGBwYXlsb2FkYCBhbmQgYHBsYWludGV4dGApLCBhbmRcbiAqICAgcmV0dXJucyBhIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgb25jZSB0aGUgaGFuZGxlcidzIHByb2Nlc3NpbmcgaXNcbiAqICAgY29tcGxldGUuXG4gKiAtIGBjb21wbGV0ZWAgLSBBIGZ1bmN0aW9uIGNhbGxlZCBvbmNlIGRlY3J5cHRpb24gaXMgY29tcGxldGUsIGp1c3QgcHJpb3JcbiAqICAgdG8gZnVsZmlsbGluZyB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSBgZGVjcnlwdCgpYDsgaXQgdGFrZXMgdGhlIG9iamVjdFxuICogICB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgYnkgYGRlY3J5cHQoKWAncyBmdWxmaWxsZWQgUHJvbWlzZSwgYW5kIHJldHVybnNcbiAqICAgYSBQcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIG9uY2UgdGhlIGhhbmRsZXIncyBwcm9jZXNzaW5nIGlzIGNvbXBsZXRlLlxuICpcbiAqIE5vdGUgdGhhdCBub3JtYWwgcHJvY2Vzc2luZyBvZiBgZGVjcnlwdCgpYCBkb2VzIG5vdCBjb250aW51ZSB1bnRpbCBhbGxcbiAqIHJlbGV2YW50IGhhbmRsZXJzIGhhdmUgY29tcGxldGVkLiBBbnkgY2hhbmdlcyBoYW5kbGVycyBtYWtlIHRvIHRoZVxuICogcHJvdmlkZWQgb2JqZWN0cyBhZmZlY3RzIGBkZWNyeXB0KClgJ3MgcHJvY2Vzc2luZy5cbiAqXG4gKiBAcGFyYW0ge0pXSy5LZXl8SldLLktleVN0b3JlfSBrcyBUaGUgS2V5IG9yIEtleVN0b3JlIHRvIHVzZSBmb3IgZGVjcnlwdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgRGVjcnlwdGVyLlxuICogQHJldHVybnMge0pXRS5EZWNyeXB0ZXJ9IFRoZSBuZXcgRGVjcnlwdGVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWNyeXB0KGtzLCBvcHRzKSB7XG4gIHZhciBkZWMgPSBuZXcgSldFRGVjcnlwdGVyKGtzLCBvcHRzKTtcbiAgcmV0dXJuIGRlYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY3J5cHRlcjogSldFRGVjcnlwdGVyLFxuICBjcmVhdGVEZWNyeXB0OiBjcmVhdGVEZWNyeXB0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/defaults.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/defaults.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/*!\n * jwe/defaults.js - Defaults for JWEs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\n/**\n * @description\n * The default options for {@link JWE.createEncrypt}.\n *\n * @property {Boolean|String} zip Determines the compression algorithm to\n *           apply to the plaintext (if any) before it is encrypted. This can\n *           also be `true` (which is equivalent to `\"DEF\"`) or **`false`**\n *           (the default, which is equivalent to no compression).\n * @property {String} format Determines the serialization format of the\n *           output.  Expected to be `\"general\"` for general JSON\n *           Serialization, `\"flattened\"` for flattened JSON Serialization,\n *           or `\"compact\"` for Compact Serialization (default is\n *           **`\"general\"`**).\n * @property {Boolean} compact Determines if the output is the Compact\n *           serialization (`true`) or the JSON serialization (**`false`**,\n *           the default).\n * @property {String} contentAlg The algorithm used to encrypt the plaintext\n *           (default is **`\"A128CBC-HS256\"`**).\n * @property {String|String[]} protect The names of the headers to integrity\n *           protect.  The value `\"\"` means that none of the header parameters\n *           are integrity protected, while `\"*\"` (the default) means that all\n *           header parameters are integrity protected.\n */\nvar JWEDefaults = {\n  zip: false,\n  format: \"general\",\n  contentAlg: \"A128CBC-HS256\",\n  protect: \"*\"\n};\n\nmodule.exports = JWEDefaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVmYXVsdHMuanM/ODExOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ZS9kZWZhdWx0cy5qcyAtIERlZmF1bHRzIGZvciBKV0VzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciB7QGxpbmsgSldFLmNyZWF0ZUVuY3J5cHR9LlxuICpcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxTdHJpbmd9IHppcCBEZXRlcm1pbmVzIHRoZSBjb21wcmVzc2lvbiBhbGdvcml0aG0gdG9cbiAqICAgICAgICAgICBhcHBseSB0byB0aGUgcGxhaW50ZXh0IChpZiBhbnkpIGJlZm9yZSBpdCBpcyBlbmNyeXB0ZWQuIFRoaXMgY2FuXG4gKiAgICAgICAgICAgYWxzbyBiZSBgdHJ1ZWAgKHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gYFwiREVGXCJgKSBvciAqKmBmYWxzZWAqKlxuICogICAgICAgICAgICh0aGUgZGVmYXVsdCwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byBubyBjb21wcmVzc2lvbikuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZm9ybWF0IERldGVybWluZXMgdGhlIHNlcmlhbGl6YXRpb24gZm9ybWF0IG9mIHRoZVxuICogICAgICAgICAgIG91dHB1dC4gIEV4cGVjdGVkIHRvIGJlIGBcImdlbmVyYWxcImAgZm9yIGdlbmVyYWwgSlNPTlxuICogICAgICAgICAgIFNlcmlhbGl6YXRpb24sIGBcImZsYXR0ZW5lZFwiYCBmb3IgZmxhdHRlbmVkIEpTT04gU2VyaWFsaXphdGlvbixcbiAqICAgICAgICAgICBvciBgXCJjb21wYWN0XCJgIGZvciBDb21wYWN0IFNlcmlhbGl6YXRpb24gKGRlZmF1bHQgaXNcbiAqICAgICAgICAgICAqKmBcImdlbmVyYWxcImAqKikuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbXBhY3QgRGV0ZXJtaW5lcyBpZiB0aGUgb3V0cHV0IGlzIHRoZSBDb21wYWN0XG4gKiAgICAgICAgICAgc2VyaWFsaXphdGlvbiAoYHRydWVgKSBvciB0aGUgSlNPTiBzZXJpYWxpemF0aW9uICgqKmBmYWxzZWAqKixcbiAqICAgICAgICAgICB0aGUgZGVmYXVsdCkuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gY29udGVudEFsZyBUaGUgYWxnb3JpdGhtIHVzZWQgdG8gZW5jcnlwdCB0aGUgcGxhaW50ZXh0XG4gKiAgICAgICAgICAgKGRlZmF1bHQgaXMgKipgXCJBMTI4Q0JDLUhTMjU2XCJgKiopLlxuICogQHByb3BlcnR5IHtTdHJpbmd8U3RyaW5nW119IHByb3RlY3QgVGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzIHRvIGludGVncml0eVxuICogICAgICAgICAgIHByb3RlY3QuICBUaGUgdmFsdWUgYFwiXCJgIG1lYW5zIHRoYXQgbm9uZSBvZiB0aGUgaGVhZGVyIHBhcmFtZXRlcnNcbiAqICAgICAgICAgICBhcmUgaW50ZWdyaXR5IHByb3RlY3RlZCwgd2hpbGUgYFwiKlwiYCAodGhlIGRlZmF1bHQpIG1lYW5zIHRoYXQgYWxsXG4gKiAgICAgICAgICAgaGVhZGVyIHBhcmFtZXRlcnMgYXJlIGludGVncml0eSBwcm90ZWN0ZWQuXG4gKi9cbnZhciBKV0VEZWZhdWx0cyA9IHtcbiAgemlwOiBmYWxzZSxcbiAgZm9ybWF0OiBcImdlbmVyYWxcIixcbiAgY29udGVudEFsZzogXCJBMTI4Q0JDLUhTMjU2XCIsXG4gIHByb3RlY3Q6IFwiKlwiXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpXRURlZmF1bHRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/encrypt.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    generateCEK = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\").generateCEK),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    slice = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\").slice),\n    pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ../algorithms/constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\");\n\nvar assign = __webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\");\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar DEFAULTS = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/node-jose/lib/jwe/defaults.js\");\n\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n    format = cfg.format || \"general\",\n    protectAll = !!cfg.protectAll,\n    content = Buffer.alloc(0);\n\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n  Object.defineProperty(this, \"zip\", {\n    get: function() {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n  Object.defineProperty(this, \"compact\", {\n    get: function() { return \"compact\" === format; },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n  Object.defineProperty(this, \"format\", {\n    get: function() { return format; },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n  Object.defineProperty(this, \"protected\", {\n    get: function() {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n  Object.defineProperty(this, \"header\", {\n    get: function() {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise = Promise.resolve({});\n\n      // determine CEK and IV\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function(jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n        return jwe;\n      });\n\n      // process recipients\n      promise = promise.then(function(jwe) {\n        var procR = function(r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n\n          var algKey = r.key,\n              algAlg = props.alg;\n\n          // generate Ephemeral EC Key\n          var tks,\n              rpromise;\n          if ((props.alg || \"\").indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          }\n\n          // encrypt the CEK\n          rpromise = rpromise.then(function() {\n            var cek,\n                p;\n            // special case 'alg=dir'\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function(jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n                encKey = generateCEK(encAlg);\n              }\n              p = encKey.then(function(jwk) {\n                cek = jwk.get(\"k\", true);\n                // algKey may or may not be a promise\n                return algKey;\n              });\n              p = p.then(function(algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n            return p;\n          });\n          rpromise = rpromise.then(function(wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {},\n                                     wrapped.header);\n            }\n\n            return rjwe;\n           });\n           return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function(rcpts) {\n          var single = (1 === rcpts.length);\n          rcpts = rcpts.map(function(r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function(rcpts) {\n          jwe.recipients = rcpts.filter(function(r) { return !!r; });\n          return jwe;\n        });\n        return p;\n      });\n\n      // normalize headers\n      var props = {};\n      promise = promise.then(function(jwe) {\n        var protect,\n          lenProtect,\n          unprotect,\n          lenUnprotect;\n\n        unprotect = clone(fields);\n        if ((protectAll && jwe.recipients.length === 1) || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = {};\n          protect = assign({},\n                     unprotect,\n                    jwe.recipients[0].header);\n          lenProtect = Object.keys(protect).length;\n\n          unprotect = undefined;\n          lenUnprotect = 0;\n\n          delete jwe.recipients[0].header;\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function(f) {\n            // remove protected header values from body unprotected header\n            if (!(f in unprotect)) {\n              return;\n            }\n            protect[f] = unprotect[f];\n            lenProtect++;\n\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n\n          jwe.recipients = (jwe.recipients || []).map(function(rcpt) {\n            rcpt = rcpt || {};\n            var header = rcpt.header;\n            if (header) {\n              Object.keys(header).forEach(function (f) {\n                if (f in protect) { delete header[f]; }\n              });\n              if (!Object.keys(header).length) {\n                delete rcpt.header;\n              }\n            }\n            return rcpt;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        }\n\n        // \"serialize\" (and setup merged props)\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      });\n\n      // (OPTIONAL) compress plaintext\n      promise = promise.then(function(jwe) {\n        var pdata = content;\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function(resolve, reject) {\n            try {\n              var data = pako.deflateRaw(Buffer.from(pdata, \"binary\"));\n\n              jwe.plaintext = Buffer.from(data);\n              resolve(jwe);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        }\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      });\n\n      // encrypt plaintext\n      promise = promise.then(function(jwe) {\n        props.adata = jwe.protected;\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = Buffer.from(props.adata, \"utf8\");\n        }\n        // calculate IV\n        var iv = cfg.iv ||\n                 util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function(encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function(result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n            if (\"aad\" in cfg && cfg.aad != null) {\n             jwe.aad = cfg.aad;\n            }\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      });\n\n      // (OPTIONAL) compact/flattened results\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jwe) {\n            var compact = new Array(5);\n\n            compact[0] = jwe.protected;\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n            [\"header\", \"encrypted_key\"].forEach(function(f) {\n              if (!rcpt) { return; }\n              if (!(f in rcpt)) { return; }\n              if (!rcpt[f]) { return; }\n              if (\"object\" === typeof rcpt[f] && !Object.keys(rcpt[f]).length) { return; }\n              flattened[f] = rcpt[f];\n            });\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n\n            return flattened;\n          });\n          break;\n        case \"general\":\n          promise = promise.then(function(jwe) {\n            var recipients = jwe.recipients || [];\n            recipients = recipients.map(function (rcpt) {\n              if (!Object.keys(rcpt).length) { return undefined; }\n              return rcpt;\n            });\n            recipients = recipients.filter(function (rcpt) { return !!rcpt; });\n            if (recipients.length) {\n              jwe.recipients = recipients;\n            } else {\n              delete jwe.recipients;\n            }\n\n            return jwe;\n          });\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n    rcptStart = 1,\n    rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n        (opts && \"kty\" in opts) ||\n        (opts && \"key\" in opts &&\n        (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  }\n\n  // fixup options\n  options = assign(clone(DEFAULTS), options);\n\n  // setup header fields\n  var fields = clone(options.fields || {});\n  if (options.zip) {\n    fields.zip = (typeof options.zip === \"boolean\") ?\n           (options.zip ? \"DEF\" : false) :\n           options.zip;\n  }\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n      /* eslint no-fallthrough: [0] */\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n      break;\n  }\n\n  // note protected fields (globally)\n  // protected fields are global only\n  var protectAll = false;\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function(r, idx) {\n    var p;\n\n    // resolve a key\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function(k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    }\n\n    // convert ephemeral key (if present)\n    if (r.epk) {\n      p = p.then(function(recipient) {\n        return JWK.asKey(r.epk).\n          then(function(epk) {\n            recipient.epk = epk;\n            return recipient;\n          });\n      });\n    }\n\n    // resolve the complete recipient\n    p = p.then(function(recipient) {\n      var key = recipient.key;\n\n      // prepare the recipient header\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header);\n\n      // ensure key protection algorithm is set\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n        header.alg = props.alg;\n      }\n      if (!props.alg) {\n        return Promise.reject(new Error(\"key not valid for encrypting to recipient \" + idx));\n      }\n      header.alg = props.alg;\n\n      // determine the key reference\n      var ref = recipient.reference;\n      delete recipient.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // freeze recipient\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n\n    return p;\n  });\n\n  // create and configure encryption\n  var cfg = {\n    aad: (\"aad\" in options) ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZW5jcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGlFQUFTO0FBQzVCLGtCQUFrQix1R0FBZ0M7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLCtEQUFRO0FBQzFCLFlBQVksaUdBQTBCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxnREFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBeUI7O0FBRWpELGFBQWEsbUJBQU8sQ0FBQyw0REFBZTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHNFQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNLGNBQWMsVUFBVSx3QkFBd0IsTUFBTTtBQUNyRSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZSxlQUFlO0FBQzlCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixpRkFBaUY7QUFDakY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxhQUFhO0FBQ2IsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandlL2VuY3J5cHQuanM/MGEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ZS9lbmNyeXB0LmpzIC0gRW5jcnlwdCB0byBhIEpXRVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIGdlbmVyYXRlQ0VLID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKS5nZW5lcmF0ZUNFSyxcbiAgICBKV0sgPSByZXF1aXJlKFwiLi4vandrXCIpLFxuICAgIHNsaWNlID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKS5zbGljZSxcbiAgICBwYWtvID0gcmVxdWlyZShcInBha29cIiksXG4gICAgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXMvY29uc3RhbnRzXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIik7XG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpO1xudmFyIERFRkFVTFRTID0gcmVxdWlyZShcIi4vZGVmYXVsdHNcIik7XG5cbi8qKlxuICogQGNsYXNzIEpXRS5FbmNyeXB0ZXJcbiAqIEBjbGFzc2Rlc2NcbiAqIEdlbmVyYXRvciBvZiBlbmNyeXB0ZWQgZGF0YS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiBUaGlzIGNsYXNzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQgY2FsbCB7QGxpbmtcbiAqIEpXRS5jcmVhdGVFbmNyeXB0fS5cbiAqL1xuZnVuY3Rpb24gSldFRW5jcnlwdGVyKGNmZywgZmllbGRzLCByZWNpcGllbnRzKSB7XG4gIHZhciBmaW5hbGl6ZWQgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSBjZmcuZm9ybWF0IHx8IFwiZ2VuZXJhbFwiLFxuICAgIHByb3RlY3RBbGwgPSAhIWNmZy5wcm90ZWN0QWxsLFxuICAgIGNvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ30gSldFLkVuY3J5cHRlciN6aXBcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJbmRpY2F0ZXMgdGhlIGNvbXByZXNzaW9uIGFsZ29yaXRobSBhcHBsaWVkIHRvIHRoZSBwbGFpbnRleHRcbiAgICogYmVmb3JlIGl0IGlzIGVuY3J5cHRlZC4gIFRoZSBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgKlxuICAgKiArICoqYFwiREVGXCJgKio6IENvbXByZXNzIHRoZSBwbGFpbnRleHQgdXNpbmcgdGhlIERFRkxBVEUgYWxnb3JpdGhtLlxuICAgKiArICoqYFwiXCJgKio6IERvIG5vdCBjb21wcmVzcyB0aGUgcGxhaW50ZXh0LlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiemlwXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZpZWxkcy56aXAgfHwgXCJcIjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtCb29sZWFufSBKV0UuRW5jcnlwdGVyI2NvbXBhY3RcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgb3V0cHV0IG9mIHRoaXMgZW5jcnlwdGlvbiBnZW5lcmF0b3IgaXNcbiAgICogdXNpbmcgdGhlIENvbXBhY3Qgc2VyaWFsaXphdGlvbiAoYHRydWVgKSBvciB0aGUgSlNPTlxuICAgKiBzZXJpYWxpemF0aW9uIChgZmFsc2VgKS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbXBhY3RcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBcImNvbXBhY3RcIiA9PT0gZm9ybWF0OyB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEpXRS5FbmNyeXB0ZXIjZm9ybWF0XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSW5kaWNhdGVzIHRoZSBmb3JtYXQgdGhlIG91dHB1dCBvZiB0aGlzIGVuY3J5cHRpb24gZ2VuZXJhdG9yIHRha2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9ybWF0OyB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmdbXX0gSldFLkVuY3J5cHRlciNwcm90ZWN0ZWRcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgaGVhZGVyIHBhcmFtZXRlciBuYW1lcyB0aGF0IGFyZSBwcm90ZWN0ZWQuIFByb3RlY3RlZCBoZWFkZXIgZmllbGRzXG4gICAqIGFyZSBmaXJzdCBzZXJpYWxpemVkIHRvIFVURi04IHRoZW4gZW5jb2RlZCBhcyB1dGlsLmJhc2U2NHVybCwgdGhlbiB1c2VkIGFzXG4gICAqIHRoZSBhZGRpdGlvbmFsIGF1dGhlbnRpY2F0ZWQgZGF0YSBpbiB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm90ZWN0ZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2xvbmUoY2ZnLnByb3RlY3QpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge09iamVjdH0gSldFLkVuY3J5cHRlciNoZWFkZXJcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgZ2xvYmFsIGhlYWRlciBwYXJhbWV0ZXJzLCBib3RoIHByb3RlY3RlZCBhbmQgdW5wcm90ZWN0ZWQuIENhbGxcbiAgICoge0BsaW5rIEpXRS5FbmNyeXB0ZXIjcHJvdGVjdGVkfSB0byBkZXRlcm1pbmUgd2hpY2ggcGFyYW1ldGVycyB3aWxsXG4gICAqIGJlIHByb3RlY3RlZC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlYWRlclwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjbG9uZShmaWVsZHMpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0UuRW5jcnlwdGVyI3VwZGF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVXBkYXRlcyB0aGUgcGxhaW50ZXh0IGRhdGEgZm9yIHRoZSBlbmNyeXB0aW9uIGdlbmVyYXRvci4gVGhlIHBsYWludGV4dFxuICAgKiBpcyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIGFueSBvdGhlciBwbGFpbnRleHQgYWxyZWFkeSBhcHBsaWVkLlxuICAgKlxuICAgKiBJZiB7ZGF0YX0gaXMgYSBCdWZmZXIsIHtlbmNvZGluZ30gaXMgaWdub3JlZC4gT3RoZXJ3aXNlLCB7ZGF0YX0gaXNcbiAgICogY29udmVydGVkIHRvIGEgQnVmZmVyIGludGVybmFsbHkgdG8ge2VuY29kaW5nfS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBbZGF0YV0gVGhlIHBsYWludGV4dCB0byBhcHBseS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZ10gVGhlIGVuY29kaW5nIG9mIHRoZSBwbGFpbnRleHQuXG4gICAqIEByZXR1cm5zIHtKV0UuRW5jcnlwdGVyfSBUaGlzIGVuY3J5cHRpb24gZ2VuZXJhdG9yLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgY2lwaGVydGV4dCBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVwZGF0ZVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICBpZiAoZmluYWxpemVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGRhdGEgPSB1dGlsLmFzQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGVudCA9IEJ1ZmZlci5jb25jYXQoW2NvbnRlbnQsIGRhdGFdLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQubGVuZ3RoICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXRS5FbmNyeXB0ZXIjZmluYWxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEZpbmlzaGVzIHRoZSBlbmNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCBpcyB0aGUgSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgKiBvYmplY3QsIGVpdGhlciBpbiB0aGUgQ29tcGFjdCAoaWYge0BsaW5rIEpXRS5FbmNyeXB0ZXIjY29tcGFjdH0gaXNcbiAgICogYHRydWVgKSBvciB0aGUgSlNPTiBzZXJpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IFtkYXRhXSBUaGUgZmluYWwgcGxhaW50ZXh0IGRhdGEgdG8gYXBwbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2RpbmddIFRoZSBlbmNvZGluZyBvZiB0aGUgZmluYWwgcGxhaW50ZXh0IGRhdGFcbiAgICogICAgICAgIChpZiBhbnkpLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIGZvciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjaXBoZXJ0ZXh0IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluYWxcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgaWYgKGZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbFwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3QtbWludXRlIGRhdGFcbiAgICAgIHRoaXMudXBkYXRlKGRhdGEsIGVuY29kaW5nKTtcblxuICAgICAgLy8gbWFyayBhcyBkb25lLi4uaXNoXG4gICAgICBmaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoe30pO1xuXG4gICAgICAvLyBkZXRlcm1pbmUgQ0VLIGFuZCBJVlxuICAgICAgdmFyIGVuY0FsZyA9IGZpZWxkcy5lbmM7XG4gICAgICB2YXIgZW5jS2V5O1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgaWYgKGNmZy5jZWspIHtcbiAgICAgICAgICBlbmNLZXkgPSBKV0suYXNLZXkoY2ZnLmNlayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwcm9jZXNzIHJlY2lwaWVudHNcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHZhciBwcm9jUiA9IGZ1bmN0aW9uKHIsIG9uZSkge1xuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgIHByb3BzID0gYXNzaWduKHByb3BzLCBmaWVsZHMpO1xuICAgICAgICAgIHByb3BzID0gYXNzaWduKHByb3BzLCByLmhlYWRlcik7XG5cbiAgICAgICAgICB2YXIgYWxnS2V5ID0gci5rZXksXG4gICAgICAgICAgICAgIGFsZ0FsZyA9IHByb3BzLmFsZztcblxuICAgICAgICAgIC8vIGdlbmVyYXRlIEVwaGVtZXJhbCBFQyBLZXlcbiAgICAgICAgICB2YXIgdGtzLFxuICAgICAgICAgICAgICBycHJvbWlzZTtcbiAgICAgICAgICBpZiAoKHByb3BzLmFsZyB8fCBcIlwiKS5pbmRleE9mKFwiRUNESC1FU1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgdGtzID0gYWxnS2V5LmtleXN0b3JlLnRlbXAoKTtcbiAgICAgICAgICAgIGlmIChyLmVwaykge1xuICAgICAgICAgICAgICBycHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyLmVwaykuXG4gICAgICAgICAgICAgICAgdGhlbihmdW5jdGlvbihlcGspIHtcbiAgICAgICAgICAgICAgICAgIHIuaGVhZGVyLmVwayA9IGVway50b0pTT04oZmFsc2UsIFtcImtpZFwiXSk7XG4gICAgICAgICAgICAgICAgICBwcm9wcy5lcGsgPSBlcGsudG9PYmplY3QodHJ1ZSwgW1wia2lkXCJdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJwcm9taXNlID0gdGtzLmdlbmVyYXRlKFwiRUNcIiwgYWxnS2V5LmdldChcImNydlwiKSkuXG4gICAgICAgICAgICAgICAgdGhlbihmdW5jdGlvbihlcGspIHtcbiAgICAgICAgICAgICAgICAgIHIuaGVhZGVyLmVwayA9IGVway50b0pTT04oZmFsc2UsIFtcImtpZFwiXSk7XG4gICAgICAgICAgICAgICAgICBwcm9wcy5lcGsgPSBlcGsudG9PYmplY3QodHJ1ZSwgW1wia2lkXCJdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlbmNyeXB0IHRoZSBDRUtcbiAgICAgICAgICBycHJvbWlzZSA9IHJwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2VrLFxuICAgICAgICAgICAgICAgIHA7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgJ2FsZz1kaXInXG4gICAgICAgICAgICBpZiAoXCJkaXJcIiA9PT0gYWxnQWxnICYmIG9uZSkge1xuICAgICAgICAgICAgICBlbmNLZXkgPSBQcm9taXNlLnJlc29sdmUoYWxnS2V5KTtcbiAgICAgICAgICAgICAgcCA9IGVuY0tleS50aGVuKGZ1bmN0aW9uKGp3aykge1xuICAgICAgICAgICAgICAgIC8vIGZpeHVwIGVuY0FsZ1xuICAgICAgICAgICAgICAgIGlmICghZW5jQWxnKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wcy5lbmMgPSBmaWVsZHMuZW5jID0gZW5jQWxnID0gandrLmFsZ29yaXRobXMoSldLLk1PREVfRU5DUllQVClbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgZGlyZWN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWVuY0tleSkge1xuICAgICAgICAgICAgICAgIGlmICghZW5jQWxnKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wcy5lbmMgPSBmaWVsZHMuZW5jID0gZW5jQWxnID0gY2ZnLmNvbnRlbnRBbGc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuY0tleSA9IGdlbmVyYXRlQ0VLKGVuY0FsZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcCA9IGVuY0tleS50aGVuKGZ1bmN0aW9uKGp3aykge1xuICAgICAgICAgICAgICAgIGNlayA9IGp3ay5nZXQoXCJrXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGFsZ0tleSBtYXkgb3IgbWF5IG5vdCBiZSBhIHByb21pc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxnS2V5O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihhbGdLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxnS2V5LndyYXAoYWxnQWxnLCBjZWssIHByb3BzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBycHJvbWlzZSA9IHJwcm9taXNlLnRoZW4oZnVuY3Rpb24od3JhcHBlZCkge1xuICAgICAgICAgICAgaWYgKHdyYXBwZWQub25jZSAmJiAhb25lKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3QgdXNlICdhbGcnOidcIiArIGFsZ0FsZyArIFwiJyB3aXRoIG11bHRpcGxlIHJlY2lwaWVudHNcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmp3ZSA9IHt9LFxuICAgICAgICAgICAgICAgIGNlaztcbiAgICAgICAgICAgIGlmICh3cmFwcGVkLmRhdGEpIHtcbiAgICAgICAgICAgICAgY2VrID0gd3JhcHBlZC5kYXRhO1xuICAgICAgICAgICAgICBjZWsgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUoY2VrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdyYXBwZWQuZGlyZWN0ICYmIGNlaykge1xuICAgICAgICAgICAgICAvLyByZXBsYWNlIGNvbnRlbnQga2V5XG4gICAgICAgICAgICAgIGVuY0tleSA9IEpXSy5hc0tleSh7XG4gICAgICAgICAgICAgICAga3R5OiBcIm9jdFwiLFxuICAgICAgICAgICAgICAgIGs6IGNla1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VrKSB7XG4gICAgICAgICAgICAgIC8qIGVzbGludCBjYW1lbGNhc2U6IFswXSAqL1xuICAgICAgICAgICAgICByandlLmVuY3J5cHRlZF9rZXkgPSBjZWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyLmhlYWRlciAmJiBPYmplY3Qua2V5cyhyLmhlYWRlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJqd2UuaGVhZGVyID0gY2xvbmUoci5oZWFkZXIgfHwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdyYXBwZWQuaGVhZGVyKSB7XG4gICAgICAgICAgICAgIHJqd2UuaGVhZGVyID0gYXNzaWduKHJqd2UuaGVhZGVyIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZWQuaGVhZGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJqd2U7XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICByZXR1cm4gcnByb21pc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHAgPSBQcm9taXNlLmFsbChyZWNpcGllbnRzKTtcbiAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihyY3B0cykge1xuICAgICAgICAgIHZhciBzaW5nbGUgPSAoMSA9PT0gcmNwdHMubGVuZ3RoKTtcbiAgICAgICAgICByY3B0cyA9IHJjcHRzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvY1Iociwgc2luZ2xlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmNwdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihyY3B0cykge1xuICAgICAgICAgIGp3ZS5yZWNpcGllbnRzID0gcmNwdHMuZmlsdGVyKGZ1bmN0aW9uKHIpIHsgcmV0dXJuICEhcjsgfSk7XG4gICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBoZWFkZXJzXG4gICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHZhciBwcm90ZWN0LFxuICAgICAgICAgIGxlblByb3RlY3QsXG4gICAgICAgICAgdW5wcm90ZWN0LFxuICAgICAgICAgIGxlblVucHJvdGVjdDtcblxuICAgICAgICB1bnByb3RlY3QgPSBjbG9uZShmaWVsZHMpO1xuICAgICAgICBpZiAoKHByb3RlY3RBbGwgJiYgandlLnJlY2lwaWVudHMubGVuZ3RoID09PSAxKSB8fCBcImNvbXBhY3RcIiA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgLy8gbWVyZ2Ugc2luZ2xlIHJlY2lwaWVudCBpbnRvIGZpZWxkc1xuICAgICAgICAgIHByb3RlY3QgPSB7fTtcbiAgICAgICAgICBwcm90ZWN0ID0gYXNzaWduKHt9LFxuICAgICAgICAgICAgICAgICAgICAgdW5wcm90ZWN0LFxuICAgICAgICAgICAgICAgICAgICBqd2UucmVjaXBpZW50c1swXS5oZWFkZXIpO1xuICAgICAgICAgIGxlblByb3RlY3QgPSBPYmplY3Qua2V5cyhwcm90ZWN0KS5sZW5ndGg7XG5cbiAgICAgICAgICB1bnByb3RlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbGVuVW5wcm90ZWN0ID0gMDtcblxuICAgICAgICAgIGRlbGV0ZSBqd2UucmVjaXBpZW50c1swXS5oZWFkZXI7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGp3ZS5yZWNpcGllbnRzWzBdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGp3ZS5yZWNpcGllbnRzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdGVjdCA9IHt9O1xuICAgICAgICAgIGxlblByb3RlY3QgPSAwO1xuICAgICAgICAgIGxlblVucHJvdGVjdCA9IE9iamVjdC5rZXlzKHVucHJvdGVjdCkubGVuZ3RoO1xuICAgICAgICAgIGNmZy5wcm90ZWN0LmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHByb3RlY3RlZCBoZWFkZXIgdmFsdWVzIGZyb20gYm9keSB1bnByb3RlY3RlZCBoZWFkZXJcbiAgICAgICAgICAgIGlmICghKGYgaW4gdW5wcm90ZWN0KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm90ZWN0W2ZdID0gdW5wcm90ZWN0W2ZdO1xuICAgICAgICAgICAgbGVuUHJvdGVjdCsrO1xuXG4gICAgICAgICAgICBkZWxldGUgdW5wcm90ZWN0W2ZdO1xuICAgICAgICAgICAgbGVuVW5wcm90ZWN0LS07XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBqd2UucmVjaXBpZW50cyA9IChqd2UucmVjaXBpZW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uKHJjcHQpIHtcbiAgICAgICAgICAgIHJjcHQgPSByY3B0IHx8IHt9O1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IHJjcHQuaGVhZGVyO1xuICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXIpLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZiBpbiBwcm90ZWN0KSB7IGRlbGV0ZSBoZWFkZXJbZl07IH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoaGVhZGVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmNwdC5oZWFkZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByY3B0O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFqd2UucmVjaXBpZW50cyB8fCBqd2UucmVjaXBpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgandlLnJlY2lwaWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBcInNlcmlhbGl6ZVwiIChhbmQgc2V0dXAgbWVyZ2VkIHByb3BzKVxuICAgICAgICBpZiAodW5wcm90ZWN0ICYmIGxlblVucHJvdGVjdCA+IDApIHtcbiAgICAgICAgICBwcm9wcyA9IGFzc2lnbihwcm9wcywgdW5wcm90ZWN0KTtcbiAgICAgICAgICBqd2UudW5wcm90ZWN0ZWQgPSB1bnByb3RlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3RlY3QgJiYgbGVuUHJvdGVjdCA+IDApIHtcbiAgICAgICAgICBwcm9wcyA9IGFzc2lnbihwcm9wcywgcHJvdGVjdCk7XG4gICAgICAgICAgcHJvdGVjdCA9IEpTT04uc3RyaW5naWZ5KHByb3RlY3QpO1xuICAgICAgICAgIGp3ZS5wcm90ZWN0ZWQgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocHJvdGVjdCwgXCJ1dGY4XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyAoT1BUSU9OQUwpIGNvbXByZXNzIHBsYWludGV4dFxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgdmFyIHBkYXRhID0gY29udGVudDtcbiAgICAgICAgaWYgKCFwcm9wcy56aXApIHtcbiAgICAgICAgICBqd2UucGxhaW50ZXh0ID0gcGRhdGE7XG4gICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy56aXAgPT09IFwiREVGXCIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IHBha28uZGVmbGF0ZVJhdyhCdWZmZXIuZnJvbShwZGF0YSwgXCJiaW5hcnlcIikpO1xuXG4gICAgICAgICAgICAgIGp3ZS5wbGFpbnRleHQgPSBCdWZmZXIuZnJvbShkYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShqd2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgJ3ppcCcgbW9kZVwiKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZW5jcnlwdCBwbGFpbnRleHRcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHByb3BzLmFkYXRhID0gandlLnByb3RlY3RlZDtcbiAgICAgICAgaWYgKFwiYWFkXCIgaW4gY2ZnICYmIGNmZy5hYWQgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BzLmFkYXRhICs9IFwiLlwiICsgY2ZnLmFhZDtcbiAgICAgICAgICBwcm9wcy5hZGF0YSA9IEJ1ZmZlci5mcm9tKHByb3BzLmFkYXRhLCBcInV0ZjhcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIElWXG4gICAgICAgIHZhciBpdiA9IGNmZy5pdiB8fFxuICAgICAgICAgICAgICAgICB1dGlsLnJhbmRvbUJ5dGVzKENPTlNUQU5UUy5OT05DRUxFTkdUSFtlbmNBbGddIC8gOCk7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaXYpIHtcbiAgICAgICAgICBpdiA9IHV0aWwuYmFzZTY0dXJsLmRlY29kZShpdik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMuaXYgPSBpdjtcblxuICAgICAgICBpZiAoXCJyZWNpcGllbnRzXCIgaW4gandlICYmIGp3ZS5yZWNpcGllbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHByb3BzLmtkYXRhID0gandlLnJlY2lwaWVudHNbMF0uZW5jcnlwdGVkX2tleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImVwdVwiIGluIGNmZyAmJiBjZmcuZXB1ICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wcy5lcHUgPSBjZmcuZXB1O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiZXB2XCIgaW4gY2ZnICYmIGNmZy5lcHYgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BzLmVwdiA9IGNmZy5lcHY7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGRhdGEgPSBqd2UucGxhaW50ZXh0O1xuICAgICAgICBkZWxldGUgandlLnBsYWludGV4dDtcbiAgICAgICAgcmV0dXJuIGVuY0tleS50aGVuKGZ1bmN0aW9uKGVuY0tleSkge1xuICAgICAgICAgIHZhciBwID0gZW5jS2V5LmVuY3J5cHQoZW5jQWxnLCBwZGF0YSwgcHJvcHMpO1xuICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBqd2UuaXYgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUoaXYsIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgaWYgKFwiYWFkXCIgaW4gY2ZnICYmIGNmZy5hYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgIGp3ZS5hYWQgPSBjZmcuYWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgandlLmNpcGhlcnRleHQgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0LmRhdGEsIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgandlLnRhZyA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHQudGFnLCBcImJpbmFyeVwiKTtcbiAgICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIChPUFRJT05BTCkgY29tcGFjdC9mbGF0dGVuZWQgcmVzdWx0c1xuICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBcImNvbXBhY3RcIjpcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3QgPSBuZXcgQXJyYXkoNSk7XG5cbiAgICAgICAgICAgIGNvbXBhY3RbMF0gPSBqd2UucHJvdGVjdGVkO1xuICAgICAgICAgICAgaWYgKGp3ZS5yZWNpcGllbnRzICYmIGp3ZS5yZWNpcGllbnRzWzBdKSB7XG4gICAgICAgICAgICAgIGNvbXBhY3RbMV0gPSBqd2UucmVjaXBpZW50c1swXS5lbmNyeXB0ZWRfa2V5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21wYWN0WzJdID0gandlLml2O1xuICAgICAgICAgICAgY29tcGFjdFszXSA9IGp3ZS5jaXBoZXJ0ZXh0O1xuICAgICAgICAgICAgY29tcGFjdFs0XSA9IGp3ZS50YWc7XG4gICAgICAgICAgICBjb21wYWN0ID0gY29tcGFjdC5qb2luKFwiLlwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhY3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmbGF0dGVuZWRcIjpcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICAgICAgdmFyIGZsYXR0ZW5lZCA9IHt9LFxuICAgICAgICAgICAgICAgIHJjcHQgPSBqd2UucmVjaXBpZW50cyAmJiBqd2UucmVjaXBpZW50c1swXTtcblxuICAgICAgICAgICAgaWYgKGp3ZS5wcm90ZWN0ZWQpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkLnByb3RlY3RlZCA9IGp3ZS5wcm90ZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoandlLnVucHJvdGVjdGVkKSB7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZC51bnByb3RlY3RlZCA9IGp3ZS51bnByb3RlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImhlYWRlclwiLCBcImVuY3J5cHRlZF9rZXlcIl0uZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgIGlmICghcmNwdCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgaWYgKCEoZiBpbiByY3B0KSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgaWYgKCFyY3B0W2ZdKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJjcHRbZl0gJiYgIU9iamVjdC5rZXlzKHJjcHRbZl0pLmxlbmd0aCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgZmxhdHRlbmVkW2ZdID0gcmNwdFtmXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGp3ZS5hYWQpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkLmFhZCA9IGp3ZS5hYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGF0dGVuZWQuaXYgPSBqd2UuaXY7XG4gICAgICAgICAgICBmbGF0dGVuZWQuY2lwaGVydGV4dCA9IGp3ZS5jaXBoZXJ0ZXh0O1xuICAgICAgICAgICAgZmxhdHRlbmVkLnRhZyA9IGp3ZS50YWc7XG5cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJnZW5lcmFsXCI6XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgICAgIHZhciByZWNpcGllbnRzID0gandlLnJlY2lwaWVudHMgfHwgW107XG4gICAgICAgICAgICByZWNpcGllbnRzID0gcmVjaXBpZW50cy5tYXAoZnVuY3Rpb24gKHJjcHQpIHtcbiAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhyY3B0KS5sZW5ndGgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgICByZXR1cm4gcmNwdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVjaXBpZW50cyA9IHJlY2lwaWVudHMuZmlsdGVyKGZ1bmN0aW9uIChyY3B0KSB7IHJldHVybiAhIXJjcHQ7IH0pO1xuICAgICAgICAgICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGp3ZS5yZWNpcGllbnRzID0gcmVjaXBpZW50cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBqd2UucmVjaXBpZW50cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW5jcnlwdChvcHRzLCByY3B0cykge1xuICAvLyBmaXh1cCByZWNpcGllbnRzXG4gIHZhciBvcHRpb25zID0gb3B0cyxcbiAgICByY3B0U3RhcnQgPSAxLFxuICAgIHJjcHRMaXN0ID0gcmNwdHM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdCBsZWFzdCBvbmUgcmVjaXBpZW50IG11c3QgYmUgcHJvdmlkZWRcIik7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBhc3N1bWUgb3B0cyBpcyB0aGUgcmVjaXBpZW50IGxpc3RcbiAgICByY3B0TGlzdCA9IG9wdHM7XG4gICAgcmNwdFN0YXJ0ID0gMDtcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSBpZiAoSldLLmlzS2V5KG9wdHMpIHx8XG4gICAgICAgIChvcHRzICYmIFwia3R5XCIgaW4gb3B0cykgfHxcbiAgICAgICAgKG9wdHMgJiYgXCJrZXlcIiBpbiBvcHRzICYmXG4gICAgICAgIChKV0suaXNLZXkob3B0cy5rZXkpIHx8IFwia3R5XCIgaW4gb3B0cy5rZXkpKSkge1xuICAgIHJjcHRMaXN0ID0gb3B0cztcbiAgICByY3B0U3RhcnQgPSAwO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gY2xvbmUob3B0cyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJjcHRMaXN0KSkge1xuICAgIHJjcHRMaXN0ID0gc2xpY2UoYXJndW1lbnRzLCByY3B0U3RhcnQpO1xuICB9XG5cbiAgLy8gZml4dXAgb3B0aW9uc1xuICBvcHRpb25zID0gYXNzaWduKGNsb25lKERFRkFVTFRTKSwgb3B0aW9ucyk7XG5cbiAgLy8gc2V0dXAgaGVhZGVyIGZpZWxkc1xuICB2YXIgZmllbGRzID0gY2xvbmUob3B0aW9ucy5maWVsZHMgfHwge30pO1xuICBpZiAob3B0aW9ucy56aXApIHtcbiAgICBmaWVsZHMuemlwID0gKHR5cGVvZiBvcHRpb25zLnppcCA9PT0gXCJib29sZWFuXCIpID9cbiAgICAgICAgICAgKG9wdGlvbnMuemlwID8gXCJERUZcIiA6IGZhbHNlKSA6XG4gICAgICAgICAgIG9wdGlvbnMuemlwO1xuICB9XG4gIG9wdGlvbnMuZm9ybWF0ID0gKG9wdGlvbnMuY29tcGFjdCA/IFwiY29tcGFjdFwiIDogb3B0aW9ucy5mb3JtYXQpIHx8IFwiZ2VuZXJhbFwiO1xuICBzd2l0Y2ggKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgY2FzZSBcImNvbXBhY3RcIjpcbiAgICAgIGlmIChcImFhZFwiIGluIG9wdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkaXRpb25hbCBhdXRoZW50aWNhdGVkIGRhdGEgY2Fubm90IGJlIHVzZWQgZm9yIGNvbXBhY3Qgc2VyaWFsaXphdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogWzBdICovXG4gICAgY2FzZSBcImZsYXR0ZW5lZFwiOlxuICAgICAgaWYgKHJjcHRMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidG9vIG1hbnkgcmVjaXBpZW50cyBmb3IgY29tcGFjdCBzZXJpYWxpemF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBub3RlIHByb3RlY3RlZCBmaWVsZHMgKGdsb2JhbGx5KVxuICAvLyBwcm90ZWN0ZWQgZmllbGRzIGFyZSBnbG9iYWwgb25seVxuICB2YXIgcHJvdGVjdEFsbCA9IGZhbHNlO1xuICBpZiAoXCJjb21wYWN0XCIgPT09IG9wdGlvbnMuZm9ybWF0IHx8IFwiKlwiID09PSBvcHRpb25zLnByb3RlY3QpIHtcbiAgICBwcm90ZWN0QWxsID0gdHJ1ZTtcbiAgICBvcHRpb25zLnByb3RlY3QgPSBPYmplY3Qua2V5cyhmaWVsZHMpLmNvbmNhdChcImVuY1wiKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wcm90ZWN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgb3B0aW9ucy5wcm90ZWN0ID0gW29wdGlvbnMucHJvdGVjdF07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnByb3RlY3QpKSB7XG4gICAgb3B0aW9ucy5wcm90ZWN0ID0gb3B0aW9ucy5wcm90ZWN0LmNvbmNhdCgpO1xuICB9IGVsc2UgaWYgKCFvcHRpb25zLnByb3RlY3QpIHtcbiAgICBvcHRpb25zLnByb3RlY3QgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm90ZWN0IG11c3QgYmUgYSBsaXN0IG9mIGZpZWxkc1wiKTtcbiAgfVxuXG4gIGlmIChwcm90ZWN0QWxsICYmIDEgPCByY3B0TGlzdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSByZWNpcGllbnRzIHRvIHByb3RlY3QgYWxsIGhlYWRlciBwYXJhbWV0ZXJzXCIpO1xuICB9XG5cbiAgcmNwdExpc3QgPSByY3B0TGlzdC5tYXAoZnVuY3Rpb24ociwgaWR4KSB7XG4gICAgdmFyIHA7XG5cbiAgICAvLyByZXNvbHZlIGEga2V5XG4gICAgaWYgKHIgJiYgXCJrdHlcIiBpbiByKSB7XG4gICAgICBwID0gSldLLmFzS2V5KHIpO1xuICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5OiBrXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHIpIHtcbiAgICAgIHAgPSBKV0suYXNLZXkoci5rZXkpO1xuICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhZGVyOiByLmhlYWRlcixcbiAgICAgICAgICByZWZlcmVuY2U6IHIucmVmZXJlbmNlLFxuICAgICAgICAgIGtleToga1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIGtleSBmb3IgcmVjaXBpZW50IFwiICsgaWR4KSk7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBlcGhlbWVyYWwga2V5IChpZiBwcmVzZW50KVxuICAgIGlmIChyLmVwaykge1xuICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihyZWNpcGllbnQpIHtcbiAgICAgICAgcmV0dXJuIEpXSy5hc0tleShyLmVwaykuXG4gICAgICAgICAgdGhlbihmdW5jdGlvbihlcGspIHtcbiAgICAgICAgICAgIHJlY2lwaWVudC5lcGsgPSBlcGs7XG4gICAgICAgICAgICByZXR1cm4gcmVjaXBpZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgY29tcGxldGUgcmVjaXBpZW50XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihyZWNpcGllbnQpIHtcbiAgICAgIHZhciBrZXkgPSByZWNpcGllbnQua2V5O1xuXG4gICAgICAvLyBwcmVwYXJlIHRoZSByZWNpcGllbnQgaGVhZGVyXG4gICAgICB2YXIgaGVhZGVyID0gcmVjaXBpZW50LmhlYWRlciB8fCB7fTtcbiAgICAgIHJlY2lwaWVudC5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgIHByb3BzID0gYXNzaWduKHByb3BzLCBmaWVsZHMpO1xuICAgICAgcHJvcHMgPSBhc3NpZ24ocHJvcHMsIHJlY2lwaWVudC5oZWFkZXIpO1xuXG4gICAgICAvLyBlbnN1cmUga2V5IHByb3RlY3Rpb24gYWxnb3JpdGhtIGlzIHNldFxuICAgICAgaWYgKCFwcm9wcy5hbGcpIHtcbiAgICAgICAgcHJvcHMuYWxnID0ga2V5LmFsZ29yaXRobXMoSldLLk1PREVfV1JBUClbMF07XG4gICAgICAgIGhlYWRlci5hbGcgPSBwcm9wcy5hbGc7XG4gICAgICB9XG4gICAgICBpZiAoIXByb3BzLmFsZykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwia2V5IG5vdCB2YWxpZCBmb3IgZW5jcnlwdGluZyB0byByZWNpcGllbnQgXCIgKyBpZHgpKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlci5hbGcgPSBwcm9wcy5hbGc7XG5cbiAgICAgIC8vIGRldGVybWluZSB0aGUga2V5IHJlZmVyZW5jZVxuICAgICAgdmFyIHJlZiA9IHJlY2lwaWVudC5yZWZlcmVuY2U7XG4gICAgICBkZWxldGUgcmVjaXBpZW50LnJlZmVyZW5jZTtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHJlZikge1xuICAgICAgICAvLyBoZWFkZXIgYWxyZWFkeSBjb250YWlucyB0aGUga2V5IHJlZmVyZW5jZVxuICAgICAgICByZWYgPSBbXCJraWRcIiwgXCJqa3VcIiwgXCJ4NWNcIiwgXCJ4NXRcIiwgXCJ4NXVcIl0uc29tZShmdW5jdGlvbihrKSB7XG4gICAgICAgICAgcmV0dXJuIChrIGluIGhlYWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZWYgPSAhcmVmID8gXCJraWRcIiA6IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKFwiYm9vbGVhblwiID09PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IChwb3NpdGl2ZSB8IG5lZ2F0aXZlKSByZXF1ZXN0IGZvciBrZXkgcmVmZXJlbmNlXG4gICAgICAgIHJlZiA9IHJlZiA/IFwia2lkXCIgOiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGp3aztcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgandrID0ga2V5LnRvSlNPTigpO1xuICAgICAgICBpZiAoXCJqd2tcIiA9PT0gcmVmKSB7XG4gICAgICAgICAgaWYgKFwib2N0XCIgPT09IGtleS5rdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3QgZW1iZWQga2V5XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGVhZGVyLmp3ayA9IGp3aztcbiAgICAgICAgfSBlbHNlIGlmIChyZWYgaW4gandrKSB7XG4gICAgICAgICAgaGVhZGVyW3JlZl0gPSBqd2tbcmVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmcmVlemUgcmVjaXBpZW50XG4gICAgICByZWNpcGllbnQgPSBPYmplY3QuZnJlZXplKHJlY2lwaWVudCk7XG4gICAgICByZXR1cm4gcmVjaXBpZW50O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHA7XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSBhbmQgY29uZmlndXJlIGVuY3J5cHRpb25cbiAgdmFyIGNmZyA9IHtcbiAgICBhYWQ6IChcImFhZFwiIGluIG9wdGlvbnMpID8gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKG9wdGlvbnMuYWFkIHx8IFwiXCIpIDogbnVsbCxcbiAgICBjb250ZW50QWxnOiBvcHRpb25zLmNvbnRlbnRBbGcsXG4gICAgZm9ybWF0OiBvcHRpb25zLmZvcm1hdCxcbiAgICBwcm90ZWN0OiBvcHRpb25zLnByb3RlY3QsXG4gICAgY2VrOiBvcHRpb25zLmNlayxcbiAgICBpdjogb3B0aW9ucy5pdixcbiAgICBwcm90ZWN0QWxsOiBwcm90ZWN0QWxsXG4gIH07XG4gIHZhciBlbmMgPSBuZXcgSldFRW5jcnlwdGVyKGNmZywgZmllbGRzLCByY3B0TGlzdCk7XG5cbiAgcmV0dXJuIGVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuY3J5cHRlcjogSldFRW5jcnlwdGVyLFxuICBjcmVhdGVFbmNyeXB0OiBjcmVhdGVFbmNyeXB0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/helpers.js - JWE Internal Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ../algorithms/constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\");\n\nmodule.exports = {\n  slice: function(input, start) {\n    return Array.prototype.slice.call(input, start || 0);\n  },\n  generateCEK: function(enc) {\n    var ks = JWK.createKeyStore();\n    var len = CONSTANTS.KEYLENGTH[enc];\n\n    if (len) {\n        return ks.generate(\"oct\", len);\n    }\n\n    throw new Error(\"unsupported encryption algorithm\");\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQXlCO0FBQ2pELFVBQVUsbUJBQU8sQ0FBQywrREFBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ZS9oZWxwZXJzLmpzP2Y0MmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2UvaGVscGVycy5qcyAtIEpXRSBJbnRlcm5hbCBIZWxwZXIgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtcy9jb25zdGFudHNcIiksXG4gICAgSldLID0gcmVxdWlyZShcIi4uL2p3a1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNsaWNlOiBmdW5jdGlvbihpbnB1dCwgc3RhcnQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5wdXQsIHN0YXJ0IHx8IDApO1xuICB9LFxuICBnZW5lcmF0ZUNFSzogZnVuY3Rpb24oZW5jKSB7XG4gICAgdmFyIGtzID0gSldLLmNyZWF0ZUtleVN0b3JlKCk7XG4gICAgdmFyIGxlbiA9IENPTlNUQU5UUy5LRVlMRU5HVEhbZW5jXTtcblxuICAgIGlmIChsZW4pIHtcbiAgICAgICAgcmV0dXJuIGtzLmdlbmVyYXRlKFwib2N0XCIsIGxlbik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgZW5jcnlwdGlvbiBhbGdvcml0aG1cIik7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/index.js - JSON Web Encryption (JWE) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWE = {\n  createEncrypt: (__webpack_require__(/*! ./encrypt */ \"(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js\").createEncrypt),\n  createDecrypt: (__webpack_require__(/*! ./decrypt */ \"(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js\").createDecrypt)\n};\n\nmodule.exports = JWE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0EsaUJBQWlCLHlHQUFrQztBQUNuRCxpQkFBaUIseUdBQWtDO0FBQ25EOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ZS9pbmRleC5qcz8yZjM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandlL2luZGV4LmpzIC0gSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKSBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSldFID0ge1xuICBjcmVhdGVFbmNyeXB0OiByZXF1aXJlKFwiLi9lbmNyeXB0XCIpLmNyZWF0ZUVuY3J5cHQsXG4gIGNyZWF0ZURlY3J5cHQ6IHJlcXVpcmUoXCIuL2RlY3J5cHRcIikuY3JlYXRlRGVjcnlwdFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKV0U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/basekey.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/basekey.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/basekey.js - JWK Key Base Class Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\");\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js\");\n\nvar assign = __webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\");\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar flatten = __webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\");\nvar intersection = __webpack_require__(/*! lodash/intersection */ \"(ssr)/./node_modules/lodash/intersection.js\");\nvar omit = __webpack_require__(/*! lodash/omit */ \"(ssr)/./node_modules/lodash/omit.js\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"(ssr)/./node_modules/lodash/pick.js\");\nvar uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\");\n\nvar ALGORITHMS = __webpack_require__(/*! ../algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/constants.js\"),\n    HELPERS = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\"),\n    UTIL = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\n/**\n * @class JWK.Key\n * @classdesc\n * Represents a JSON Web Key instance.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call\n * {@link JWK.asKey}, {@link JWK.KeyStore#add}, or\n * {@link JWK.KeyStore#generate}.\n */\nvar JWKBaseKeyObject = function(kty, ks, props, cfg) {\n  // ### validate/coerce arguments ###\n  if (!kty) {\n    throw new Error(\"kty cannot be null\");\n  }\n\n  if (!ks) {\n    throw new Error(\"keystore cannot be null\");\n  }\n\n  if (!props) {\n    throw new Error(\"props cannot be null\");\n  } else if (\"string\" === typeof props) {\n    props = JSON.parse(props);\n  }\n\n  if (!cfg) {\n    throw new Error(\"cfg cannot be null\");\n  }\n\n  var excluded = [];\n  var keys = {},\n      json = {},\n      prints,\n      kid;\n\n  props = clone(props);\n  // strip thumbprints if present\n  prints = assign({}, props[HELPERS.INTERNALS.THUMBPRINT_KEY] || {});\n  delete props[HELPERS.INTERNALS.THUMBPRINT_KEY];\n  Object.keys(prints).forEach(function(a) {\n    var h = prints[a];\n    if (!kid) {\n      kid = h;\n      if (Buffer.isBuffer(kid)) {\n        kid = UTIL.base64url.encode(kid);\n      }\n    }\n    if (!Buffer.isBuffer(h)) {\n      h = UTIL.base64url.decode(h);\n      prints[a] = h;\n    }\n  });\n\n  // force certain values\n  props.kty = kty;\n  props.kid = props.kid || kid || uuidv4();\n\n  // setup base info\n  var included = Object.keys(HELPERS.COMMON_PROPS).map(function(p) {\n    return HELPERS.COMMON_PROPS[p].name;\n  });\n  json.base = pick(props, included);\n  excluded = excluded.concat(Object.keys(json.base));\n\n  // setup public information\n  json.public = clone(props);\n  keys.public = cfg.publicKey(json.public);\n  if (keys.public) {\n    // exclude public values from extra\n    excluded = excluded.concat(Object.keys(json.public));\n  }\n\n  // setup private information\n  json.private = clone(props);\n  keys.private = cfg.privateKey(json.private);\n  if (keys.private) {\n    // exclude private values from extra\n    excluded = excluded.concat(Object.keys(json.private));\n  }\n\n  // setup extra information\n  json.extra = omit(props, excluded);\n\n  // TODO: validate 'alg' against supported algorithms\n\n  // setup calculated values\n  var keyLen;\n  if (keys.public && (\"length\" in keys.public)) {\n    keyLen = keys.public.length;\n  } else if (keys.private && (\"length\" in keys.private)) {\n    keyLen = keys.private.length;\n  } else {\n    keyLen = NaN;\n  }\n\n  // ### Public Properties ###\n  /**\n   * @member {JWK.KeyStore} JWK.Key#keystore\n   * @description\n   * The owning keystore.\n   */\n  Object.defineProperty(this, \"keystore\", {\n    value: ks,\n    enumerable: true\n  });\n  /**\n   * @member {Number} JWK.Key#length\n   * @description\n   * The size of this Key, in bits.\n   */\n  Object.defineProperty(this, \"length\", {\n    value: keyLen,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kty\n   * @description\n   * The type of Key.\n   */\n  Object.defineProperty(this, \"kty\", {\n    value: kty,\n    enumerable: true\n  });\n\n  /**\n   * @member {String} JWK.Key#kid\n   * @description\n   * The identifier for this Key.\n   */\n  Object.defineProperty(this, \"kid\", {\n    value: json.base.kid,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#use\n   * @description\n   * The usage for this Key.\n   */\n  Object.defineProperty(this, \"use\", {\n    value: json.base.use || \"\",\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#alg\n   * @description\n   * The sole algorithm this key can be used for.\n   */\n  Object.defineProperty(this, \"alg\", {\n    value: json.base.alg || \"\",\n    enumerable: true\n  });\n\n  // ### Public Methods ###\n  /**\n   * Generates the thumbprint of this Key.\n   *\n   * @param {String} [] The hash algorithm to use\n   * @returns {Promise} The promise for the thumbprint generation.\n   */\n  Object.defineProperty(this, \"thumbprint\", {\n    value: function(hash) {\n      hash = (hash || HELPERS.INTERNALS.THUMBPRINT_HASH).toUpperCase();\n      if (prints[hash]) {\n        // return cached value\n        return Promise.resolve(prints[hash]);\n      }\n      var p = HELPERS.thumbprint(cfg, json, hash);\n      p = p.then(function(result) {\n        if (result) {\n          prints[hash] = result;\n        }\n        return result;\n      });\n      return p;\n    }\n  });\n  /**\n   * @method JWK.Key#algorithms\n   * @description\n   * The possible algorithms this Key can be used for. The returned\n   * list is not any particular order, but is filtered based on the\n   * Key's intended usage.\n   *\n   * @param {String} mode The operation mode\n   * @returns {String[]} The list of supported algorithms\n   * @see JWK.Key#supports\n   */\n  Object.defineProperty(this, \"algorithms\", {\n    value: function(mode) {\n      var modes = [];\n      if (!this.use || this.use === \"sig\") {\n        if (!mode || CONSTANTS.MODE_SIGN === mode) {\n          modes.push(CONSTANTS.MODE_SIGN);\n        }\n        if (!mode || CONSTANTS.MODE_VERIFY === mode) {\n          modes.push(CONSTANTS.MODE_VERIFY);\n        }\n      }\n      if (!this.use || this.use === \"enc\") {\n        if (!mode || CONSTANTS.MODE_ENCRYPT === mode) {\n          modes.push(CONSTANTS.MODE_ENCRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_DECRYPT === mode) {\n          modes.push(CONSTANTS.MODE_DECRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_WRAP === mode) {\n          modes.push(CONSTANTS.MODE_WRAP);\n        }\n        if (!mode || CONSTANTS.MODE_UNWRAP === mode) {\n          modes.push(CONSTANTS.MODE_UNWRAP);\n        }\n      }\n\n      var self = this;\n      var algs = modes.map(function(m) {\n        return cfg.algorithms.call(self, keys, m);\n      });\n      algs = flatten(algs);\n      algs = uniq(algs);\n      if (this.alg) {\n        // TODO: fix this correctly\n        var valid;\n        if (\"oct\" === kty) {\n          valid = [this.alg, \"dir\"];\n        } else {\n          valid = [this.alg];\n        }\n        algs = intersection(algs, valid);\n      }\n\n      return algs;\n    }\n  });\n  /**\n   * @method JWK.Key#supports\n   * @description\n   * Determines if the given algorithm is supported.\n   *\n   * @param {String} alg The algorithm in question\n   * @param {String} [mode] The operation mode\n   * @returns {Boolean} `true` if {alg} is supported, and `false` otherwise.\n   * @see JWK.Key#algorithms\n   */\n  Object.defineProperty(this, \"supports\", {\n    value: function(alg, mode) {\n      return (this.algorithms(mode).indexOf(alg) !== -1);\n    }\n  });\n  /**\n   * @method JWK.Key#has\n   * @description\n   * Determines if this Key contains the given parameter.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        checked.\n   * @returns {Boolean} `true` if the given parameter is present; `false`\n   *          otherwise.\n   */\n  Object.defineProperty(this, \"has\", {\n    value: function(name, isPrivate) {\n      var contains = false;\n      contains = contains || !!(json.base &&\n                                (name in json.base));\n      contains = contains || !!(keys.public &&\n                                (name in keys.public));\n      contains = contains || !!(json.extra &&\n                                (name in json.extra));\n      contains = contains || !!(isPrivate &&\n                                keys.private &&\n                                (name in keys.private));\n      // TODO: check for export restrictions\n\n      return contains;\n    }\n  });\n  /**\n   * @method JWK.Key#get\n   * @description\n   * Retrieves the value of the given parameter. The value returned by this\n   * method is in its natural format, which might not exactly match its\n   * JSON encoding (e.g., a binary string rather than a base64url-encoded\n   * string).\n   *\n   * **NOTE:** This method can return `false`. Call\n   * {@link JWK.Key#has} to determine if the parameter is present.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should\n   *        be checked.\n   * @returns {any} The value of the named parameter, or undefined if\n   *          it is not present.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(name, isPrivate) {\n      var src;\n      if (json.base && (name in json.base)) {\n        src = json.base;\n      } else if (keys.public && (name in keys.public)) {\n        src = keys.public;\n      } else if (json.extra && (name in json.extra)) {\n        src = json.extra;\n      } else if (isPrivate && keys.private && (name in keys.private)) {\n        // TODO: check for export restrictions\n        src = keys.private;\n      }\n\n      return src && src[name] || null;\n    }\n  });\n  /**\n   * @method JWK.Key#toJSON\n   * @description\n   * Returns the JSON representation of this Key.  All properties of the\n   * returned JSON object are properly encoded (e.g., base64url encoding for\n   * any binary strings).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned JSON.\n   * @returns {Object} The plain JSON object\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       json.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? json.private : {},\n                       json.extra);\n      result = omit(result, excluded || []);\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#toPEM\n   * @description\n   * Returns the PEM representation of this Key as a string.\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @returns {string} The PEM-encoded string\n   */\n  Object.defineProperty(this, \"toPEM\", {\n    value: function(isPrivate) {\n      if (isPrivate === null) {\n        isPrivate = false;\n      }\n\n      if (!cfg.convertToPEM) {\n        throw new Error(\"Unsupported key type for PEM encoding\");\n      }\n      var k = (isPrivate) ? keys.private : keys.public;\n      if (!k) {\n        throw new Error(\"Invalid key\");\n      }\n      return cfg.convertToPEM.call(this, k, isPrivate);\n    }\n  });\n\n  /**\n   * @method JWK.Key#toObject\n   * @description\n   * Returns the plain object representing this Key.  All properties of the\n   * returned object are in their natural encoding (e.g., binary strings\n   * instead of base64url encoded).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned object.\n   * @returns {Object} The plain Object.\n   */\n  Object.defineProperty(this, \"toObject\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       keys.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? keys.private : {},\n                       json.extra);\n      result = omit(result, (excluded || []).concat(\"length\"));\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#sign\n   * @description\n   * Sign the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive signing operation; the output is\n   * _**NOT**_ a JSON Web Signature (JWS) object.\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was signed (and should be equal to {data}).\n   * + **mac**: The signature or message authentication code (MAC).\n   *\n   * @param {String} alg The signing algorithm\n   * @param {String|Buffer} data The data to sign\n   * @param {Object} [props] Additional properties for the signing\n   *        algorithm.\n   * @returns {Promise} The promise for the signing operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"sign\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"sign\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.signKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.signProps) {\n        props = merge(props, cfg.signProps.call(this, alg, props));\n      }\n      return ALGORITHMS.sign(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#verify\n   * @description\n   * Verify the given data and signature using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive verification operation; the input is\n   * _**NOT**_ a JSON Web Signature.</p>\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was verified (and should be equal to\n   *   {data}).\n   * + **mac**: The signature or MAC that was verified (and should be equal\n   *   to {mac}).\n   * + **valid**: `true` if {mac} is valid for {data}.\n   *\n   * @param {String} alg The verification algorithm\n   * @param {String|Buffer} data The data to verify\n   * @param {String|Buffer} mac The signature or MAC to verify\n   * @param {Object} [props] Additional properties for the verification\n   *        algorithm.\n   * @returns {Promise} The promise for the verification operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"verify\", {\n    value: function(alg, data, mac, props) {\n      // validate appropriateness\n      if (this.algorithms(\"verify\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.verifyKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.verifyProps) {\n        props = merge(props, cfg.verifyProps.call(this, alg, props));\n      }\n      return ALGORITHMS.verify(alg, k, data, mac, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#encrypt\n   * @description\n   * Encrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#wrap}, as different algorithms and properties are often\n   * used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **mac**: The associated message authentication code (MAC).\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"encrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"encrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.encryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.encryptProps) {\n        props = merge(props, cfg.encryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#decrypt\n   * @description\n   * Decrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive decryption operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#unwrap}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the plaintext data.\n   *\n   * @param {String} alg The decryption algorithm.\n   * @param {Buffer|String} data The data to decypt.\n   * @param {Object} [props] Additional data for the decryption operation.\n   * @returns {Promise} The promise for the decryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"decrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.decryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.decryptProps) {\n        props = merge(props, cfg.decryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#wrap\n   * @description\n   * Wraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#encrypt}, as different algorithms and properties are\n   * often used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **headers**: The additional header parameters to apply to a JWE.\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"wrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"wrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.wrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.wrapProps) {\n        props = merge(props, cfg.wrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#unwrap\n   * @description\n   * Unwraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive unwrap operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#decrypt}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the unwrapped key.\n   *\n   * @param {String} alg The unwrap algorithm.\n   * @param {Buffer|String} data The data to unwrap.\n   * @param {Object} [props] Additional data for the unwrap operation.\n   * @returns {Promise} The promise for the unwrap operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"unwrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"unwrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.unwrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.unwrapProps) {\n        props = merge(props, cfg.unwrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n};\n\nmodule.exports = JWKBaseKeyObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svYmFzZWtleS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMscUZBQU07O0FBRXJDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDaEQsV0FBVyxtQkFBTyxDQUFDLHdEQUFhO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyx3REFBYTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFlO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsdUVBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGlFQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLEdBQUcsdUJBQXVCO0FBQzlDLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUyxXQUFXLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxTQUFTLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsS0FBSztBQUN4RTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSyxpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSztBQUNiO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsNkJBQTZCLEtBQUssY0FBYyxLQUFLO0FBQ3JEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTyxJQUFJLEtBQUssaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTyxJQUFJLEtBQUssaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU8sSUFBSSxLQUFLLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU8sSUFBSSxLQUFLLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSyxpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svYmFzZWtleS5qcz9iYWVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL2Jhc2VrZXkuanMgLSBKV0sgS2V5IEJhc2UgQ2xhc3MgSW1wbGVtZW50YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIik7XG5jb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZShcImxvZGFzaC9hc3NpZ25cIik7XG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpO1xudmFyIGZsYXR0ZW4gPSByZXF1aXJlKFwibG9kYXNoL2ZsYXR0ZW5cIik7XG52YXIgaW50ZXJzZWN0aW9uID0gcmVxdWlyZShcImxvZGFzaC9pbnRlcnNlY3Rpb25cIik7XG52YXIgb21pdCA9IHJlcXVpcmUoXCJsb2Rhc2gvb21pdFwiKTtcbnZhciBwaWNrID0gcmVxdWlyZShcImxvZGFzaC9waWNrXCIpO1xudmFyIHVuaXEgPSByZXF1aXJlKFwibG9kYXNoL3VuaXFcIik7XG5cbnZhciBBTEdPUklUSE1TID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXNcIiksXG4gICAgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpLFxuICAgIEhFTFBFUlMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIFVUSUwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxuLyoqXG4gKiBAY2xhc3MgSldLLktleVxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIEpTT04gV2ViIEtleSBpbnN0YW5jZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiBUaGlzIGNsYXNzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQgY2FsbFxuICoge0BsaW5rIEpXSy5hc0tleX0sIHtAbGluayBKV0suS2V5U3RvcmUjYWRkfSwgb3JcbiAqIHtAbGluayBKV0suS2V5U3RvcmUjZ2VuZXJhdGV9LlxuICovXG52YXIgSldLQmFzZUtleU9iamVjdCA9IGZ1bmN0aW9uKGt0eSwga3MsIHByb3BzLCBjZmcpIHtcbiAgLy8gIyMjIHZhbGlkYXRlL2NvZXJjZSBhcmd1bWVudHMgIyMjXG4gIGlmICgha3R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwia3R5IGNhbm5vdCBiZSBudWxsXCIpO1xuICB9XG5cbiAgaWYgKCFrcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImtleXN0b3JlIGNhbm5vdCBiZSBudWxsXCIpO1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByb3BzIGNhbm5vdCBiZSBudWxsXCIpO1xuICB9IGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBwcm9wcykge1xuICAgIHByb3BzID0gSlNPTi5wYXJzZShwcm9wcyk7XG4gIH1cblxuICBpZiAoIWNmZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNmZyBjYW5ub3QgYmUgbnVsbFwiKTtcbiAgfVxuXG4gIHZhciBleGNsdWRlZCA9IFtdO1xuICB2YXIga2V5cyA9IHt9LFxuICAgICAganNvbiA9IHt9LFxuICAgICAgcHJpbnRzLFxuICAgICAga2lkO1xuXG4gIHByb3BzID0gY2xvbmUocHJvcHMpO1xuICAvLyBzdHJpcCB0aHVtYnByaW50cyBpZiBwcmVzZW50XG4gIHByaW50cyA9IGFzc2lnbih7fSwgcHJvcHNbSEVMUEVSUy5JTlRFUk5BTFMuVEhVTUJQUklOVF9LRVldIHx8IHt9KTtcbiAgZGVsZXRlIHByb3BzW0hFTFBFUlMuSU5URVJOQUxTLlRIVU1CUFJJTlRfS0VZXTtcbiAgT2JqZWN0LmtleXMocHJpbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgaCA9IHByaW50c1thXTtcbiAgICBpZiAoIWtpZCkge1xuICAgICAga2lkID0gaDtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoa2lkKSkge1xuICAgICAgICBraWQgPSBVVElMLmJhc2U2NHVybC5lbmNvZGUoa2lkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoaCkpIHtcbiAgICAgIGggPSBVVElMLmJhc2U2NHVybC5kZWNvZGUoaCk7XG4gICAgICBwcmludHNbYV0gPSBoO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZm9yY2UgY2VydGFpbiB2YWx1ZXNcbiAgcHJvcHMua3R5ID0ga3R5O1xuICBwcm9wcy5raWQgPSBwcm9wcy5raWQgfHwga2lkIHx8IHV1aWR2NCgpO1xuXG4gIC8vIHNldHVwIGJhc2UgaW5mb1xuICB2YXIgaW5jbHVkZWQgPSBPYmplY3Qua2V5cyhIRUxQRVJTLkNPTU1PTl9QUk9QUykubWFwKGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gSEVMUEVSUy5DT01NT05fUFJPUFNbcF0ubmFtZTtcbiAgfSk7XG4gIGpzb24uYmFzZSA9IHBpY2socHJvcHMsIGluY2x1ZGVkKTtcbiAgZXhjbHVkZWQgPSBleGNsdWRlZC5jb25jYXQoT2JqZWN0LmtleXMoanNvbi5iYXNlKSk7XG5cbiAgLy8gc2V0dXAgcHVibGljIGluZm9ybWF0aW9uXG4gIGpzb24ucHVibGljID0gY2xvbmUocHJvcHMpO1xuICBrZXlzLnB1YmxpYyA9IGNmZy5wdWJsaWNLZXkoanNvbi5wdWJsaWMpO1xuICBpZiAoa2V5cy5wdWJsaWMpIHtcbiAgICAvLyBleGNsdWRlIHB1YmxpYyB2YWx1ZXMgZnJvbSBleHRyYVxuICAgIGV4Y2x1ZGVkID0gZXhjbHVkZWQuY29uY2F0KE9iamVjdC5rZXlzKGpzb24ucHVibGljKSk7XG4gIH1cblxuICAvLyBzZXR1cCBwcml2YXRlIGluZm9ybWF0aW9uXG4gIGpzb24ucHJpdmF0ZSA9IGNsb25lKHByb3BzKTtcbiAga2V5cy5wcml2YXRlID0gY2ZnLnByaXZhdGVLZXkoanNvbi5wcml2YXRlKTtcbiAgaWYgKGtleXMucHJpdmF0ZSkge1xuICAgIC8vIGV4Y2x1ZGUgcHJpdmF0ZSB2YWx1ZXMgZnJvbSBleHRyYVxuICAgIGV4Y2x1ZGVkID0gZXhjbHVkZWQuY29uY2F0KE9iamVjdC5rZXlzKGpzb24ucHJpdmF0ZSkpO1xuICB9XG5cbiAgLy8gc2V0dXAgZXh0cmEgaW5mb3JtYXRpb25cbiAganNvbi5leHRyYSA9IG9taXQocHJvcHMsIGV4Y2x1ZGVkKTtcblxuICAvLyBUT0RPOiB2YWxpZGF0ZSAnYWxnJyBhZ2FpbnN0IHN1cHBvcnRlZCBhbGdvcml0aG1zXG5cbiAgLy8gc2V0dXAgY2FsY3VsYXRlZCB2YWx1ZXNcbiAgdmFyIGtleUxlbjtcbiAgaWYgKGtleXMucHVibGljICYmIChcImxlbmd0aFwiIGluIGtleXMucHVibGljKSkge1xuICAgIGtleUxlbiA9IGtleXMucHVibGljLmxlbmd0aDtcbiAgfSBlbHNlIGlmIChrZXlzLnByaXZhdGUgJiYgKFwibGVuZ3RoXCIgaW4ga2V5cy5wcml2YXRlKSkge1xuICAgIGtleUxlbiA9IGtleXMucHJpdmF0ZS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAga2V5TGVuID0gTmFOO1xuICB9XG5cbiAgLy8gIyMjIFB1YmxpYyBQcm9wZXJ0aWVzICMjI1xuICAvKipcbiAgICogQG1lbWJlciB7SldLLktleVN0b3JlfSBKV0suS2V5I2tleXN0b3JlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgb3duaW5nIGtleXN0b3JlLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5c3RvcmVcIiwge1xuICAgIHZhbHVlOiBrcyxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7TnVtYmVyfSBKV0suS2V5I2xlbmd0aFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHNpemUgb2YgdGhpcyBLZXksIGluIGJpdHMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZW5ndGhcIiwge1xuICAgIHZhbHVlOiBrZXlMZW4sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ30gSldLLktleSNrdHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSB0eXBlIG9mIEtleS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImt0eVwiLCB7XG4gICAgdmFsdWU6IGt0eSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEpXSy5LZXkja2lkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgaWRlbnRpZmllciBmb3IgdGhpcyBLZXkuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJraWRcIiwge1xuICAgIHZhbHVlOiBqc29uLmJhc2Uua2lkLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEpXSy5LZXkjdXNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgdXNhZ2UgZm9yIHRoaXMgS2V5LlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXNlXCIsIHtcbiAgICB2YWx1ZToganNvbi5iYXNlLnVzZSB8fCBcIlwiLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtTdHJpbmd9IEpXSy5LZXkjYWxnXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgc29sZSBhbGdvcml0aG0gdGhpcyBrZXkgY2FuIGJlIHVzZWQgZm9yLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxnXCIsIHtcbiAgICB2YWx1ZToganNvbi5iYXNlLmFsZyB8fCBcIlwiLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG5cbiAgLy8gIyMjIFB1YmxpYyBNZXRob2RzICMjI1xuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB0aHVtYnByaW50IG9mIHRoaXMgS2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW10gVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSB0aHVtYnByaW50IGdlbmVyYXRpb24uXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aHVtYnByaW50XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaGFzaCkge1xuICAgICAgaGFzaCA9IChoYXNoIHx8IEhFTFBFUlMuSU5URVJOQUxTLlRIVU1CUFJJTlRfSEFTSCkudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChwcmludHNbaGFzaF0pIHtcbiAgICAgICAgLy8gcmV0dXJuIGNhY2hlZCB2YWx1ZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByaW50c1toYXNoXSk7XG4gICAgICB9XG4gICAgICB2YXIgcCA9IEhFTFBFUlMudGh1bWJwcmludChjZmcsIGpzb24sIGhhc2gpO1xuICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByaW50c1toYXNoXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I2FsZ29yaXRobXNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBwb3NzaWJsZSBhbGdvcml0aG1zIHRoaXMgS2V5IGNhbiBiZSB1c2VkIGZvci4gVGhlIHJldHVybmVkXG4gICAqIGxpc3QgaXMgbm90IGFueSBwYXJ0aWN1bGFyIG9yZGVyLCBidXQgaXMgZmlsdGVyZWQgYmFzZWQgb24gdGhlXG4gICAqIEtleSdzIGludGVuZGVkIHVzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBUaGUgb3BlcmF0aW9uIG1vZGVcbiAgICogQHJldHVybnMge1N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdXBwb3J0ZWQgYWxnb3JpdGhtc1xuICAgKiBAc2VlIEpXSy5LZXkjc3VwcG9ydHNcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsZ29yaXRobXNcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihtb2RlKSB7XG4gICAgICB2YXIgbW9kZXMgPSBbXTtcbiAgICAgIGlmICghdGhpcy51c2UgfHwgdGhpcy51c2UgPT09IFwic2lnXCIpIHtcbiAgICAgICAgaWYgKCFtb2RlIHx8IENPTlNUQU5UUy5NT0RFX1NJR04gPT09IG1vZGUpIHtcbiAgICAgICAgICBtb2Rlcy5wdXNoKENPTlNUQU5UUy5NT0RFX1NJR04pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZSB8fCBDT05TVEFOVFMuTU9ERV9WRVJJRlkgPT09IG1vZGUpIHtcbiAgICAgICAgICBtb2Rlcy5wdXNoKENPTlNUQU5UUy5NT0RFX1ZFUklGWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy51c2UgfHwgdGhpcy51c2UgPT09IFwiZW5jXCIpIHtcbiAgICAgICAgaWYgKCFtb2RlIHx8IENPTlNUQU5UUy5NT0RFX0VOQ1JZUFQgPT09IG1vZGUpIHtcbiAgICAgICAgICBtb2Rlcy5wdXNoKENPTlNUQU5UUy5NT0RFX0VOQ1JZUFQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZSB8fCBDT05TVEFOVFMuTU9ERV9ERUNSWVBUID09PSBtb2RlKSB7XG4gICAgICAgICAgbW9kZXMucHVzaChDT05TVEFOVFMuTU9ERV9ERUNSWVBUKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUgfHwgQ09OU1RBTlRTLk1PREVfV1JBUCA9PT0gbW9kZSkge1xuICAgICAgICAgIG1vZGVzLnB1c2goQ09OU1RBTlRTLk1PREVfV1JBUCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlIHx8IENPTlNUQU5UUy5NT0RFX1VOV1JBUCA9PT0gbW9kZSkge1xuICAgICAgICAgIG1vZGVzLnB1c2goQ09OU1RBTlRTLk1PREVfVU5XUkFQKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgYWxncyA9IG1vZGVzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBjZmcuYWxnb3JpdGhtcy5jYWxsKHNlbGYsIGtleXMsIG0pO1xuICAgICAgfSk7XG4gICAgICBhbGdzID0gZmxhdHRlbihhbGdzKTtcbiAgICAgIGFsZ3MgPSB1bmlxKGFsZ3MpO1xuICAgICAgaWYgKHRoaXMuYWxnKSB7XG4gICAgICAgIC8vIFRPRE86IGZpeCB0aGlzIGNvcnJlY3RseVxuICAgICAgICB2YXIgdmFsaWQ7XG4gICAgICAgIGlmIChcIm9jdFwiID09PSBrdHkpIHtcbiAgICAgICAgICB2YWxpZCA9IFt0aGlzLmFsZywgXCJkaXJcIl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBbdGhpcy5hbGddO1xuICAgICAgICB9XG4gICAgICAgIGFsZ3MgPSBpbnRlcnNlY3Rpb24oYWxncywgdmFsaWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxncztcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3N1cHBvcnRzXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBhbGdvcml0aG0gaXMgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSBhbGdvcml0aG0gaW4gcXVlc3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IFttb2RlXSBUaGUgb3BlcmF0aW9uIG1vZGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB7YWxnfSBpcyBzdXBwb3J0ZWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICogQHNlZSBKV0suS2V5I2FsZ29yaXRobXNcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN1cHBvcnRzXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBtb2RlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuYWxnb3JpdGhtcyhtb2RlKS5pbmRleE9mKGFsZykgIT09IC0xKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I2hhc1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIEtleSBjb250YWlucyB0aGUgZ2l2ZW4gcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUHJpdmF0ZT1mYWxzZV0gYHRydWVgIGlmIHByaXZhdGUgcGFyYW1ldGVycyBzaG91bGQgYmVcbiAgICogICAgICAgIGNoZWNrZWQuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBwcmVzZW50OyBgZmFsc2VgXG4gICAqICAgICAgICAgIG90aGVyd2lzZS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc1wiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKG5hbWUsIGlzUHJpdmF0ZSkge1xuICAgICAgdmFyIGNvbnRhaW5zID0gZmFsc2U7XG4gICAgICBjb250YWlucyA9IGNvbnRhaW5zIHx8ICEhKGpzb24uYmFzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSBpbiBqc29uLmJhc2UpKTtcbiAgICAgIGNvbnRhaW5zID0gY29udGFpbnMgfHwgISEoa2V5cy5wdWJsaWMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWUgaW4ga2V5cy5wdWJsaWMpKTtcbiAgICAgIGNvbnRhaW5zID0gY29udGFpbnMgfHwgISEoanNvbi5leHRyYSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSBpbiBqc29uLmV4dHJhKSk7XG4gICAgICBjb250YWlucyA9IGNvbnRhaW5zIHx8ICEhKGlzUHJpdmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnByaXZhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWUgaW4ga2V5cy5wcml2YXRlKSk7XG4gICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXhwb3J0IHJlc3RyaWN0aW9uc1xuXG4gICAgICByZXR1cm4gY29udGFpbnM7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHBhcmFtZXRlci4gVGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoaXNcbiAgICogbWV0aG9kIGlzIGluIGl0cyBuYXR1cmFsIGZvcm1hdCwgd2hpY2ggbWlnaHQgbm90IGV4YWN0bHkgbWF0Y2ggaXRzXG4gICAqIEpTT04gZW5jb2RpbmcgKGUuZy4sIGEgYmluYXJ5IHN0cmluZyByYXRoZXIgdGhhbiBhIGJhc2U2NHVybC1lbmNvZGVkXG4gICAqIHN0cmluZykuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIG1ldGhvZCBjYW4gcmV0dXJuIGBmYWxzZWAuIENhbGxcbiAgICoge0BsaW5rIEpXSy5LZXkjaGFzfSB0byBkZXRlcm1pbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBwcmVzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyYW1ldGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUHJpdmF0ZT1mYWxzZV0gYHRydWVgIGlmIHByaXZhdGUgcGFyYW1ldGVycyBzaG91bGRcbiAgICogICAgICAgIGJlIGNoZWNrZWQuXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgcGFyYW1ldGVyLCBvciB1bmRlZmluZWQgaWZcbiAgICogICAgICAgICAgaXQgaXMgbm90IHByZXNlbnQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihuYW1lLCBpc1ByaXZhdGUpIHtcbiAgICAgIHZhciBzcmM7XG4gICAgICBpZiAoanNvbi5iYXNlICYmIChuYW1lIGluIGpzb24uYmFzZSkpIHtcbiAgICAgICAgc3JjID0ganNvbi5iYXNlO1xuICAgICAgfSBlbHNlIGlmIChrZXlzLnB1YmxpYyAmJiAobmFtZSBpbiBrZXlzLnB1YmxpYykpIHtcbiAgICAgICAgc3JjID0ga2V5cy5wdWJsaWM7XG4gICAgICB9IGVsc2UgaWYgKGpzb24uZXh0cmEgJiYgKG5hbWUgaW4ganNvbi5leHRyYSkpIHtcbiAgICAgICAgc3JjID0ganNvbi5leHRyYTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcml2YXRlICYmIGtleXMucHJpdmF0ZSAmJiAobmFtZSBpbiBrZXlzLnByaXZhdGUpKSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleHBvcnQgcmVzdHJpY3Rpb25zXG4gICAgICAgIHNyYyA9IGtleXMucHJpdmF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNyYyAmJiBzcmNbbmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3RvSlNPTlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEtleS4gIEFsbCBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgKiByZXR1cm5lZCBKU09OIG9iamVjdCBhcmUgcHJvcGVybHkgZW5jb2RlZCAoZS5nLiwgYmFzZTY0dXJsIGVuY29kaW5nIGZvclxuICAgKiBhbnkgYmluYXJ5IHN0cmluZ3MpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1ByaXZhdGU9ZmFsc2VdIGB0cnVlYCBpZiBwcml2YXRlIHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICAgICBpbmNsdWRlZC5cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gW2V4Y2x1ZGVkXSBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIHRvIGV4Y2x1ZGUgZnJvbVxuICAgKiAgICAgICAgdGhlIHJldHVybmVkIEpTT04uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbGFpbiBKU09OIG9iamVjdFxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9KU09OXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaXNQcml2YXRlLCBleGNsdWRlZCkge1xuICAgICAgLy8gY29lcmNlIGFyZ3VtZW50c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXNQcml2YXRlKSkge1xuICAgICAgICBleGNsdWRlZCA9IGlzUHJpdmF0ZTtcbiAgICAgICAgaXNQcml2YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleHBvcnQgcmVzdHJpY3Rpb25zXG4gICAgICByZXN1bHQgPSBtZXJnZShyZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgIGpzb24uYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAganNvbi5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgICAgIChcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGlzUHJpdmF0ZSAmJiBpc1ByaXZhdGUpID8ganNvbi5wcml2YXRlIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgIGpzb24uZXh0cmEpO1xuICAgICAgcmVzdWx0ID0gb21pdChyZXN1bHQsIGV4Y2x1ZGVkIHx8IFtdKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjdG9QRU1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgdGhlIFBFTSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEtleSBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNQcml2YXRlPWZhbHNlXSBgdHJ1ZWAgaWYgcHJpdmF0ZSBwYXJhbWV0ZXJzIHNob3VsZCBiZVxuICAgKiAgICAgICAgaW5jbHVkZWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBQRU0tZW5jb2RlZCBzdHJpbmdcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvUEVNXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaXNQcml2YXRlKSB7XG4gICAgICBpZiAoaXNQcml2YXRlID09PSBudWxsKSB7XG4gICAgICAgIGlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNmZy5jb252ZXJ0VG9QRU0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQga2V5IHR5cGUgZm9yIFBFTSBlbmNvZGluZ1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gKGlzUHJpdmF0ZSkgPyBrZXlzLnByaXZhdGUgOiBrZXlzLnB1YmxpYztcbiAgICAgIGlmICghaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGtleVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjZmcuY29udmVydFRvUEVNLmNhbGwodGhpcywgaywgaXNQcml2YXRlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjdG9PYmplY3RcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgdGhlIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBLZXkuICBBbGwgcHJvcGVydGllcyBvZiB0aGVcbiAgICogcmV0dXJuZWQgb2JqZWN0IGFyZSBpbiB0aGVpciBuYXR1cmFsIGVuY29kaW5nIChlLmcuLCBiaW5hcnkgc3RyaW5nc1xuICAgKiBpbnN0ZWFkIG9mIGJhc2U2NHVybCBlbmNvZGVkKS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNQcml2YXRlPWZhbHNlXSBgdHJ1ZWAgaWYgcHJpdmF0ZSBwYXJhbWV0ZXJzIHNob3VsZCBiZVxuICAgKiAgICAgICAgaW5jbHVkZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IFtleGNsdWRlZF0gVGhlIGxpc3Qgb2YgcGFyYW1ldGVycyB0byBleGNsdWRlIGZyb21cbiAgICogICAgICAgIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwbGFpbiBPYmplY3QuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b09iamVjdFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGlzUHJpdmF0ZSwgZXhjbHVkZWQpIHtcbiAgICAgIC8vIGNvZXJjZSBhcmd1bWVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlzUHJpdmF0ZSkpIHtcbiAgICAgICAgZXhjbHVkZWQgPSBpc1ByaXZhdGU7XG4gICAgICAgIGlzUHJpdmF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXhwb3J0IHJlc3RyaWN0aW9uc1xuICAgICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICBqc29uLmJhc2UsXG4gICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVibGljLFxuICAgICAgICAgICAgICAgICAgICAgICAoXCJib29sZWFuXCIgPT09IHR5cGVvZiBpc1ByaXZhdGUgJiYgaXNQcml2YXRlKSA/IGtleXMucHJpdmF0ZSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICBqc29uLmV4dHJhKTtcbiAgICAgIHJlc3VsdCA9IG9taXQocmVzdWx0LCAoZXhjbHVkZWQgfHwgW10pLmNvbmNhdChcImxlbmd0aFwiKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3NpZ25cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNpZ24gdGhlIGdpdmVuIGRhdGEgdXNpbmcgdGhlIHNwZWNpZmllZCBhbGdvcml0aG0uXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIGlzIHRoZSBwcmltaXRpdmUgc2lnbmluZyBvcGVyYXRpb247IHRoZSBvdXRwdXQgaXNcbiAgICogXyoqTk9UKipfIGEgSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpIG9iamVjdC5cbiAgICpcbiAgICogVGhlIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIGFuIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogKyAqKmRhdGEqKjogVGhlIGRhdGEgdGhhdCB3YXMgc2lnbmVkIChhbmQgc2hvdWxkIGJlIGVxdWFsIHRvIHtkYXRhfSkuXG4gICAqICsgKiptYWMqKjogVGhlIHNpZ25hdHVyZSBvciBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUgKE1BQykuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIHNpZ25pbmcgYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gZGF0YSBUaGUgZGF0YSB0byBzaWduXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIHNpZ25pbmdcbiAgICogICAgICAgIGFsZ29yaXRobS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgc2lnbmluZyBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7YWxnfSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoaXMgS2V5OyBvciBpZlxuICAgKiAgICAgICAgIHRoaXMgS2V5IGRvZXMgbm90IGNvbnRhaW4gdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlcnMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBkYXRhLCBwcm9wcykge1xuICAgICAgLy8gdmFsaWRhdGUgYXBwcm9wcmlhdGVuZXNzXG4gICAgICBpZiAodGhpcy5hbGdvcml0aG1zKFwic2lnblwiKS5pbmRleE9mKGFsZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG1cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBjZmcuc2lnbktleS5jYWxsKHRoaXMsIGFsZywga2V5cyk7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImltcHJvcGVyIGtleVwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgcHJvcGVydGllcyAoaWYgYW55KVxuICAgICAgcHJvcHMgPSAocHJvcHMpID9cbiAgICAgICAgICAgICAgY2xvbmUocHJvcHMpIDpcbiAgICAgICAgICAgICAge307XG4gICAgICBpZiAoY2ZnLnNpZ25Qcm9wcykge1xuICAgICAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCBjZmcuc2lnblByb3BzLmNhbGwodGhpcywgYWxnLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFMR09SSVRITVMuc2lnbihhbGcsIGssIGRhdGEsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3ZlcmlmeVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVmVyaWZ5IHRoZSBnaXZlbiBkYXRhIGFuZCBzaWduYXR1cmUgdXNpbmcgdGhlIHNwZWNpZmllZCBhbGdvcml0aG0uXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIGlzIHRoZSBwcmltaXRpdmUgdmVyaWZpY2F0aW9uIG9wZXJhdGlvbjsgdGhlIGlucHV0IGlzXG4gICAqIF8qKk5PVCoqXyBhIEpTT04gV2ViIFNpZ25hdHVyZS48L3A+XG4gICAqXG4gICAqIFRoZSBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyBhbiBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICsgKipkYXRhKio6IFRoZSBkYXRhIHRoYXQgd2FzIHZlcmlmaWVkIChhbmQgc2hvdWxkIGJlIGVxdWFsIHRvXG4gICAqICAge2RhdGF9KS5cbiAgICogKyAqKm1hYyoqOiBUaGUgc2lnbmF0dXJlIG9yIE1BQyB0aGF0IHdhcyB2ZXJpZmllZCAoYW5kIHNob3VsZCBiZSBlcXVhbFxuICAgKiAgIHRvIHttYWN9KS5cbiAgICogKyAqKnZhbGlkKio6IGB0cnVlYCBpZiB7bWFjfSBpcyB2YWxpZCBmb3Ige2RhdGF9LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSB2ZXJpZmljYXRpb24gYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gZGF0YSBUaGUgZGF0YSB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBtYWMgVGhlIHNpZ25hdHVyZSBvciBNQUMgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIHZlcmlmaWNhdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSB2ZXJpZmljYXRpb24gb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2FsZ30gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIEtleTsgb3IgaWZcbiAgICogICAgICAgICB0aGUgS2V5IGRvZXMgbm90IGNvbnRhaW4gdGhlIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJpZnlcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIGRhdGEsIG1hYywgcHJvcHMpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFwcHJvcHJpYXRlbmVzc1xuICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtcyhcInZlcmlmeVwiKS5pbmRleE9mKGFsZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG1cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBjZmcudmVyaWZ5S2V5LmNhbGwodGhpcywgYWxnLCBrZXlzKTtcbiAgICAgIGlmICghaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW1wcm9wZXIga2V5XCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBwcm9wZXJ0aWVzIChpZiBhbnkpXG4gICAgICBwcm9wcyA9IChwcm9wcykgP1xuICAgICAgICAgICAgICBjbG9uZShwcm9wcykgOlxuICAgICAgICAgICAgICB7fTtcbiAgICAgIGlmIChjZmcudmVyaWZ5UHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBtZXJnZShwcm9wcywgY2ZnLnZlcmlmeVByb3BzLmNhbGwodGhpcywgYWxnLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFMR09SSVRITVMudmVyaWZ5KGFsZywgaywgZGF0YSwgbWFjLCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I2VuY3J5cHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEVuY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIHRoZSBzcGVjaWZpZWQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBpcyB0aGUgcHJpbWl0aXZlIGVuY3J5cHRpb24gb3BlcmF0aW9uOyB0aGUgb3V0cHV0IGlzXG4gICAqIF8qKk5PVCoqXyBhIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSkgb2JqZWN0LlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBvcGVyYXRpb24gaXMgdHJlYXRlZCBhcyBkaXN0aW5jdCBmcm9tIHtAbGlua1xuICAgKiBKV0suS2V5I3dyYXB9LCBhcyBkaWZmZXJlbnQgYWxnb3JpdGhtcyBhbmQgcHJvcGVydGllcyBhcmUgb2Z0ZW5cbiAgICogdXNlZCBmb3Igd3JhcHBpbmcgYSBrZXkgdmVyc3VlcyBlbmNyeXB0aW5nIGFyYml0cmFyeSBkYXRhLlxuICAgKlxuICAgKiBUaGUgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiArICoqZGF0YSoqOiBUaGUgY2lwaGVydGV4dCBkYXRhXG4gICAqICsgKiptYWMqKjogVGhlIGFzc29jaWF0ZWQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlIChNQUMpLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSBlbmNyeXB0aW9uIGFsZ29yaXRobVxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gZW5jcnlwdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgZm9yIHRoZSBlbmNyeXB0aW9uXG4gICAqICAgICAgICBhbGdvcml0aG0uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2FsZ30gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIEtleTsgb3IgaWZcbiAgICogICAgICAgICB0aGlzIEtleSBkb2VzIG5vdCBjb250YWluIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jcnlwdFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgZGF0YSwgcHJvcHMpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFwcHJvcHJpYXRlbmVzc1xuICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtcyhcImVuY3J5cHRcIikuaW5kZXhPZihhbGcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gY2ZnLmVuY3J5cHRLZXkuY2FsbCh0aGlzLCBhbGcsIGtleXMpO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbXByb3BlciBrZXlcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIHByb3BlcnRpZXMgKGlmIGFueSlcbiAgICAgIHByb3BzID0gKHByb3BzKSA/XG4gICAgICAgICAgICAgIGNsb25lKHByb3BzKSA6XG4gICAgICAgICAgICAgIHt9O1xuICAgICAgaWYgKGNmZy5lbmNyeXB0UHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBtZXJnZShwcm9wcywgY2ZnLmVuY3J5cHRQcm9wcy5jYWxsKHRoaXMsIGFsZywgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBTEdPUklUSE1TLmVuY3J5cHQoYWxnLCBrLCBkYXRhLCBwcm9wcyk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSNkZWNyeXB0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWNyeXB0cyB0aGUgZ2l2ZW4gZGF0YSB1c2luZyB0aGUgc3BlY2lmaWVkIGFsZ29yaXRobS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgaXMgdGhlIHByaW1pdGl2ZSBkZWNyeXB0aW9uIG9wZXJhdGlvbjsgdGhlIGlucHV0IGlzXG4gICAqIF8qKk5PVCoqXyBhIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSkgb2JqZWN0LlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBvcGVyYXRpb24gaXMgdHJlYXRlZCBhcyBkaXN0aW5jdCBmcm9tIHtAbGlua1xuICAgKiBKV0suS2V5I3Vud3JhcH0sIGFzIGRpZmZlcmVudCBhbGdvcml0aG1zIGFuZCBwcm9wZXJ0aWVzIGFyZSBvZnRlbiB1c2VkXG4gICAqIGZvciB1bndyYXBwaW5nIGEga2V5IHZlcnN1ZXMgZGVjcnlwdGluZyBhcmJpdHJhcnkgZGF0YS5cbiAgICpcbiAgICogVGhlIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIHRoZSBwbGFpbnRleHQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgZGVjcnlwdGlvbiBhbGdvcml0aG0uXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBkZWN5cHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgZGF0YSBmb3IgdGhlIGRlY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBkZWNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHthbGd9IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBLZXk7IG9yIGlmXG4gICAqICAgICAgICAgdGhlIEtleSBkb2VzIG5vdCBjb250YWluIHRoZSBhcHByb3ByaWF0ZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVjcnlwdFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgZGF0YSwgcHJvcHMpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFwcHJvcHJpYXRlbmVzc1xuICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtcyhcImRlY3J5cHRcIikuaW5kZXhPZihhbGcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gY2ZnLmRlY3J5cHRLZXkuY2FsbCh0aGlzLCBhbGcsIGtleXMpO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbXByb3BlciBrZXlcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIHByb3BlcnRpZXMgKGlmIGFueSlcbiAgICAgIHByb3BzID0gKHByb3BzKSA/XG4gICAgICAgICAgICAgIGNsb25lKHByb3BzKSA6XG4gICAgICAgICAgICAgIHt9O1xuICAgICAgaWYgKGNmZy5kZWNyeXB0UHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBtZXJnZShwcm9wcywgY2ZnLmRlY3J5cHRQcm9wcy5jYWxsKHRoaXMsIGFsZywgcHJvcHMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBTEdPUklUSE1TLmRlY3J5cHQoYWxnLCBrLCBkYXRhLCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3dyYXBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFdyYXBzIHRoZSBnaXZlbiBrZXkgdXNpbmcgdGhlIHNwZWNpZmllZCBhbGdvcml0aG0uXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIGlzIHRoZSBwcmltaXRpdmUgZW5jcnlwdGlvbiBvcGVyYXRpb247IHRoZSBvdXRwdXQgaXNcbiAgICogXyoqTk9UKipfIGEgSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKSBvYmplY3QuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIG9wZXJhdGlvbiBpcyB0cmVhdGVkIGFzIGRpc3RpbmN0IGZyb20ge0BsaW5rXG4gICAqIEpXSy5LZXkjZW5jcnlwdH0sIGFzIGRpZmZlcmVudCBhbGdvcml0aG1zIGFuZCBwcm9wZXJ0aWVzIGFyZVxuICAgKiBvZnRlbiB1c2VkIGZvciB3cmFwcGluZyBhIGtleSB2ZXJzdWVzIGVuY3J5cHRpbmcgYXJiaXRyYXJ5IGRhdGEuXG4gICAqXG4gICAqIFRoZSBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICsgKipkYXRhKio6IFRoZSBjaXBoZXJ0ZXh0IGRhdGFcbiAgICogKyAqKmhlYWRlcnMqKjogVGhlIGFkZGl0aW9uYWwgaGVhZGVyIHBhcmFtZXRlcnMgdG8gYXBwbHkgdG8gYSBKV0UuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBlbmNyeXB0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGVuY3J5cHRpb25cbiAgICogICAgICAgIGFsZ29yaXRobS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7YWxnfSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoaXMgS2V5OyBvciBpZlxuICAgKiAgICAgICAgIHRoaXMgS2V5IGRvZXMgbm90IGNvbnRhaW4gdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlcnMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3cmFwXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBkYXRhLCBwcm9wcykge1xuICAgICAgLy8gdmFsaWRhdGUgYXBwcm9wcmlhdGVuZXNzXG4gICAgICBpZiAodGhpcy5hbGdvcml0aG1zKFwid3JhcFwiKS5pbmRleE9mKGFsZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG1cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBjZmcud3JhcEtleS5jYWxsKHRoaXMsIGFsZywga2V5cyk7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImltcHJvcGVyIGtleVwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgcHJvcGVydGllcyAoaWYgYW55KVxuICAgICAgcHJvcHMgPSAocHJvcHMpID9cbiAgICAgICAgICAgICAgY2xvbmUocHJvcHMpIDpcbiAgICAgICAgICAgICAge307XG4gICAgICBpZiAoY2ZnLndyYXBQcm9wcykge1xuICAgICAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCBjZmcud3JhcFByb3BzLmNhbGwodGhpcywgYWxnLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFMR09SSVRITVMuZW5jcnlwdChhbGcsIGssIGRhdGEsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I3Vud3JhcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVW53cmFwcyB0aGUgZ2l2ZW4ga2V5IHVzaW5nIHRoZSBzcGVjaWZpZWQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBpcyB0aGUgcHJpbWl0aXZlIHVud3JhcCBvcGVyYXRpb247IHRoZSBpbnB1dCBpc1xuICAgKiBfKipOT1QqKl8gYSBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpIG9iamVjdC5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgb3BlcmF0aW9uIGlzIHRyZWF0ZWQgYXMgZGlzdGluY3QgZnJvbSB7QGxpbmtcbiAgICogSldLLktleSNkZWNyeXB0fSwgYXMgZGlmZmVyZW50IGFsZ29yaXRobXMgYW5kIHByb3BlcnRpZXMgYXJlIG9mdGVuIHVzZWRcbiAgICogZm9yIHVud3JhcHBpbmcgYSBrZXkgdmVyc3VlcyBkZWNyeXB0aW5nIGFyYml0cmFyeSBkYXRhLlxuICAgKlxuICAgKiBUaGUgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgdGhlIHVud3JhcHBlZCBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIHVud3JhcCBhbGdvcml0aG0uXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byB1bndyYXAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgZGF0YSBmb3IgdGhlIHVud3JhcCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHVud3JhcCBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7YWxnfSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoaXMgS2V5OyBvciBpZlxuICAgKiAgICAgICAgIHRoZSBLZXkgZG9lcyBub3QgY29udGFpbiB0aGUgYXBwcm9wcmlhdGUgcHJvcGVydGllcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVud3JhcFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgZGF0YSwgcHJvcHMpIHtcbiAgICAgIC8vIHZhbGlkYXRlIGFwcHJvcHJpYXRlbmVzc1xuICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtcyhcInVud3JhcFwiKS5pbmRleE9mKGFsZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG1cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBjZmcudW53cmFwS2V5LmNhbGwodGhpcywgYWxnLCBrZXlzKTtcbiAgICAgIGlmICghaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW1wcm9wZXIga2V5XCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBwcm9wZXJ0aWVzIChpZiBhbnkpXG4gICAgICBwcm9wcyA9IChwcm9wcykgP1xuICAgICAgICAgICAgICBjbG9uZShwcm9wcykgOlxuICAgICAgICAgICAgICB7fTtcbiAgICAgIGlmIChjZmcudW53cmFwUHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBtZXJnZShwcm9wcywgY2ZnLnVud3JhcFByb3BzLmNhbGwodGhpcywgYWxnLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFMR09SSVRITVMuZGVjcnlwdChhbGcsIGssIGRhdGEsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKV0tCYXNlS2V5T2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/constants.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/*!\n * jwk/constants.js - Constants for JWKs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nmodule.exports = {\n  MODE_SIGN: \"sign\",\n  MODE_VERIFY: \"verify\",\n  MODE_ENCRYPT: \"encrypt\",\n  MODE_DECRYPT: \"decrypt\",\n  MODE_WRAP: \"wrap\",\n  MODE_UNWRAP: \"unwrap\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9jb25zdGFudHMuanM/NDZhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9jb25zdGFudHMuanMgLSBDb25zdGFudHMgZm9yIEpXS3NcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1PREVfU0lHTjogXCJzaWduXCIsXG4gIE1PREVfVkVSSUZZOiBcInZlcmlmeVwiLFxuICBNT0RFX0VOQ1JZUFQ6IFwiZW5jcnlwdFwiLFxuICBNT0RFX0RFQ1JZUFQ6IFwiZGVjcnlwdFwiLFxuICBNT0RFX1dSQVA6IFwid3JhcFwiLFxuICBNT0RFX1VOV1JBUDogXCJ1bndyYXBcIlxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/eckey.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/eckey.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar ecutil = __webpack_require__(/*! ../algorithms/ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    depsecc = __webpack_require__(/*! ../deps/ecc */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n];\nvar WRAP_ALGS = [\n  \"ECDH-ES\",\n  \"ECDH-ES+A128KW\",\n  \"ECDH-ES+A192KW\",\n  \"ECDH-ES+A256KW\"\n];\n\nvar EC_OID = ecutil.EC_OID;\nfunction oidToCurveName(oid) {\n  switch (oid) {\n    case \"1.2.840.10045.3.1.7\":\n      return \"P-256\";\n    case \"1.3.132.0.34\":\n      return \"P-384\";\n    case \"1.3.132.0.35\":\n      return \"P-521\";\n    default:\n      return null;\n  }\n}\n\nvar JWKEcCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"crv\", type: \"string\"},\n      {name: \"x\", type: \"binary\"},\n      {name: \"y\", type: \"binary\"}\n    ]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.crv && pk.x && pk.y) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      delete pk.crv;\n      delete pk.x;\n      delete pk.y;\n    }\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"crv\", type: \"string\"},\n      {name: \"x\", type: \"binary\"},\n      {name: \"y\", type: \"binary\"},\n      {name: \"d\", type: \"binary\"}\n    ]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.crv && pk.x && pk.y && pk.d) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function(json) {\n    if (json.public) {\n      json = json.public;\n    }\n    var fields = {\n      crv: json.crv,\n      kty: \"EC\",\n      x: json.x,\n      y: json.y\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    var len = (keys.public && keys.public.length) ||\n              (keys.private && keys.private.length) ||\n              0;\n    // NOTE: 521 is the actual, but 512 is the expected\n    if (len === 521) {\n        len = 512;\n    }\n\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return [];\n      case \"wrap\":\n        return (keys.public && WRAP_ALGS) || [];\n      case \"unwrap\":\n        return (keys.private && WRAP_ALGS) || [];\n      case \"sign\":\n        if (!keys.private) {\n          return [];\n        }\n        return SIG_ALGS.filter(function(a) {\n          return (a === (\"ES\" + len));\n        });\n      case \"verify\":\n        if (!keys.public) {\n          return [];\n        }\n        return SIG_ALGS.filter(function(a) {\n          return (a === (\"ES\" + len));\n        });\n    }\n  },\n\n  encryptKey: function(alg, keys) {\n    return keys.public;\n  },\n  decryptKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  wrapKey: function(alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  signKey: function(alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.public;\n  }\n};\nJWKEcCfg.convertToPEM = ecutil.convertToPEM;\n\n// Inspired by digitalbaazar/node-forge/js/rsa.js\nvar validators = {\n  oid: EC_OID,\n  privateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // EC version\n        name: \"ECPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false\n      },\n      {\n        // private value (d)\n        name: \"ECPrivateKey.private\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // EC parameters\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        name: \"ECPrivateKey.parameters\",\n        constructed: true,\n        value: [\n          {\n            // namedCurve (crv)\n            name: \"ECPrivateKey.namedCurve\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.OID,\n            constructed: false,\n            capture: \"crv\"\n          }\n        ]\n      },\n      {\n        // publicKey\n        name: \"ECPrivateKey.publicKey\",\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        value: [\n          {\n            name: \"ECPrivateKey.point\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.BITSTRING,\n            constructed: false,\n            capture: \"point\"\n          }\n        ]\n      }\n    ]\n  },\n  embeddedPrivateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // EC version\n        name: \"ECPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false\n      },\n      {\n        // private value (d)\n        name: \"ECPrivateKey.private\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // publicKey\n        name: \"ECPrivateKey.publicKey\",\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        value: [\n          {\n            name: \"ECPrivateKey.point\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.BITSTRING,\n            constructed: false,\n            capture: \"point\"\n          }\n        ]\n      }\n    ]\n  }\n};\n\nvar JWKEcFactory = {\n  kty: \"EC\",\n  validators: validators,\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKEcCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    var keypair = depsecc.generateKeyPair(size);\n    var result = {\n      \"crv\": size,\n      \"x\": keypair.public.x,\n      \"y\": keypair.public.y,\n      \"d\": keypair.private.d\n    };\n    return Promise.resolve(result);\n  },\n  import: function(input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    // coerce key params to OID\n    var crv;\n    if (input.keyParams && forge.asn1.Type.OID === input.keyParams.type) {\n      crv = forge.asn1.derToOid(input.keyParams.value);\n      crv = oidToCurveName(crv);\n    } else if (input.crv) {\n      crv = forge.asn1.derToOid(input.crv);\n      crv = oidToCurveName(crv);\n    }\n    if (!crv) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      var capture = {},\n          errors = [];\n      if (\"private\" === input.type) {\n        // coerce capture.value to DER *iff* private\n        if (\"string\" === typeof input.keyValue) {\n          input.keyValue = forge.asn1.fromDer(input.keyValue);\n        } else if (Array.isArray(input.keyValue)) {\n          input.keyValue = input.keyValue[0];\n        }\n\n        if (!forge.asn1.validate(input.keyValue,\n                                 validators.embeddedPrivateKey,\n                                 capture,\n                                 errors)) {\n          return null;\n        }\n      } else {\n        capture.point = input.keyValue;\n      }\n      input = capture;\n    }\n\n    // convert factors to Buffers\n    var output = {\n      kty: \"EC\",\n      crv: crv\n    };\n    if (input.d) {\n      output.d = Buffer.from(input.d, \"binary\");\n    }\n    if (input.point) {\n      var pt = Buffer.from(input.point, \"binary\");\n      // only support uncompressed\n      if (4 !== pt.readUInt16BE(0)) {\n        return null;\n      }\n      pt = pt.slice(2);\n      var len = pt.length / 2;\n      output.x = pt.slice(0, len);\n      output.y = pt.slice(len);\n    }\n    return output;\n  }\n};\n// public API\nmodule.exports = Object.freeze({\n  config: JWKEcCfg,\n  factory: JWKEcFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKEcFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svZWNrZXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywwRkFBMEI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx5RUFBYTs7QUFFbkM7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkMsT0FBTywwQkFBMEI7QUFDakMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPLDRCQUE0QjtBQUNuQyxPQUFPLDBCQUEwQjtBQUNqQyxPQUFPLDBCQUEwQjtBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9lY2tleS5qcz8yMmFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL3JzYS5qcyAtIFJTQSBLZXkgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGVjdXRpbCA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zL2VjLXV0aWwuanNcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZVwiKSxcbiAgICBkZXBzZWNjID0gcmVxdWlyZShcIi4uL2RlcHMvZWNjXCIpO1xuXG52YXIgSldLID0ge1xuICBCYXNlS2V5OiByZXF1aXJlKFwiLi9iYXNla2V5LmpzXCIpLFxuICBoZWxwZXJzOiByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpXG59O1xuXG52YXIgU0lHX0FMR1MgPSBbXG4gIFwiRVMyNTZcIixcbiAgXCJFUzM4NFwiLFxuICBcIkVTNTEyXCJcbl07XG52YXIgV1JBUF9BTEdTID0gW1xuICBcIkVDREgtRVNcIixcbiAgXCJFQ0RILUVTK0ExMjhLV1wiLFxuICBcIkVDREgtRVMrQTE5MktXXCIsXG4gIFwiRUNESC1FUytBMjU2S1dcIlxuXTtcblxudmFyIEVDX09JRCA9IGVjdXRpbC5FQ19PSUQ7XG5mdW5jdGlvbiBvaWRUb0N1cnZlTmFtZShvaWQpIHtcbiAgc3dpdGNoIChvaWQpIHtcbiAgICBjYXNlIFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiOlxuICAgICAgcmV0dXJuIFwiUC0yNTZcIjtcbiAgICBjYXNlIFwiMS4zLjEzMi4wLjM0XCI6XG4gICAgICByZXR1cm4gXCJQLTM4NFwiO1xuICAgIGNhc2UgXCIxLjMuMTMyLjAuMzVcIjpcbiAgICAgIHJldHVybiBcIlAtNTIxXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBKV0tFY0NmZyA9IHtcbiAgcHVibGljS2V5OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBmaWVsZHMgPSBKV0suaGVscGVycy5DT01NT05fUFJPUFMuY29uY2F0KFtcbiAgICAgIHtuYW1lOiBcImNydlwiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICAgIHtuYW1lOiBcInhcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJ5XCIsIHR5cGU6IFwiYmluYXJ5XCJ9XG4gICAgXSk7XG4gICAgdmFyIHBrID0gSldLLmhlbHBlcnMudW5wYWNrUHJvcHMocHJvcHMsIGZpZWxkcyk7XG4gICAgaWYgKHBrICYmIHBrLmNydiAmJiBway54ICYmIHBrLnkpIHtcbiAgICAgIHBrLmxlbmd0aCA9IGVjdXRpbC5jdXJ2ZVNpemUocGsuY3J2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHBrLmNydjtcbiAgICAgIGRlbGV0ZSBway54O1xuICAgICAgZGVsZXRlIHBrLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBrO1xuICB9LFxuICBwcml2YXRlS2V5OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBmaWVsZHMgPSBKV0suaGVscGVycy5DT01NT05fUFJPUFMuY29uY2F0KFtcbiAgICAgIHtuYW1lOiBcImNydlwiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICAgIHtuYW1lOiBcInhcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJ5XCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwiZFwiLCB0eXBlOiBcImJpbmFyeVwifVxuICAgIF0pO1xuICAgIHZhciBwayA9IEpXSy5oZWxwZXJzLnVucGFja1Byb3BzKHByb3BzLCBmaWVsZHMpO1xuICAgIGlmIChwayAmJiBway5jcnYgJiYgcGsueCAmJiBway55ICYmIHBrLmQpIHtcbiAgICAgIHBrLmxlbmd0aCA9IGVjdXRpbC5jdXJ2ZVNpemUocGsuY3J2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGsgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBrO1xuICB9LFxuICB0aHVtYnByaW50OiBmdW5jdGlvbihqc29uKSB7XG4gICAgaWYgKGpzb24ucHVibGljKSB7XG4gICAgICBqc29uID0ganNvbi5wdWJsaWM7XG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSB7XG4gICAgICBjcnY6IGpzb24uY3J2LFxuICAgICAga3R5OiBcIkVDXCIsXG4gICAgICB4OiBqc29uLngsXG4gICAgICB5OiBqc29uLnlcbiAgICB9O1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH0sXG4gIGFsZ29yaXRobXM6IGZ1bmN0aW9uKGtleXMsIG1vZGUpIHtcbiAgICB2YXIgbGVuID0gKGtleXMucHVibGljICYmIGtleXMucHVibGljLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUubGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAwO1xuICAgIC8vIE5PVEU6IDUyMSBpcyB0aGUgYWN0dWFsLCBidXQgNTEyIGlzIHRoZSBleHBlY3RlZFxuICAgIGlmIChsZW4gPT09IDUyMSkge1xuICAgICAgICBsZW4gPSA1MTI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIFwiZW5jcnlwdFwiOlxuICAgICAgY2FzZSBcImRlY3J5cHRcIjpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgY2FzZSBcIndyYXBcIjpcbiAgICAgICAgcmV0dXJuIChrZXlzLnB1YmxpYyAmJiBXUkFQX0FMR1MpIHx8IFtdO1xuICAgICAgY2FzZSBcInVud3JhcFwiOlxuICAgICAgICByZXR1cm4gKGtleXMucHJpdmF0ZSAmJiBXUkFQX0FMR1MpIHx8IFtdO1xuICAgICAgY2FzZSBcInNpZ25cIjpcbiAgICAgICAgaWYgKCFrZXlzLnByaXZhdGUpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNJR19BTEdTLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIChhID09PSAoXCJFU1wiICsgbGVuKSk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcInZlcmlmeVwiOlxuICAgICAgICBpZiAoIWtleXMucHVibGljKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTSUdfQUxHUy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiAoYSA9PT0gKFwiRVNcIiArIGxlbikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgZW5jcnlwdEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHVibGljO1xuICB9LFxuICBkZWNyeXB0S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlO1xuICB9LFxuXG4gIHdyYXBLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnB1YmxpYztcbiAgfSxcbiAgdW53cmFwS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlO1xuICB9LFxuXG4gIHNpZ25LZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGU7XG4gIH0sXG4gIHZlcmlmeUtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHVibGljO1xuICB9XG59O1xuSldLRWNDZmcuY29udmVydFRvUEVNID0gZWN1dGlsLmNvbnZlcnRUb1BFTTtcblxuLy8gSW5zcGlyZWQgYnkgZGlnaXRhbGJhYXphci9ub2RlLWZvcmdlL2pzL3JzYS5qc1xudmFyIHZhbGlkYXRvcnMgPSB7XG4gIG9pZDogRUNfT0lELFxuICBwcml2YXRlS2V5OiB7XG4gICAgLy8gRUNQcml2YXRlS2V5XG4gICAgbmFtZTogXCJFQ1ByaXZhdGVLZXlcIixcbiAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbXG4gICAgICB7XG4gICAgICAgIC8vIEVDIHZlcnNpb25cbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkudmVyc2lvblwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByaXZhdGUgdmFsdWUgKGQpXG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnByaXZhdGVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIEVDIHBhcmFtZXRlcnNcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucGFyYW1ldGVyc1wiLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBuYW1lZEN1cnZlIChjcnYpXG4gICAgICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5uYW1lZEN1cnZlXCIsXG4gICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0lELFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogXCJjcnZcIlxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHVibGljS2V5XG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnB1YmxpY0tleVwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wb2ludFwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IFwicG9pbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgZW1iZWRkZWRQcml2YXRlS2V5OiB7XG4gICAgLy8gRUNQcml2YXRlS2V5XG4gICAgbmFtZTogXCJFQ1ByaXZhdGVLZXlcIixcbiAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbXG4gICAgICB7XG4gICAgICAgIC8vIEVDIHZlcnNpb25cbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkudmVyc2lvblwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByaXZhdGUgdmFsdWUgKGQpXG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnByaXZhdGVcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHB1YmxpY0tleVxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wdWJsaWNLZXlcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucG9pbnRcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiBcInBvaW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdXG4gIH1cbn07XG5cbnZhciBKV0tFY0ZhY3RvcnkgPSB7XG4gIGt0eTogXCJFQ1wiLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzLFxuICBwcmVwYXJlOiBmdW5jdGlvbihwcm9wcykge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBwcm9wZXJ0aWVzXG4gICAgdmFyIGNmZyA9IEpXS0VjQ2ZnO1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKHByb3BzKTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHJldHVybiBKV0suaGVscGVycy50aHVtYnByaW50KGNmZywganNvbik7XG4gICAgfSk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihoYXNoKSB7XG4gICAgICB2YXIgcHJpbnRzID0ge307XG4gICAgICBwcmludHNbSldLLmhlbHBlcnMuSU5URVJOQUxTLlRIVU1CUFJJTlRfSEFTSF0gPSBoYXNoO1xuICAgICAgcHJvcHNbSldLLmhlbHBlcnMuSU5URVJOQUxTLlRIVU1CUFJJTlRfS0VZXSA9IHByaW50cztcbiAgICAgIHJldHVybiBjZmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH0sXG4gIGdlbmVyYXRlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgdmFyIGtleXBhaXIgPSBkZXBzZWNjLmdlbmVyYXRlS2V5UGFpcihzaXplKTtcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgXCJjcnZcIjogc2l6ZSxcbiAgICAgIFwieFwiOiBrZXlwYWlyLnB1YmxpYy54LFxuICAgICAgXCJ5XCI6IGtleXBhaXIucHVibGljLnksXG4gICAgICBcImRcIjoga2V5cGFpci5wcml2YXRlLmRcbiAgICB9O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgfSxcbiAgaW1wb3J0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh2YWxpZGF0b3JzLm9pZCAhPT0gaW5wdXQua2V5T2lkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjb2VyY2Uga2V5IHBhcmFtcyB0byBPSURcbiAgICB2YXIgY3J2O1xuICAgIGlmIChpbnB1dC5rZXlQYXJhbXMgJiYgZm9yZ2UuYXNuMS5UeXBlLk9JRCA9PT0gaW5wdXQua2V5UGFyYW1zLnR5cGUpIHtcbiAgICAgIGNydiA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoaW5wdXQua2V5UGFyYW1zLnZhbHVlKTtcbiAgICAgIGNydiA9IG9pZFRvQ3VydmVOYW1lKGNydik7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5jcnYpIHtcbiAgICAgIGNydiA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoaW5wdXQuY3J2KTtcbiAgICAgIGNydiA9IG9pZFRvQ3VydmVOYW1lKGNydik7XG4gICAgfVxuICAgIGlmICghY3J2KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWlucHV0LnBhcnNlZCkge1xuICAgICAgdmFyIGNhcHR1cmUgPSB7fSxcbiAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgIGlmIChcInByaXZhdGVcIiA9PT0gaW5wdXQudHlwZSkge1xuICAgICAgICAvLyBjb2VyY2UgY2FwdHVyZS52YWx1ZSB0byBERVIgKmlmZiogcHJpdmF0ZVxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0LmtleVZhbHVlKSB7XG4gICAgICAgICAgaW5wdXQua2V5VmFsdWUgPSBmb3JnZS5hc24xLmZyb21EZXIoaW5wdXQua2V5VmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQua2V5VmFsdWUpKSB7XG4gICAgICAgICAgaW5wdXQua2V5VmFsdWUgPSBpbnB1dC5rZXlWYWx1ZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm9yZ2UuYXNuMS52YWxpZGF0ZShpbnB1dC5rZXlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMuZW1iZWRkZWRQcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZS5wb2ludCA9IGlucHV0LmtleVZhbHVlO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSBjYXB0dXJlO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZmFjdG9ycyB0byBCdWZmZXJzXG4gICAgdmFyIG91dHB1dCA9IHtcbiAgICAgIGt0eTogXCJFQ1wiLFxuICAgICAgY3J2OiBjcnZcbiAgICB9O1xuICAgIGlmIChpbnB1dC5kKSB7XG4gICAgICBvdXRwdXQuZCA9IEJ1ZmZlci5mcm9tKGlucHV0LmQsIFwiYmluYXJ5XCIpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQucG9pbnQpIHtcbiAgICAgIHZhciBwdCA9IEJ1ZmZlci5mcm9tKGlucHV0LnBvaW50LCBcImJpbmFyeVwiKTtcbiAgICAgIC8vIG9ubHkgc3VwcG9ydCB1bmNvbXByZXNzZWRcbiAgICAgIGlmICg0ICE9PSBwdC5yZWFkVUludDE2QkUoMCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBwdCA9IHB0LnNsaWNlKDIpO1xuICAgICAgdmFyIGxlbiA9IHB0Lmxlbmd0aCAvIDI7XG4gICAgICBvdXRwdXQueCA9IHB0LnNsaWNlKDAsIGxlbik7XG4gICAgICBvdXRwdXQueSA9IHB0LnNsaWNlKGxlbik7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG4vLyBwdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICBjb25maWc6IEpXS0VjQ2ZnLFxuICBmYWN0b3J5OiBKV0tFY0ZhY3Rvcnlcbn0pO1xuXG4vLyByZWdpc3RyYXRpb25cbihmdW5jdGlvbihSRUdJU1RSWSkge1xuICBSRUdJU1RSWS5yZWdpc3RlcihKV0tFY0ZhY3RvcnkpO1xufSkocmVxdWlyZShcIi4va2V5c3RvcmVcIikucmVnaXN0cnkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/eckey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/helpers.js - JWK Internal Helper Functions and Constants\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\");\n\nvar ALGORITHMS = __webpack_require__(/*! ../algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\");\n\n// ### ASN.1 Validators\n// Adapted from digitalbazaar/node-forge/js/asn1.js\n// PrivateKeyInfo\nvar privateKeyValidator = {\n  name: \"PrivateKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      // Version (INTEGER)\n      name: \"PrivateKeyInfo.version\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"keyVersion\"\n    },\n    {\n      name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"keyOid\"\n        },\n        {\n          name: \"AlgorithmIdentifier.parameters\",\n          captureAsn1: \"keyParams\"\n        }\n      ]\n    },\n    {\n      name: \"PrivateKeyInfo\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: \"keyValue\"\n    }\n  ]\n};\n// Adapted from digitalbazaar/node-forge/x509.js\nvar publicKeyValidator = {\n  name: \"SubjectPublicKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"keyOid\"\n        },\n        {\n          name: \"AlgorithmIdentifier.parameters\",\n          captureAsn1: \"keyParams\"\n        }\n      ]\n    },\n    {\n      name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.BITSTRING,\n      constructed: false,\n      capture: \"keyValue\"\n    }\n  ]\n};\n// Adapted from digitalbazaar/node-forge/x509.js\nvar X509CertificateValidator = {\n  name: \"Certificate\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      name: \"Certificate.TBSCertificate\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"certificate\",\n      value: [\n        {\n          name: \"Certificate.TBSCertificate.version\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 0,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.version.integer\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.INTEGER,\n              constructed: false,\n              capture: \"certVersion\"\n            }\n          ]\n        },\n        {\n          name: \"Certificate.TBSCertificate.serialNumber\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"certSerialNumber\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.signature\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.signature.algorithm\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.OID,\n              constructed: false,\n              capture: \"certSignatureOid\"\n            }, {\n              name: \"Certificate.TBSCertificate.signature.parameters\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              optional: true,\n              captureAsn1: \"certSignatureParams\"\n            }\n          ]\n        },\n        {\n          name: \"Certificate.TBSCertificate.issuer\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certIssuer\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.validity\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          // Note: UTC and generalized times may both appear so the capture\n          // names are based on their detected order, the names used below\n          // are only for the common case, which validity time really means\n          // \"notBefore\" and which means \"notAfter\" will be determined by order\n          value: [\n            {\n              // notBefore (Time) (UTC time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (utc)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity1UTCTime\"\n            },\n            {\n              // notBefore (Time) (generalized time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (generalized)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity2GeneralizedTime\"\n            },\n            {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (utc)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity3UTCTime\"\n            },\n            {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (generalized)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity4GeneralizedTime\"\n            }\n          ]\n        }, {\n          // Name (subject) (RDNSequence)\n          name: \"Certificate.TBSCertificate.subject\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certSubject\"\n        },\n        // SubjectPublicKeyInfo\n        publicKeyValidator,\n        {\n          // issuerUniqueID (optional)\n          name: \"Certificate.TBSCertificate.issuerUniqueID\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 1,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.issuerUniqueID.id\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.BITSTRING,\n              constructed: false,\n              capture: \"certIssuerUniqueId\"\n            }\n          ]\n        },\n        {\n          // subjectUniqueID (optional)\n          name: \"Certificate.TBSCertificate.subjectUniqueID\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 2,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.subjectUniqueID.id\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.BITSTRING,\n              constructed: false,\n              capture: \"certSubjectUniqueId\"\n            }\n          ]\n        },\n        {\n          // Extensions (optional)\n          name: \"Certificate.TBSCertificate.extensions\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 3,\n          constructed: true,\n          captureAsn1: \"certExtensions\",\n          optional: true\n        }\n      ]\n    },\n    {\n      // AlgorithmIdentifier (signature algorithm)\n      name: \"Certificate.signatureAlgorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          // algorithm\n          name: \"Certificate.signatureAlgorithm.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"certSignatureOid\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.signature.parameters\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          optional: true,\n          captureAsn1: \"certSignatureParams\"\n        }\n      ]\n    },\n    {\n      // SignatureValue\n      name: \"Certificate.signatureValue\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.BITSTRING,\n      constructed: false,\n      capture: \"certSignature\"\n    }\n  ]\n};\n\nvar INTERNALS = {\n  THUMBPRINT_KEY: \"internal\\u0000thumbprint\",\n  THUMBPRINT_HASH: \"SHA-256\"\n};\n\nmodule.exports = {\n  validators: {\n    privateKey: privateKeyValidator,\n    publicKey: publicKeyValidator,\n    certificate: X509CertificateValidator\n  },\n\n  thumbprint: function(cfg, json, hash) {\n    if (\"function\" !== typeof cfg.thumbprint) {\n      return Promise.reject(new Error(\"thumbprint not supported\"));\n    }\n\n    hash = (hash || INTERNALS.THUMBPRINT_HASH).toUpperCase();\n    var fields = cfg.thumbprint(json);\n    var input = Object.keys(fields).\n                sort().\n                map(function(k) {\n      var v = fields[k];\n      if (Buffer.isBuffer(v)) {\n        v = util.base64url.encode(v);\n      }\n      return JSON.stringify(k) + \":\" + JSON.stringify(v);\n    });\n    input = \"{\" + input.join(\",\") + \"}\";\n    try {\n      return ALGORITHMS.digest(hash, Buffer.from(input, \"utf8\"));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  },\n  unpackProps: function(props, allowed) {\n    var output;\n\n    // apply all of the existing values\n    allowed.forEach(function(cfg) {\n      if (!(cfg.name in props)) {\n        return;\n      }\n      output = output || {};\n      var value = props[cfg.name];\n      switch (cfg.type) {\n        case \"binary\":\n          if (Buffer.isBuffer(value)) {\n            props[cfg.name] = util.base64url.encode(value);\n          } else {\n            value = util.base64url.decode(value);\n          }\n          break;\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          break;\n        case \"array\":\n          value = [].concat(value);\n          break;\n        case \"object\":\n          value = clone(value);\n          break;\n        default:\n          // TODO: deep clone?\n          break;\n      }\n      output[cfg.name] = value;\n    });\n\n    // remove any from json that didn't apply\n    var check = output || {};\n    Object.keys(props).\n           forEach(function(n) {\n              if (n in check) { return; }\n              delete props[n];\n           });\n\n    return output;\n  },\n  COMMON_PROPS: [\n    {name: \"kty\", type: \"string\"},\n    {name: \"kid\", type: \"string\"},\n    {name: \"use\", type: \"string\"},\n    {name: \"alg\", type: \"string\"},\n    {name: \"x5c\", type: \"array\"},\n    {name: \"x5t\", type: \"binary\"},\n    {name: \"x5u\", type: \"string\"},\n    {name: \"key_ops\", type: \"array\"}\n  ],\n  INTERNALS: INTERNALS\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBEQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMsdUVBQWU7O0FBRW5DLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLFlBQVk7O0FBRVo7QUFDQSxHQUFHO0FBQ0g7QUFDQSxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDJCQUEyQjtBQUNoQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9oZWxwZXJzLmpzP2YyMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svaGVscGVycy5qcyAtIEpXSyBJbnRlcm5hbCBIZWxwZXIgRnVuY3Rpb25zIGFuZCBDb25zdGFudHNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZVwiKTtcblxudmFyIEFMR09SSVRITVMgPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtc1wiKTtcblxuLy8gIyMjIEFTTi4xIFZhbGlkYXRvcnNcbi8vIEFkYXB0ZWQgZnJvbSBkaWdpdGFsYmF6YWFyL25vZGUtZm9yZ2UvanMvYXNuMS5qc1xuLy8gUHJpdmF0ZUtleUluZm9cbnZhciBwcml2YXRlS2V5VmFsaWRhdG9yID0ge1xuICBuYW1lOiBcIlByaXZhdGVLZXlJbmZvXCIsXG4gIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFtcbiAgICB7XG4gICAgICAvLyBWZXJzaW9uIChJTlRFR0VSKVxuICAgICAgbmFtZTogXCJQcml2YXRlS2V5SW5mby52ZXJzaW9uXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IFwia2V5VmVyc2lvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcIlByaXZhdGVLZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG1cIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgdmFsdWU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5hbGdvcml0aG1cIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJrZXlPaWRcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJBbGdvcml0aG1JZGVudGlmaWVyLnBhcmFtZXRlcnNcIixcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJrZXlQYXJhbXNcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcIlByaXZhdGVLZXlJbmZvXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0NURVRTVFJJTkcsXG4gICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICBjYXB0dXJlOiBcImtleVZhbHVlXCJcbiAgICB9XG4gIF1cbn07XG4vLyBBZGFwdGVkIGZyb20gZGlnaXRhbGJhemFhci9ub2RlLWZvcmdlL3g1MDkuanNcbnZhciBwdWJsaWNLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6IFwiU3ViamVjdFB1YmxpY0tleUluZm9cIixcbiAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwiU3ViamVjdFB1YmxpY0tleUluZm8uQWxnb3JpdGhtSWRlbnRpZmllclwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImtleU9pZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVyc1wiLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImtleVBhcmFtc1wiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiU3ViamVjdFB1YmxpY0tleUluZm8uc3ViamVjdFB1YmxpY0tleVwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IFwia2V5VmFsdWVcIlxuICAgIH1cbiAgXVxufTtcbi8vIEFkYXB0ZWQgZnJvbSBkaWdpdGFsYmF6YWFyL25vZGUtZm9yZ2UveDUwOS5qc1xudmFyIFg1MDlDZXJ0aWZpY2F0ZVZhbGlkYXRvciA9IHtcbiAgbmFtZTogXCJDZXJ0aWZpY2F0ZVwiLFxuICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZVwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0aWZpY2F0ZVwiLFxuICAgICAgdmFsdWU6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvblwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgdHlwZTogMCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZlcnNpb24uaW50ZWdlclwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZlcnNpb25cIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2VyaWFsTnVtYmVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImNlcnRTZXJpYWxOdW1iZXJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmVcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLmFsZ29yaXRobVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0U2lnbmF0dXJlT2lkXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUucGFyYW1ldGVyc1wiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0U2lnbmF0dXJlUGFyYW1zXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydElzc3VlclwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5XCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICAvLyBOb3RlOiBVVEMgYW5kIGdlbmVyYWxpemVkIHRpbWVzIG1heSBib3RoIGFwcGVhciBzbyB0aGUgY2FwdHVyZVxuICAgICAgICAgIC8vIG5hbWVzIGFyZSBiYXNlZCBvbiB0aGVpciBkZXRlY3RlZCBvcmRlciwgdGhlIG5hbWVzIHVzZWQgYmVsb3dcbiAgICAgICAgICAvLyBhcmUgb25seSBmb3IgdGhlIGNvbW1vbiBjYXNlLCB3aGljaCB2YWxpZGl0eSB0aW1lIHJlYWxseSBtZWFuc1xuICAgICAgICAgIC8vIFwibm90QmVmb3JlXCIgYW5kIHdoaWNoIG1lYW5zIFwibm90QWZ0ZXJcIiB3aWxsIGJlIGRldGVybWluZWQgYnkgb3JkZXJcbiAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBub3RCZWZvcmUgKFRpbWUpIChVVEMgdGltZSBjYXNlKVxuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAodXRjKVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5VVENUSU1FLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRWYWxpZGl0eTFVVENUaW1lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKGdlbmVyYWxpemVkIHRpbWUgY2FzZSlcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RCZWZvcmUgKGdlbmVyYWxpemVkKVwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5HRU5FUkFMSVpFRFRJTUUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZhbGlkaXR5MkdlbmVyYWxpemVkVGltZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyICh1dGMpXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlVUQ1RJTUUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZhbGlkaXR5M1VUQ1RpbWVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gbm90QWZ0ZXIgKFRpbWUpIChvbmx5IFVUQyB0aW1lIGlzIHN1cHBvcnRlZClcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52YWxpZGl0eS5ub3RBZnRlciAoZ2VuZXJhbGl6ZWQpXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmFsaWRpdHk0R2VuZXJhbGl6ZWRUaW1lXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAvLyBOYW1lIChzdWJqZWN0KSAoUkROU2VxdWVuY2UpXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0XCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0U3ViamVjdFwiXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFN1YmplY3RQdWJsaWNLZXlJbmZvXG4gICAgICAgIHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICAgICAge1xuICAgICAgICAgIC8vIGlzc3VlclVuaXF1ZUlEIChvcHRpb25hbClcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLmlzc3VlclVuaXF1ZUlEXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICB0eXBlOiAxLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSUQuaWRcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydElzc3VlclVuaXF1ZUlkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBzdWJqZWN0VW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlEXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc3ViamVjdFVuaXF1ZUlELmlkXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRTdWJqZWN0VW5pcXVlSWRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIEV4dGVuc2lvbnMgKG9wdGlvbmFsKVxuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuZXh0ZW5zaW9uc1wiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0RXh0ZW5zaW9uc1wiLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIEFsZ29yaXRobUlkZW50aWZpZXIgKHNpZ25hdHVyZSBhbGdvcml0aG0pXG4gICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobVwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgLy8gYWxnb3JpdGhtXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5zaWduYXR1cmVBbGdvcml0aG0uYWxnb3JpdGhtXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFNpZ25hdHVyZU9pZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRTaWduYXR1cmVQYXJhbXNcIlxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBTaWduYXR1cmVWYWx1ZVxuICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5zaWduYXR1cmVWYWx1ZVwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IFwiY2VydFNpZ25hdHVyZVwiXG4gICAgfVxuICBdXG59O1xuXG52YXIgSU5URVJOQUxTID0ge1xuICBUSFVNQlBSSU5UX0tFWTogXCJpbnRlcm5hbFxcdTAwMDB0aHVtYnByaW50XCIsXG4gIFRIVU1CUFJJTlRfSEFTSDogXCJTSEEtMjU2XCJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2YWxpZGF0b3JzOiB7XG4gICAgcHJpdmF0ZUtleTogcHJpdmF0ZUtleVZhbGlkYXRvcixcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleVZhbGlkYXRvcixcbiAgICBjZXJ0aWZpY2F0ZTogWDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yXG4gIH0sXG5cbiAgdGh1bWJwcmludDogZnVuY3Rpb24oY2ZnLCBqc29uLCBoYXNoKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNmZy50aHVtYnByaW50KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidGh1bWJwcmludCBub3Qgc3VwcG9ydGVkXCIpKTtcbiAgICB9XG5cbiAgICBoYXNoID0gKGhhc2ggfHwgSU5URVJOQUxTLlRIVU1CUFJJTlRfSEFTSCkudG9VcHBlckNhc2UoKTtcbiAgICB2YXIgZmllbGRzID0gY2ZnLnRodW1icHJpbnQoanNvbik7XG4gICAgdmFyIGlucHV0ID0gT2JqZWN0LmtleXMoZmllbGRzKS5cbiAgICAgICAgICAgICAgICBzb3J0KCkuXG4gICAgICAgICAgICAgICAgbWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciB2ID0gZmllbGRzW2tdO1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICB2ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGspICsgXCI6XCIgKyBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICB9KTtcbiAgICBpbnB1dCA9IFwie1wiICsgaW5wdXQuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFMR09SSVRITVMuZGlnZXN0KGhhc2gsIEJ1ZmZlci5mcm9tKGlucHV0LCBcInV0ZjhcIikpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuICB9LFxuICB1bnBhY2tQcm9wczogZnVuY3Rpb24ocHJvcHMsIGFsbG93ZWQpIHtcbiAgICB2YXIgb3V0cHV0O1xuXG4gICAgLy8gYXBwbHkgYWxsIG9mIHRoZSBleGlzdGluZyB2YWx1ZXNcbiAgICBhbGxvd2VkLmZvckVhY2goZnVuY3Rpb24oY2ZnKSB7XG4gICAgICBpZiAoIShjZmcubmFtZSBpbiBwcm9wcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3V0cHV0ID0gb3V0cHV0IHx8IHt9O1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbY2ZnLm5hbWVdO1xuICAgICAgc3dpdGNoIChjZmcudHlwZSkge1xuICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHByb3BzW2NmZy5uYW1lXSA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5iYXNlNjR1cmwuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICB2YWx1ZSA9IGNsb25lKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUT0RPOiBkZWVwIGNsb25lP1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3V0cHV0W2NmZy5uYW1lXSA9IHZhbHVlO1xuICAgIH0pO1xuXG4gICAgLy8gcmVtb3ZlIGFueSBmcm9tIGpzb24gdGhhdCBkaWRuJ3QgYXBwbHlcbiAgICB2YXIgY2hlY2sgPSBvdXRwdXQgfHwge307XG4gICAgT2JqZWN0LmtleXMocHJvcHMpLlxuICAgICAgICAgICBmb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgaWYgKG4gaW4gY2hlY2spIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1tuXTtcbiAgICAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuICBDT01NT05fUFJPUFM6IFtcbiAgICB7bmFtZTogXCJrdHlcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAge25hbWU6IFwia2lkXCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgIHtuYW1lOiBcInVzZVwiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICB7bmFtZTogXCJhbGdcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAge25hbWU6IFwieDVjXCIsIHR5cGU6IFwiYXJyYXlcIn0sXG4gICAge25hbWU6IFwieDV0XCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgIHtuYW1lOiBcIng1dVwiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICB7bmFtZTogXCJrZXlfb3BzXCIsIHR5cGU6IFwiYXJyYXlcIn1cbiAgXSxcbiAgSU5URVJOQUxTOiBJTlRFUk5BTFNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * jwk/index.js - JSON Web Key (JWK) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWKStore = __webpack_require__(/*! ./keystore.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\");\n\n// Public API -- Key and KeyStore methods\nObject.keys(JWKStore.KeyStore).forEach(function(name) {\n  exports[name] = JWKStore.KeyStore[name];\n});\n\n// Public API -- constants\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/constants.js\");\nObject.keys(CONSTANTS).forEach(function(name) {\n  exports[name] = CONSTANTS[name];\n});\n\n// Registered Key Types\n__webpack_require__(/*! ./octkey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/octkey.js\");\n__webpack_require__(/*! ./rsakey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js\");\n__webpack_require__(/*! ./eckey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/eckey.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx5RUFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN4QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1CQUFPLENBQUMscUVBQWE7QUFDckIsbUJBQU8sQ0FBQyxxRUFBYTtBQUNyQixtQkFBTyxDQUFDLG1FQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9pbmRleC5qcz9kNjc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL2luZGV4LmpzIC0gSlNPTiBXZWIgS2V5IChKV0spIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBKV0tTdG9yZSA9IHJlcXVpcmUoXCIuL2tleXN0b3JlLmpzXCIpO1xuXG4vLyBQdWJsaWMgQVBJIC0tIEtleSBhbmQgS2V5U3RvcmUgbWV0aG9kc1xuT2JqZWN0LmtleXMoSldLU3RvcmUuS2V5U3RvcmUpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gSldLU3RvcmUuS2V5U3RvcmVbbmFtZV07XG59KTtcblxuLy8gUHVibGljIEFQSSAtLSBjb25zdGFudHNcbnZhciBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG5PYmplY3Qua2V5cyhDT05TVEFOVFMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBleHBvcnRzW25hbWVdID0gQ09OU1RBTlRTW25hbWVdO1xufSk7XG5cbi8vIFJlZ2lzdGVyZWQgS2V5IFR5cGVzXG5yZXF1aXJlKFwiLi9vY3RrZXkuanNcIik7XG5yZXF1aXJlKFwiLi9yc2FrZXkuanNcIik7XG5yZXF1aXJlKFwiLi9lY2tleS5qc1wiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/keystore.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/keystore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/keystore.js - JWK KeyStore Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\n/**\n * @class JWK.KeyStoreRegistry\n * @classdesc\n * A registry of JWK.Key types that can be used.\n *\n * @description\n * **NOTE:** This constructor cannot be called directly. Instead use the\n * global {JWK.registry}\n */\nvar JWKRegistry = function() {\n  var types = {};\n\n  Object.defineProperty(this, \"register\", {\n    value: function(factory) {\n      if (!factory || \"string\" !== typeof factory.kty || !factory.kty) {\n        throw new Error(\"invalid Key factory\");\n      }\n\n      var kty = factory.kty;\n      types[kty] = factory;\n      return this;\n    }\n  });\n  Object.defineProperty(this, \"unregister\", {\n    value: function(factory) {\n      if (!factory || \"string\" !== typeof factory.kty || !factory.kty) {\n        throw new Error(\"invalid Key factory\");\n      }\n\n      var kty = factory.kty;\n      if (factory === types[kty]) {\n        delete types[kty];\n      }\n      return this;\n    }\n  });\n\n  Object.defineProperty(this, \"get\", {\n    value: function(kty) {\n      return types[kty || \"\"] || undefined;\n    }\n  });\n  Object.defineProperty(this, \"all\", {\n    value: function() {\n      return Object.keys(types).map(function(t) { return types[t]; });\n    }\n  });\n};\n\n// Globals\nvar GLOBAL_REGISTRY = new JWKRegistry();\n\n// importer\nfunction processCert(input) {\n  // convert certIssuer to readable attributes\n  [\"certIssuer\", \"certSubject\"].forEach(function(field) {\n    /* eslint new-cap: [0] */\n    var attrs = forge.pki.RDNAttributesAsArray(input[field]);\n    var result = input[field] = {};\n    attrs.forEach(function(a) {\n      result[a.name || a.type] = a.value;\n    });\n  });\n\n  return input;\n}\n\nfunction fromPEM(input) {\n  var result = {};\n  var pems = forge.pem.decode(input);\n  var found = pems.some(function(p) {\n    switch (p.type) {\n      case \"CERTIFICATE\":\n        result.form = \"pkix\";\n        break;\n      case \"PUBLIC KEY\":\n        result.form = \"spki\";\n        break;\n      case \"PRIVATE KEY\":\n        result.form = \"pkcs8\";\n        break;\n      case \"EC PRIVATE KEY\":\n        /* eslint no-fallthrough: [0] */\n      case \"RSA PRIVATE KEY\":\n        result.form = \"private\";\n        break;\n      default:\n        return false;\n    }\n\n    result.body = p.body;\n    return true;\n  });\n  if (!found) {\n    throw new Error(\"supported PEM type not found\");\n  }\n  return result;\n}\nfunction importFrom(registry, input) {\n  // form can be one of:\n  //  'private' | 'pkcs8' | 'public' | 'spki' | 'pkix' | 'x509'\n  var capture = {},\n      errors = [],\n      result;\n\n  // conver from DER to ASN1\n  var form = input.form,\n      der = input.body,\n      thumbprint = null;\n  input = forge.asn1.fromDer(der);\n  switch(form) {\n    case \"private\":\n      registry.all().some(function(factory) {\n        if (result) {\n          return false;\n        }\n        if (!factory.validators) {\n          return false;\n        }\n\n        var oid = factory.validators.oid,\n            validator = factory.validators.privateKey;\n        if (!validator) {\n          return false;\n        }\n        capture = {};\n        errors = [];\n        result = forge.asn1.validate(input, validator, capture, errors);\n        if (result) {\n          capture.keyOid = forge.asn1.oidToDer(oid);\n          capture.parsed = true;\n        }\n        return result;\n      });\n      capture.type = \"private\";\n      break;\n    case \"pkcs8\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.privateKey, capture, errors);\n      capture.type = \"private\";\n      break;\n    case \"public\":\n      // eslint no-fallthrough: [0] */\n    case \"spki\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.publicKey, capture, errors);\n      capture.type = \"public\";\n      break;\n    case \"pkix\":\n      /* eslint no-fallthrough: [0] */\n    case \"x509\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.certificate, capture, errors);\n      if (result) {\n        capture = processCert(capture);\n        var md = forge.md.sha1.create();\n        md.update(der);\n        thumbprint = util.base64url.encode(Buffer.from(md.digest().toHex(), \"hex\"));\n      }\n      capture.type = \"public\";\n      break;\n  }\n  if (!result) {\n    return null;\n  }\n\n  // convert oids\n  if (capture.keyOid) {\n    capture.keyOid = forge.asn1.derToOid(capture.keyOid);\n  }\n\n  // find and invoke the importer\n  result = null;\n  GLOBAL_REGISTRY.all().forEach(function(factory) {\n    if (result) {\n      return;\n    }\n    if (!factory) {\n      return;\n    }\n    if (\"function\" !== typeof factory.import) {\n      return;\n    }\n    result = factory.import(capture);\n  });\n  if (result && capture.certSubject && capture.certSubject.commonName) {\n    result.kid = capture.certSubject.commonName;\n  }\n  if (result && thumbprint) {\n    result.x5t = thumbprint;\n  }\n  return result;\n}\n\n/**\n * @class JWK.KeyStore\n * @classdesc\n * Represents a collection of Keys.\n *\n * @description\n * **NOTE:** This constructor cannot be called directly. Instead call {@link\n * JWK.createKeyStore}.\n */\nvar JWKStore = function(registry, parent) {\n  var keysets = {};\n\n  /**\n   * @method JWK.KeyStore#generate\n   * @description\n   * Generates a new random Key into this KeyStore.\n   *\n   * The type of {size} depends on the value of {kty}:\n   *\n   * + **`EC`**: String naming the curve to use, which can be one of:\n   *   `\"P-256\"`, `\"P-384\"`, or `\"P-521\"` (default is **`\"P-256\"`**).\n   * + **`RSA`**: Number describing the size of the key, in bits (default is\n   *   **`2048`**).\n   * + **`oct`**: Number describing the size of the key, in bits (default is\n   *   **`256`**).\n   *\n   * Any properties in {props} are applied before the key is generated,\n   * and are expected to be data types acceptable in JSON.  This allows the\n   * generated key to have a specific key identifier, or to specify its\n   * acceptable usage.\n   *\n   * The returned Promise, when fulfilled, returns the generated Key.\n   *\n   * @param {String} kty The type of generated key\n   * @param {String|Number} [size] The size of the generated key\n   * @param {Object} [props] Additional properties to apply to the generated\n   *        key.\n   * @returns {Promise} The promise for the generated Key\n   * @throws {Error} If {kty} is not supported\n   */\n  Object.defineProperty(this, \"generate\", {\n    value: function(kty, size, props) {\n      var keytype = registry.get(kty);\n      if (!keytype) {\n        return Promise.reject(new Error(\"unsupported key type\"));\n      }\n\n      props = clone(props || {});\n      props.kty = kty;\n\n      var self = this,\n          promise = keytype.generate(size);\n      return promise.then(function(jwk) {\n        jwk = merge(props, jwk, {\n          kty: kty\n        });\n        return self.add(jwk);\n      });\n    }\n  });\n  /**\n   * @method JWK.KeyStore#add\n   * @description\n   * Adds a Key to this KeyStore. If {jwk} is a string, it is first\n   * parsed into a plain JSON object. If {jwk} is already an instance\n   * of JWK.Key, its (public) JSON representation is first obtained\n   * then applied to a new JWK.Key object within this KeyStore.\n   *\n   * @param {String|Object} jwk The JSON Web Key (JWK)\n   * @param {String} [form] The format of a String key to expect\n   * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg \"pem\")\n   * @returns {Promise} The promise for the added key\n   */\n  Object.defineProperty(this, \"add\", {\n    value: function(jwk, form, extras) {\n      extras = extras || {};\n\n      var factors;\n      if (Buffer.isBuffer(jwk) || typeof jwk === \"string\") {\n        // form can be 'json', 'pkcs8', 'spki', 'pkix', 'x509', 'pem'\n        form = (form || \"json\").toLowerCase();\n        if (\"json\" === form) {\n          jwk = JSON.parse(jwk.toString(\"utf8\"));\n        } else {\n          try {\n            if (\"pem\" === form) {\n              // convert *first* PEM -> DER\n              factors = fromPEM(jwk);\n            } else {\n              factors = {\n                body: jwk.toString(\"binary\"),\n                form: form\n              };\n            }\n            jwk = importFrom(registry, factors);\n            if (!jwk) {\n              throw new Error(\"no importer for key\");\n            }\n            Object.keys(extras).forEach(function(field){\n              jwk[field] = extras[field];\n            });\n          } catch (err) {\n            return Promise.reject(err);\n          }\n        }\n      } else if (JWKStore.isKey(jwk)) {\n        // assume a complete duplicate is desired\n        jwk = jwk.toJSON(true);\n      } else {\n        jwk = clone(jwk);\n      }\n\n      var keytype = registry.get(jwk.kty);\n      if (!keytype) {\n        return Promise.reject(new Error(\"unsupported key type\"));\n      }\n\n      var self = this,\n          promise = keytype.prepare(jwk);\n      return promise.then(function(cfg) {\n        return new JWK.BaseKey(jwk.kty, self, jwk, cfg);\n      }).then(function(jwk) {\n        var kid = jwk.kid || \"\";\n        var keys = keysets[kid] = keysets[kid] || [];\n        keys.push(jwk);\n\n        return jwk;\n      });\n    }\n  });\n  /**\n   * @method JWK.KeyStore#remove\n   * @description\n   * Removes a Key from this KeyStore.\n   *\n   * **NOTE:** The removed Key's {keystore} property is not changed.\n   *\n   * @param {JWK.Key} jwk The key to remove.\n   */\n  Object.defineProperty(this, \"remove\", {\n    value: function(jwk) {\n      if (!jwk) {\n        return;\n      }\n\n      var keys = keysets[jwk.kid];\n      if (!keys) {\n        return;\n      }\n\n      var pos = keys.indexOf(jwk);\n      if (pos === -1) {\n        return;\n      }\n\n      keys.splice(pos, 1);\n      if (!keys.length) {\n        delete keysets[jwk.kid];\n      }\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#all\n   * @description\n   * Retrieves all of the contained Keys that optinally match all of the\n   * given properties.\n   *\n   * If {props} are specified, this method only returns Keys which exactly\n   * match the given properties. The properties can be any of the\n   * following:\n   *\n   * + **alg**: The algorithm for the Key.\n   * + **use**: The usage for the Key.\n   * + **kid**: The identifier for the Key.\n   *\n   * If no properties are given, this method returns all of the Keys for this\n   * KeyStore.\n   *\n   * @param {Object} [props] The properties to match against\n   * @param {Boolean} [local = false] `true` if only the Keys\n   *        directly contained by this KeyStore should be returned, or\n   *        `false` if it should return all Keys of this KeyStore and\n   *        its ancestors.\n   * @returns {JWK.Key[]} The list of matching Keys, or an empty array if no\n   *          matches are found.\n   */\n  Object.defineProperty(this, \"all\", {\n    value: function(props, local) {\n      props = props || {};\n\n      // workaround for issues/109\n      if (props.kid !== undefined && props.kid !== null && typeof props.kid !== \"string\") {\n        props.kid = String(props.kid);\n      }\n\n      var candidates = [];\n      var matches = function(key) {\n        // match on 'kty'\n        if (props.kty &&\n            key.kty &&\n            props.kty !== key.kty) {\n          return false;\n        }\n        // match on 'use'\n        if (props.use &&\n            key.use &&\n            props.use !== key.use) {\n          return false;\n        }\n        // match on 'alg'\n        if (props.alg) {\n          if (props.alg !== \"dir\" &&\n              key.alg &&\n              props.alg !== key.alg) {\n            return false;\n          }\n          return key.supports(props.alg);\n        }\n        //TODO: match on 'key_ops'\n\n        return true;\n      };\n      Object.keys(keysets).forEach(function(id) {\n        if (props.kid && props.kid !== id) {\n          return;\n        }\n\n        var keys = keysets[id].filter(matches);\n        if (keys.length) {\n          candidates = candidates.concat(keys);\n        }\n      });\n\n      if (!local && parent) {\n        candidates = candidates.concat(parent.all(props));\n      }\n\n      return candidates;\n    }\n  });\n  /**\n   * @method JWK.KeyStore#get\n   * @description\n   * Retrieves the contained Key matching the given {kid}, and optionally\n   * all of the given properties.  This method equivalent to calling\n   * {@link JWK.Store#all}, then returning the first Key whose\n   * \"kid\" is {kid}. If {kid} is undefined, then the first Key that\n   * is returned from `all()` is returned.\n   *\n   * @param {String} [kid] The key identifier to match against.\n   * @param {Object} [props] The properties to match against.\n   * @param {Boolean} [local = false] `true` if only the Keys\n   *        directly contained by this KeyStore should be returned, or\n   *        `false` if it should return all Keys of this KeyStore and\n   *        its ancestors.\n   * @returns {JWK.Key} The Key matching {kid} and {props}, or `null`\n   *          if no match is found.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(kid, props, local) {\n      // reconcile arguments\n      if (typeof kid === \"boolean\") {\n        local = kid;\n        props = kid = null;\n      } else if (typeof kid === \"object\") {\n        local = props;\n        props = kid;\n        kid = null;\n      }\n\n      // fixup props\n      props = props || {};\n      if (kid) {\n        props.kid = kid;\n      }\n\n      // workaround for issues/109\n      if (props.kid !== undefined && props.kid !== null && typeof props.kid !== \"string\") {\n       props.kid = String(props.kid);\n      }\n\n      var candidates = this.all(props, true);\n      if (!candidates.length && parent && !local) {\n        candidates = parent.get(props, local);\n      }\n      return candidates[0] || null;\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#temp\n   * @description\n   * Creates a temporary KeyStore based on this KeyStore.\n   *\n   * @returns {JWK.KeyStore} The temporary KeyStore.\n   */\n  Object.defineProperty(this, \"temp\", {\n    value: function() {\n      return new JWKStore(registry, this);\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#toJSON\n   * @description\n   * Generates a JSON representation of this KeyStore, which conforms\n   * to a JWK Set from {I-D.ietf-jose-json-web-key}.\n   *\n   * @param {Boolean} [isPrivate = false] `true` if the private fields\n   *        of stored keys are to be included.\n   * @returns {Object} The JSON representation of this KeyStore.\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate) {\n      var keys = [];\n\n      Object.keys(keysets).forEach(function(kid) {\n        var items = keysets[kid].map(function(k) {\n          return k.toJSON(isPrivate);\n        });\n        keys = keys.concat(items);\n      });\n\n      return {\n        keys: keys\n      };\n    }\n  });\n};\n\n/**\n * Determines if the given object is an instance of JWK.KeyStore.\n *\n * @param {Object} obj The object to test\n * @returns {Boolean} `true` if {obj} is an instance of JWK.KeyStore,\n *          and `false` otherwise.\n */\nJWKStore.isKeyStore = function(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (\"object\" !== typeof obj) {\n    return false;\n  }\n\n  if (\"function\" !== typeof obj.get ||\n      \"function\" !== typeof obj.all ||\n      \"function\" !== typeof obj.generate ||\n      \"function\" !== typeof obj.add ||\n      \"function\" !== typeof obj.remove) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Creates a new empty KeyStore.\n *\n * @returns {JWK.KeyStore} The empty KeyStore.\n */\nJWKStore.createKeyStore = function() {\n  return new JWKStore(GLOBAL_REGISTRY);\n};\n\n/**\n * Coerces the given object into a KeyStore. This method uses the following\n * algorithm to coerce {ks}:\n *\n * 1. if {ks} is an instance of JWK.KeyStore, it is returned directly\n * 2. if {ks} is a string, it is parsed into a JSON value\n * 3. if {ks} is an array, it creates a new JWK.KeyStore and calls {@link\n *    JWK.KeyStore#add} for each element in the {ks} array.\n * 4. if {ks} is a JSON object, it creates a new JWK.KeyStore and calls {@link\n *    JWK.KeyStore#add} for each element in the \"keys\" property.\n *\n * @param {Object|String} ks The value to coerce into a\n *        KeyStore\n * @returns {Promise(JWK.KeyStore)} A promise for the coerced KeyStore.\n */\nJWKStore.asKeyStore = function(ks) {\n  if (JWKStore.isKeyStore(ks)) {\n    return Promise.resolve(ks);\n  }\n\n  var store = JWKStore.createKeyStore(),\n      keys;\n\n  if (typeof ks === \"string\") {\n    ks = JSON.parse(ks);\n  }\n\n  if (Array.isArray(ks)) {\n    keys = ks;\n  } else if (\"keys\" in ks) {\n    keys = ks.keys;\n  } else {\n    return Promise.reject(new Error(\"invalid keystore\"));\n  }\n\n  keys = keys.map(function(k) {\n    return store.add(k);\n  });\n\n  var promise = Promise.all(keys);\n  promise = promise.then(function() {\n    return store;\n  });\n\n  return promise;\n};\n\n\n/**\n * Determines if the given object is a JWK.Key instance.\n *\n * @param {Object} obj The object to test\n * @returns `true` if {obj} is a JWK.Key\n */\nJWKStore.isKey = function(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (\"object\" !== typeof obj) {\n    return false;\n  }\n\n  if (!JWKStore.isKeyStore(obj.keystore)) {\n    return false;\n  }\n\n  if (\"string\" !== typeof obj.kty ||\n      \"number\" !== typeof obj.length ||\n      \"function\" !== typeof obj.algorithms ||\n      \"function\" !== typeof obj.supports ||\n      \"function\" !== typeof obj.encrypt ||\n      \"function\" !== typeof obj.decrypt ||\n      \"function\" !== typeof obj.wrap ||\n      \"function\" !== typeof obj.unwrap ||\n      \"function\" !== typeof obj.sign ||\n      \"function\" !== typeof obj.verify) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Creates a new key with the given properties.  This method is a convenience\n * to calling `JWK.createKeyStore()` then `generate()` on the returned keystore.\n *\n * @param {String} kty The type of generated key\n * @param {String|Number} [size] The size of the generated key\n * @param {Object} [props] Additional properties to apply to the generated\n *        key.\n * @returns {Promise} The promise for the generated Key\n * @throws {Error} If {kty} is not supported\n * @see JWKStore#generate\n */\nJWKStore.createKey = function(kty, size, props) {\n  var ks = JWKStore.createKeyStore();\n  return ks.generate(kty, size, props);\n}\n\n/**\n * Coerces the given object into a Key. If {key} is an instance of JWK.Key,\n * it is returned directly. Otherwise, this method first creates a new\n * JWK.KeyStore and calls {@link JWK.KeyStore#add} on this new KeyStore.\n *\n * @param {Object|String} key The value to coerce into a Key\n * @param {String} [form] The format of a String Key to expect\n * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg \"pem\")\n * @returns {Promise(JWK.Key)} A promise for the coerced Key.\n */\nJWKStore.asKey = function(key, form, extras) {\n  if (JWKStore.isKey(key)) {\n    return Promise.resolve(key);\n  }\n\n  var ks = JWKStore.createKeyStore();\n  key = ks.add(key, form, extras);\n\n  return key;\n};\n\nmodule.exports = {\n  KeyRegistry: JWKRegistry,\n  KeyStore: JWKStore,\n  registry: GLOBAL_REGISTRY\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2sva2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxZQUFZLG1CQUFPLENBQUMsdUVBQWU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUzs7QUFFNUI7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSx5QkFBeUIsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQywwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCLGVBQWUsSUFBSSxNQUFNLEtBQUs7QUFDOUI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUyxrQkFBa0IsS0FBSyxLQUFLLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTLFdBQVcsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLFVBQVUsSUFBSTtBQUNkLFVBQVUsSUFBSTtBQUNkLFVBQVUsSUFBSSxzREFBc0Q7QUFDcEUsd0JBQXdCLHlCQUF5QixJQUFJO0FBQ3JELFVBQVUsSUFBSSwyREFBMkQ7QUFDekUsd0JBQXdCO0FBQ3hCO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsWUFBWSxPQUFPLElBQUksS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9rZXlzdG9yZS5qcz81ZTkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL2tleXN0b3JlLmpzIC0gSldLIEtleVN0b3JlIEltcGxlbWVudGF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIiksXG4gICAgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxudmFyIEpXSyA9IHtcbiAgQmFzZUtleTogcmVxdWlyZShcIi4vYmFzZWtleS5qc1wiKSxcbiAgaGVscGVyczogcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKVxufTtcblxuLyoqXG4gKiBAY2xhc3MgSldLLktleVN0b3JlUmVnaXN0cnlcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgcmVnaXN0cnkgb2YgSldLLktleSB0eXBlcyB0aGF0IGNhbiBiZSB1c2VkLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIFRoaXMgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseS4gSW5zdGVhZCB1c2UgdGhlXG4gKiBnbG9iYWwge0pXSy5yZWdpc3RyeX1cbiAqL1xudmFyIEpXS1JlZ2lzdHJ5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlcyA9IHt9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ2lzdGVyXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgaWYgKCFmYWN0b3J5IHx8IFwic3RyaW5nXCIgIT09IHR5cGVvZiBmYWN0b3J5Lmt0eSB8fCAhZmFjdG9yeS5rdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBLZXkgZmFjdG9yeVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGt0eSA9IGZhY3Rvcnkua3R5O1xuICAgICAgdHlwZXNba3R5XSA9IGZhY3Rvcnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1bnJlZ2lzdGVyXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgaWYgKCFmYWN0b3J5IHx8IFwic3RyaW5nXCIgIT09IHR5cGVvZiBmYWN0b3J5Lmt0eSB8fCAhZmFjdG9yeS5rdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBLZXkgZmFjdG9yeVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGt0eSA9IGZhY3Rvcnkua3R5O1xuICAgICAgaWYgKGZhY3RvcnkgPT09IHR5cGVzW2t0eV0pIHtcbiAgICAgICAgZGVsZXRlIHR5cGVzW2t0eV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGt0eSkge1xuICAgICAgcmV0dXJuIHR5cGVzW2t0eSB8fCBcIlwiXSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxsXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModHlwZXMpLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiB0eXBlc1t0XTsgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIEdsb2JhbHNcbnZhciBHTE9CQUxfUkVHSVNUUlkgPSBuZXcgSldLUmVnaXN0cnkoKTtcblxuLy8gaW1wb3J0ZXJcbmZ1bmN0aW9uIHByb2Nlc3NDZXJ0KGlucHV0KSB7XG4gIC8vIGNvbnZlcnQgY2VydElzc3VlciB0byByZWFkYWJsZSBhdHRyaWJ1dGVzXG4gIFtcImNlcnRJc3N1ZXJcIiwgXCJjZXJ0U3ViamVjdFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgLyogZXNsaW50IG5ldy1jYXA6IFswXSAqL1xuICAgIHZhciBhdHRycyA9IGZvcmdlLnBraS5SRE5BdHRyaWJ1dGVzQXNBcnJheShpbnB1dFtmaWVsZF0pO1xuICAgIHZhciByZXN1bHQgPSBpbnB1dFtmaWVsZF0gPSB7fTtcbiAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJlc3VsdFthLm5hbWUgfHwgYS50eXBlXSA9IGEudmFsdWU7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gZnJvbVBFTShpbnB1dCkge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBwZW1zID0gZm9yZ2UucGVtLmRlY29kZShpbnB1dCk7XG4gIHZhciBmb3VuZCA9IHBlbXMuc29tZShmdW5jdGlvbihwKSB7XG4gICAgc3dpdGNoIChwLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJDRVJUSUZJQ0FURVwiOlxuICAgICAgICByZXN1bHQuZm9ybSA9IFwicGtpeFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQVUJMSUMgS0VZXCI6XG4gICAgICAgIHJlc3VsdC5mb3JtID0gXCJzcGtpXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBSSVZBVEUgS0VZXCI6XG4gICAgICAgIHJlc3VsdC5mb3JtID0gXCJwa2NzOFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJFQyBQUklWQVRFIEtFWVwiOlxuICAgICAgICAvKiBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFswXSAqL1xuICAgICAgY2FzZSBcIlJTQSBQUklWQVRFIEtFWVwiOlxuICAgICAgICByZXN1bHQuZm9ybSA9IFwicHJpdmF0ZVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXN1bHQuYm9keSA9IHAuYm9keTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIGlmICghZm91bmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdXBwb3J0ZWQgUEVNIHR5cGUgbm90IGZvdW5kXCIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpbXBvcnRGcm9tKHJlZ2lzdHJ5LCBpbnB1dCkge1xuICAvLyBmb3JtIGNhbiBiZSBvbmUgb2Y6XG4gIC8vICAncHJpdmF0ZScgfCAncGtjczgnIHwgJ3B1YmxpYycgfCAnc3BraScgfCAncGtpeCcgfCAneDUwOSdcbiAgdmFyIGNhcHR1cmUgPSB7fSxcbiAgICAgIGVycm9ycyA9IFtdLFxuICAgICAgcmVzdWx0O1xuXG4gIC8vIGNvbnZlciBmcm9tIERFUiB0byBBU04xXG4gIHZhciBmb3JtID0gaW5wdXQuZm9ybSxcbiAgICAgIGRlciA9IGlucHV0LmJvZHksXG4gICAgICB0aHVtYnByaW50ID0gbnVsbDtcbiAgaW5wdXQgPSBmb3JnZS5hc24xLmZyb21EZXIoZGVyKTtcbiAgc3dpdGNoKGZvcm0pIHtcbiAgICBjYXNlIFwicHJpdmF0ZVwiOlxuICAgICAgcmVnaXN0cnkuYWxsKCkuc29tZShmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmYWN0b3J5LnZhbGlkYXRvcnMpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2lkID0gZmFjdG9yeS52YWxpZGF0b3JzLm9pZCxcbiAgICAgICAgICAgIHZhbGlkYXRvciA9IGZhY3RvcnkudmFsaWRhdG9ycy5wcml2YXRlS2V5O1xuICAgICAgICBpZiAoIXZhbGlkYXRvcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXB0dXJlID0ge307XG4gICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICByZXN1bHQgPSBmb3JnZS5hc24xLnZhbGlkYXRlKGlucHV0LCB2YWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBjYXB0dXJlLmtleU9pZCA9IGZvcmdlLmFzbjEub2lkVG9EZXIob2lkKTtcbiAgICAgICAgICBjYXB0dXJlLnBhcnNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgY2FwdHVyZS50eXBlID0gXCJwcml2YXRlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicGtjczhcIjpcbiAgICAgIHJlc3VsdCA9IGZvcmdlLmFzbjEudmFsaWRhdGUoaW5wdXQsIEpXSy5oZWxwZXJzLnZhbGlkYXRvcnMucHJpdmF0ZUtleSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgIGNhcHR1cmUudHlwZSA9IFwicHJpdmF0ZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgLy8gZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBbMF0gKi9cbiAgICBjYXNlIFwic3BraVwiOlxuICAgICAgcmVzdWx0ID0gZm9yZ2UuYXNuMS52YWxpZGF0ZShpbnB1dCwgSldLLmhlbHBlcnMudmFsaWRhdG9ycy5wdWJsaWNLZXksIGNhcHR1cmUsIGVycm9ycyk7XG4gICAgICBjYXB0dXJlLnR5cGUgPSBcInB1YmxpY1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInBraXhcIjpcbiAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogWzBdICovXG4gICAgY2FzZSBcIng1MDlcIjpcbiAgICAgIHJlc3VsdCA9IGZvcmdlLmFzbjEudmFsaWRhdGUoaW5wdXQsIEpXSy5oZWxwZXJzLnZhbGlkYXRvcnMuY2VydGlmaWNhdGUsIGNhcHR1cmUsIGVycm9ycyk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcm9jZXNzQ2VydChjYXB0dXJlKTtcbiAgICAgICAgdmFyIG1kID0gZm9yZ2UubWQuc2hhMS5jcmVhdGUoKTtcbiAgICAgICAgbWQudXBkYXRlKGRlcik7XG4gICAgICAgIHRodW1icHJpbnQgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUoQnVmZmVyLmZyb20obWQuZGlnZXN0KCkudG9IZXgoKSwgXCJoZXhcIikpO1xuICAgICAgfVxuICAgICAgY2FwdHVyZS50eXBlID0gXCJwdWJsaWNcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBjb252ZXJ0IG9pZHNcbiAgaWYgKGNhcHR1cmUua2V5T2lkKSB7XG4gICAgY2FwdHVyZS5rZXlPaWQgPSBmb3JnZS5hc24xLmRlclRvT2lkKGNhcHR1cmUua2V5T2lkKTtcbiAgfVxuXG4gIC8vIGZpbmQgYW5kIGludm9rZSB0aGUgaW1wb3J0ZXJcbiAgcmVzdWx0ID0gbnVsbDtcbiAgR0xPQkFMX1JFR0lTVFJZLmFsbCgpLmZvckVhY2goZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBmYWN0b3J5LmltcG9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN1bHQgPSBmYWN0b3J5LmltcG9ydChjYXB0dXJlKTtcbiAgfSk7XG4gIGlmIChyZXN1bHQgJiYgY2FwdHVyZS5jZXJ0U3ViamVjdCAmJiBjYXB0dXJlLmNlcnRTdWJqZWN0LmNvbW1vbk5hbWUpIHtcbiAgICByZXN1bHQua2lkID0gY2FwdHVyZS5jZXJ0U3ViamVjdC5jb21tb25OYW1lO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgdGh1bWJwcmludCkge1xuICAgIHJlc3VsdC54NXQgPSB0aHVtYnByaW50O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGNsYXNzIEpXSy5LZXlTdG9yZVxuICogQGNsYXNzZGVzY1xuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2YgS2V5cy5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiBUaGlzIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuIEluc3RlYWQgY2FsbCB7QGxpbmtcbiAqIEpXSy5jcmVhdGVLZXlTdG9yZX0uXG4gKi9cbnZhciBKV0tTdG9yZSA9IGZ1bmN0aW9uKHJlZ2lzdHJ5LCBwYXJlbnQpIHtcbiAgdmFyIGtleXNldHMgPSB7fTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjZ2VuZXJhdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdlbmVyYXRlcyBhIG5ldyByYW5kb20gS2V5IGludG8gdGhpcyBLZXlTdG9yZS5cbiAgICpcbiAgICogVGhlIHR5cGUgb2Yge3NpemV9IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIHtrdHl9OlxuICAgKlxuICAgKiArICoqYEVDYCoqOiBTdHJpbmcgbmFtaW5nIHRoZSBjdXJ2ZSB0byB1c2UsIHdoaWNoIGNhbiBiZSBvbmUgb2Y6XG4gICAqICAgYFwiUC0yNTZcImAsIGBcIlAtMzg0XCJgLCBvciBgXCJQLTUyMVwiYCAoZGVmYXVsdCBpcyAqKmBcIlAtMjU2XCJgKiopLlxuICAgKiArICoqYFJTQWAqKjogTnVtYmVyIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdGhlIGtleSwgaW4gYml0cyAoZGVmYXVsdCBpc1xuICAgKiAgICoqYDIwNDhgKiopLlxuICAgKiArICoqYG9jdGAqKjogTnVtYmVyIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdGhlIGtleSwgaW4gYml0cyAoZGVmYXVsdCBpc1xuICAgKiAgICoqYDI1NmAqKikuXG4gICAqXG4gICAqIEFueSBwcm9wZXJ0aWVzIGluIHtwcm9wc30gYXJlIGFwcGxpZWQgYmVmb3JlIHRoZSBrZXkgaXMgZ2VuZXJhdGVkLFxuICAgKiBhbmQgYXJlIGV4cGVjdGVkIHRvIGJlIGRhdGEgdHlwZXMgYWNjZXB0YWJsZSBpbiBKU09OLiAgVGhpcyBhbGxvd3MgdGhlXG4gICAqIGdlbmVyYXRlZCBrZXkgdG8gaGF2ZSBhIHNwZWNpZmljIGtleSBpZGVudGlmaWVyLCBvciB0byBzcGVjaWZ5IGl0c1xuICAgKiBhY2NlcHRhYmxlIHVzYWdlLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgdGhlIGdlbmVyYXRlZCBLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrdHkgVGhlIHR5cGUgb2YgZ2VuZXJhdGVkIGtleVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtzaXplXSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhlIGdlbmVyYXRlZFxuICAgKiAgICAgICAga2V5LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBnZW5lcmF0ZWQgS2V5XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7a3R5fSBpcyBub3Qgc3VwcG9ydGVkXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZW5lcmF0ZVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGt0eSwgc2l6ZSwgcHJvcHMpIHtcbiAgICAgIHZhciBrZXl0eXBlID0gcmVnaXN0cnkuZ2V0KGt0eSk7XG4gICAgICBpZiAoIWtleXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleSB0eXBlXCIpKTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBjbG9uZShwcm9wcyB8fCB7fSk7XG4gICAgICBwcm9wcy5rdHkgPSBrdHk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICBwcm9taXNlID0ga2V5dHlwZS5nZW5lcmF0ZShzaXplKTtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandrKSB7XG4gICAgICAgIGp3ayA9IG1lcmdlKHByb3BzLCBqd2ssIHtcbiAgICAgICAgICBrdHk6IGt0eVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGYuYWRkKGp3ayk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjYWRkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBZGRzIGEgS2V5IHRvIHRoaXMgS2V5U3RvcmUuIElmIHtqd2t9IGlzIGEgc3RyaW5nLCBpdCBpcyBmaXJzdFxuICAgKiBwYXJzZWQgaW50byBhIHBsYWluIEpTT04gb2JqZWN0LiBJZiB7andrfSBpcyBhbHJlYWR5IGFuIGluc3RhbmNlXG4gICAqIG9mIEpXSy5LZXksIGl0cyAocHVibGljKSBKU09OIHJlcHJlc2VudGF0aW9uIGlzIGZpcnN0IG9idGFpbmVkXG4gICAqIHRoZW4gYXBwbGllZCB0byBhIG5ldyBKV0suS2V5IG9iamVjdCB3aXRoaW4gdGhpcyBLZXlTdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqd2sgVGhlIEpTT04gV2ViIEtleSAoSldLKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2Zvcm1dIFRoZSBmb3JtYXQgb2YgYSBTdHJpbmcga2V5IHRvIGV4cGVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dHJhc10gZXh0cmEgandrIGZpZWxkcyBpbnNlcnRlZCB3aGVuIGltcG9ydGluZyBmcm9tIGEgbm9uIGpzb24gc3RyaW5nIChlZyBcInBlbVwiKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBhZGRlZCBrZXlcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGp3aywgZm9ybSwgZXh0cmFzKSB7XG4gICAgICBleHRyYXMgPSBleHRyYXMgfHwge307XG5cbiAgICAgIHZhciBmYWN0b3JzO1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihqd2spIHx8IHR5cGVvZiBqd2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gZm9ybSBjYW4gYmUgJ2pzb24nLCAncGtjczgnLCAnc3BraScsICdwa2l4JywgJ3g1MDknLCAncGVtJ1xuICAgICAgICBmb3JtID0gKGZvcm0gfHwgXCJqc29uXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcImpzb25cIiA9PT0gZm9ybSkge1xuICAgICAgICAgIGp3ayA9IEpTT04ucGFyc2UoandrLnRvU3RyaW5nKFwidXRmOFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChcInBlbVwiID09PSBmb3JtKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnZlcnQgKmZpcnN0KiBQRU0gLT4gREVSXG4gICAgICAgICAgICAgIGZhY3RvcnMgPSBmcm9tUEVNKGp3ayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmYWN0b3JzID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IGp3ay50b1N0cmluZyhcImJpbmFyeVwiKSxcbiAgICAgICAgICAgICAgICBmb3JtOiBmb3JtXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqd2sgPSBpbXBvcnRGcm9tKHJlZ2lzdHJ5LCBmYWN0b3JzKTtcbiAgICAgICAgICAgIGlmICghandrKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGltcG9ydGVyIGZvciBrZXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhleHRyYXMpLmZvckVhY2goZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICAgICAgICBqd2tbZmllbGRdID0gZXh0cmFzW2ZpZWxkXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEpXS1N0b3JlLmlzS2V5KGp3aykpIHtcbiAgICAgICAgLy8gYXNzdW1lIGEgY29tcGxldGUgZHVwbGljYXRlIGlzIGRlc2lyZWRcbiAgICAgICAgandrID0gandrLnRvSlNPTih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGp3ayA9IGNsb25lKGp3ayk7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXl0eXBlID0gcmVnaXN0cnkuZ2V0KGp3ay5rdHkpO1xuICAgICAgaWYgKCFrZXl0eXBlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXkgdHlwZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICBwcm9taXNlID0ga2V5dHlwZS5wcmVwYXJlKGp3ayk7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNmZykge1xuICAgICAgICByZXR1cm4gbmV3IEpXSy5CYXNlS2V5KGp3ay5rdHksIHNlbGYsIGp3aywgY2ZnKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oandrKSB7XG4gICAgICAgIHZhciBraWQgPSBqd2sua2lkIHx8IFwiXCI7XG4gICAgICAgIHZhciBrZXlzID0ga2V5c2V0c1traWRdID0ga2V5c2V0c1traWRdIHx8IFtdO1xuICAgICAgICBrZXlzLnB1c2goandrKTtcblxuICAgICAgICByZXR1cm4gandrO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI3JlbW92ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmVtb3ZlcyBhIEtleSBmcm9tIHRoaXMgS2V5U3RvcmUuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGUgcmVtb3ZlZCBLZXkncyB7a2V5c3RvcmV9IHByb3BlcnR5IGlzIG5vdCBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0pXSy5LZXl9IGp3ayBUaGUga2V5IHRvIHJlbW92ZS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlbW92ZVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGp3aykge1xuICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5cyA9IGtleXNldHNbandrLmtpZF07XG4gICAgICBpZiAoIWtleXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9zID0ga2V5cy5pbmRleE9mKGp3ayk7XG4gICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGtleXMuc3BsaWNlKHBvcywgMSk7XG4gICAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBrZXlzZXRzW2p3ay5raWRdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI2FsbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0cmlldmVzIGFsbCBvZiB0aGUgY29udGFpbmVkIEtleXMgdGhhdCBvcHRpbmFsbHkgbWF0Y2ggYWxsIG9mIHRoZVxuICAgKiBnaXZlbiBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBJZiB7cHJvcHN9IGFyZSBzcGVjaWZpZWQsIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyBLZXlzIHdoaWNoIGV4YWN0bHlcbiAgICogbWF0Y2ggdGhlIGdpdmVuIHByb3BlcnRpZXMuIFRoZSBwcm9wZXJ0aWVzIGNhbiBiZSBhbnkgb2YgdGhlXG4gICAqIGZvbGxvd2luZzpcbiAgICpcbiAgICogKyAqKmFsZyoqOiBUaGUgYWxnb3JpdGhtIGZvciB0aGUgS2V5LlxuICAgKiArICoqdXNlKio6IFRoZSB1c2FnZSBmb3IgdGhlIEtleS5cbiAgICogKyAqKmtpZCoqOiBUaGUgaWRlbnRpZmllciBmb3IgdGhlIEtleS5cbiAgICpcbiAgICogSWYgbm8gcHJvcGVydGllcyBhcmUgZ2l2ZW4sIHRoaXMgbWV0aG9kIHJldHVybnMgYWxsIG9mIHRoZSBLZXlzIGZvciB0aGlzXG4gICAqIEtleVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvY2FsID0gZmFsc2VdIGB0cnVlYCBpZiBvbmx5IHRoZSBLZXlzXG4gICAqICAgICAgICBkaXJlY3RseSBjb250YWluZWQgYnkgdGhpcyBLZXlTdG9yZSBzaG91bGQgYmUgcmV0dXJuZWQsIG9yXG4gICAqICAgICAgICBgZmFsc2VgIGlmIGl0IHNob3VsZCByZXR1cm4gYWxsIEtleXMgb2YgdGhpcyBLZXlTdG9yZSBhbmRcbiAgICogICAgICAgIGl0cyBhbmNlc3RvcnMuXG4gICAqIEByZXR1cm5zIHtKV0suS2V5W119IFRoZSBsaXN0IG9mIG1hdGNoaW5nIEtleXMsIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vXG4gICAqICAgICAgICAgIG1hdGNoZXMgYXJlIGZvdW5kLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxsXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24ocHJvcHMsIGxvY2FsKSB7XG4gICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciBpc3N1ZXMvMTA5XG4gICAgICBpZiAocHJvcHMua2lkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMua2lkICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5raWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcHJvcHMua2lkID0gU3RyaW5nKHByb3BzLmtpZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XG4gICAgICB2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyBtYXRjaCBvbiAna3R5J1xuICAgICAgICBpZiAocHJvcHMua3R5ICYmXG4gICAgICAgICAgICBrZXkua3R5ICYmXG4gICAgICAgICAgICBwcm9wcy5rdHkgIT09IGtleS5rdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF0Y2ggb24gJ3VzZSdcbiAgICAgICAgaWYgKHByb3BzLnVzZSAmJlxuICAgICAgICAgICAga2V5LnVzZSAmJlxuICAgICAgICAgICAgcHJvcHMudXNlICE9PSBrZXkudXNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1hdGNoIG9uICdhbGcnXG4gICAgICAgIGlmIChwcm9wcy5hbGcpIHtcbiAgICAgICAgICBpZiAocHJvcHMuYWxnICE9PSBcImRpclwiICYmXG4gICAgICAgICAgICAgIGtleS5hbGcgJiZcbiAgICAgICAgICAgICAgcHJvcHMuYWxnICE9PSBrZXkuYWxnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZXkuc3VwcG9ydHMocHJvcHMuYWxnKTtcbiAgICAgICAgfVxuICAgICAgICAvL1RPRE86IG1hdGNoIG9uICdrZXlfb3BzJ1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5rZXlzKGtleXNldHMpLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgaWYgKHByb3BzLmtpZCAmJiBwcm9wcy5raWQgIT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBrZXlzZXRzW2lkXS5maWx0ZXIobWF0Y2hlcyk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmNvbmNhdChrZXlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghbG9jYWwgJiYgcGFyZW50KSB7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmNvbmNhdChwYXJlbnQuYWxsKHByb3BzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSNnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHJpZXZlcyB0aGUgY29udGFpbmVkIEtleSBtYXRjaGluZyB0aGUgZ2l2ZW4ge2tpZH0sIGFuZCBvcHRpb25hbGx5XG4gICAqIGFsbCBvZiB0aGUgZ2l2ZW4gcHJvcGVydGllcy4gIFRoaXMgbWV0aG9kIGVxdWl2YWxlbnQgdG8gY2FsbGluZ1xuICAgKiB7QGxpbmsgSldLLlN0b3JlI2FsbH0sIHRoZW4gcmV0dXJuaW5nIHRoZSBmaXJzdCBLZXkgd2hvc2VcbiAgICogXCJraWRcIiBpcyB7a2lkfS4gSWYge2tpZH0gaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBmaXJzdCBLZXkgdGhhdFxuICAgKiBpcyByZXR1cm5lZCBmcm9tIGBhbGwoKWAgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2lkXSBUaGUga2V5IGlkZW50aWZpZXIgdG8gbWF0Y2ggYWdhaW5zdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbbG9jYWwgPSBmYWxzZV0gYHRydWVgIGlmIG9ubHkgdGhlIEtleXNcbiAgICogICAgICAgIGRpcmVjdGx5IGNvbnRhaW5lZCBieSB0aGlzIEtleVN0b3JlIHNob3VsZCBiZSByZXR1cm5lZCwgb3JcbiAgICogICAgICAgIGBmYWxzZWAgaWYgaXQgc2hvdWxkIHJldHVybiBhbGwgS2V5cyBvZiB0aGlzIEtleVN0b3JlIGFuZFxuICAgKiAgICAgICAgaXRzIGFuY2VzdG9ycy5cbiAgICogQHJldHVybnMge0pXSy5LZXl9IFRoZSBLZXkgbWF0Y2hpbmcge2tpZH0gYW5kIHtwcm9wc30sIG9yIGBudWxsYFxuICAgKiAgICAgICAgICBpZiBubyBtYXRjaCBpcyBmb3VuZC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGtpZCwgcHJvcHMsIGxvY2FsKSB7XG4gICAgICAvLyByZWNvbmNpbGUgYXJndW1lbnRzXG4gICAgICBpZiAodHlwZW9mIGtpZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgbG9jYWwgPSBraWQ7XG4gICAgICAgIHByb3BzID0ga2lkID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtpZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsb2NhbCA9IHByb3BzO1xuICAgICAgICBwcm9wcyA9IGtpZDtcbiAgICAgICAga2lkID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gZml4dXAgcHJvcHNcbiAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICBpZiAoa2lkKSB7XG4gICAgICAgIHByb3BzLmtpZCA9IGtpZDtcbiAgICAgIH1cblxuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaXNzdWVzLzEwOVxuICAgICAgaWYgKHByb3BzLmtpZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmtpZCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMua2lkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgcHJvcHMua2lkID0gU3RyaW5nKHByb3BzLmtpZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW5kaWRhdGVzID0gdGhpcy5hbGwocHJvcHMsIHRydWUpO1xuICAgICAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCAmJiBwYXJlbnQgJiYgIWxvY2FsKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMgPSBwYXJlbnQuZ2V0KHByb3BzLCBsb2NhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlc1swXSB8fCBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI3RlbXBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENyZWF0ZXMgYSB0ZW1wb3JhcnkgS2V5U3RvcmUgYmFzZWQgb24gdGhpcyBLZXlTdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge0pXSy5LZXlTdG9yZX0gVGhlIHRlbXBvcmFyeSBLZXlTdG9yZS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRlbXBcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSldLU3RvcmUocmVnaXN0cnksIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI3RvSlNPTlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2VuZXJhdGVzIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEtleVN0b3JlLCB3aGljaCBjb25mb3Jtc1xuICAgKiB0byBhIEpXSyBTZXQgZnJvbSB7SS1ELmlldGYtam9zZS1qc29uLXdlYi1rZXl9LlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1ByaXZhdGUgPSBmYWxzZV0gYHRydWVgIGlmIHRoZSBwcml2YXRlIGZpZWxkc1xuICAgKiAgICAgICAgb2Ygc3RvcmVkIGtleXMgYXJlIHRvIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEtleVN0b3JlLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9KU09OXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaXNQcml2YXRlKSB7XG4gICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICBPYmplY3Qua2V5cyhrZXlzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uKGtpZCkge1xuICAgICAgICB2YXIgaXRlbXMgPSBrZXlzZXRzW2tpZF0ubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gay50b0pTT04oaXNQcml2YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChpdGVtcyk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5czoga2V5c1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgSldLLktleVN0b3JlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHtvYmp9IGlzIGFuIGluc3RhbmNlIG9mIEpXSy5LZXlTdG9yZSxcbiAqICAgICAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuSldLU3RvcmUuaXNLZXlTdG9yZSA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5nZXQgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5hbGwgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5nZW5lcmF0ZSB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmFkZCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnJlbW92ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGVtcHR5IEtleVN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHtKV0suS2V5U3RvcmV9IFRoZSBlbXB0eSBLZXlTdG9yZS5cbiAqL1xuSldLU3RvcmUuY3JlYXRlS2V5U3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBKV0tTdG9yZShHTE9CQUxfUkVHSVNUUlkpO1xufTtcblxuLyoqXG4gKiBDb2VyY2VzIHRoZSBnaXZlbiBvYmplY3QgaW50byBhIEtleVN0b3JlLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBmb2xsb3dpbmdcbiAqIGFsZ29yaXRobSB0byBjb2VyY2Uge2tzfTpcbiAqXG4gKiAxLiBpZiB7a3N9IGlzIGFuIGluc3RhbmNlIG9mIEpXSy5LZXlTdG9yZSwgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHlcbiAqIDIuIGlmIHtrc30gaXMgYSBzdHJpbmcsIGl0IGlzIHBhcnNlZCBpbnRvIGEgSlNPTiB2YWx1ZVxuICogMy4gaWYge2tzfSBpcyBhbiBhcnJheSwgaXQgY3JlYXRlcyBhIG5ldyBKV0suS2V5U3RvcmUgYW5kIGNhbGxzIHtAbGlua1xuICogICAgSldLLktleVN0b3JlI2FkZH0gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUge2tzfSBhcnJheS5cbiAqIDQuIGlmIHtrc30gaXMgYSBKU09OIG9iamVjdCwgaXQgY3JlYXRlcyBhIG5ldyBKV0suS2V5U3RvcmUgYW5kIGNhbGxzIHtAbGlua1xuICogICAgSldLLktleVN0b3JlI2FkZH0gZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgXCJrZXlzXCIgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrcyBUaGUgdmFsdWUgdG8gY29lcmNlIGludG8gYVxuICogICAgICAgIEtleVN0b3JlXG4gKiBAcmV0dXJucyB7UHJvbWlzZShKV0suS2V5U3RvcmUpfSBBIHByb21pc2UgZm9yIHRoZSBjb2VyY2VkIEtleVN0b3JlLlxuICovXG5KV0tTdG9yZS5hc0tleVN0b3JlID0gZnVuY3Rpb24oa3MpIHtcbiAgaWYgKEpXS1N0b3JlLmlzS2V5U3RvcmUoa3MpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrcyk7XG4gIH1cblxuICB2YXIgc3RvcmUgPSBKV0tTdG9yZS5jcmVhdGVLZXlTdG9yZSgpLFxuICAgICAga2V5cztcblxuICBpZiAodHlwZW9mIGtzID09PSBcInN0cmluZ1wiKSB7XG4gICAga3MgPSBKU09OLnBhcnNlKGtzKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGtzKSkge1xuICAgIGtleXMgPSBrcztcbiAgfSBlbHNlIGlmIChcImtleXNcIiBpbiBrcykge1xuICAgIGtleXMgPSBrcy5rZXlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGtleXN0b3JlXCIpKTtcbiAgfVxuXG4gIGtleXMgPSBrZXlzLm1hcChmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIHN0b3JlLmFkZChrKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLmFsbChrZXlzKTtcbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIEpXSy5LZXkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB7b2JqfSBpcyBhIEpXSy5LZXlcbiAqL1xuSldLU3RvcmUuaXNLZXkgPSBmdW5jdGlvbihvYmopIHtcbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iaikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghSldLU3RvcmUuaXNLZXlTdG9yZShvYmoua2V5c3RvcmUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBvYmoua3R5IHx8XG4gICAgICBcIm51bWJlclwiICE9PSB0eXBlb2Ygb2JqLmxlbmd0aCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmFsZ29yaXRobXMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5zdXBwb3J0cyB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmVuY3J5cHQgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai5kZWNyeXB0IHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmoud3JhcCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnVud3JhcCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnNpZ24gfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai52ZXJpZnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBrZXkgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllcy4gIFRoaXMgbWV0aG9kIGlzIGEgY29udmVuaWVuY2VcbiAqIHRvIGNhbGxpbmcgYEpXSy5jcmVhdGVLZXlTdG9yZSgpYCB0aGVuIGBnZW5lcmF0ZSgpYCBvbiB0aGUgcmV0dXJuZWQga2V5c3RvcmUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGt0eSBUaGUgdHlwZSBvZiBnZW5lcmF0ZWQga2V5XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IFtzaXplXSBUaGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGtleVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoZSBnZW5lcmF0ZWRcbiAqICAgICAgICBrZXkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBnZW5lcmF0ZWQgS2V5XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYge2t0eX0gaXMgbm90IHN1cHBvcnRlZFxuICogQHNlZSBKV0tTdG9yZSNnZW5lcmF0ZVxuICovXG5KV0tTdG9yZS5jcmVhdGVLZXkgPSBmdW5jdGlvbihrdHksIHNpemUsIHByb3BzKSB7XG4gIHZhciBrcyA9IEpXS1N0b3JlLmNyZWF0ZUtleVN0b3JlKCk7XG4gIHJldHVybiBrcy5nZW5lcmF0ZShrdHksIHNpemUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBDb2VyY2VzIHRoZSBnaXZlbiBvYmplY3QgaW50byBhIEtleS4gSWYge2tleX0gaXMgYW4gaW5zdGFuY2Ugb2YgSldLLktleSxcbiAqIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIGZpcnN0IGNyZWF0ZXMgYSBuZXdcbiAqIEpXSy5LZXlTdG9yZSBhbmQgY2FsbHMge0BsaW5rIEpXSy5LZXlTdG9yZSNhZGR9IG9uIHRoaXMgbmV3IEtleVN0b3JlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5IFRoZSB2YWx1ZSB0byBjb2VyY2UgaW50byBhIEtleVxuICogQHBhcmFtIHtTdHJpbmd9IFtmb3JtXSBUaGUgZm9ybWF0IG9mIGEgU3RyaW5nIEtleSB0byBleHBlY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFzXSBleHRyYSBqd2sgZmllbGRzIGluc2VydGVkIHdoZW4gaW1wb3J0aW5nIGZyb20gYSBub24ganNvbiBzdHJpbmcgKGVnIFwicGVtXCIpXG4gKiBAcmV0dXJucyB7UHJvbWlzZShKV0suS2V5KX0gQSBwcm9taXNlIGZvciB0aGUgY29lcmNlZCBLZXkuXG4gKi9cbkpXS1N0b3JlLmFzS2V5ID0gZnVuY3Rpb24oa2V5LCBmb3JtLCBleHRyYXMpIHtcbiAgaWYgKEpXS1N0b3JlLmlzS2V5KGtleSkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gIH1cblxuICB2YXIga3MgPSBKV0tTdG9yZS5jcmVhdGVLZXlTdG9yZSgpO1xuICBrZXkgPSBrcy5hZGQoa2V5LCBmb3JtLCBleHRyYXMpO1xuXG4gIHJldHVybiBrZXk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgS2V5UmVnaXN0cnk6IEpXS1JlZ2lzdHJ5LFxuICBLZXlTdG9yZTogSldLU3RvcmUsXG4gIHJlZ2lzdHJ5OiBHTE9CQUxfUkVHSVNUUllcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/octkey.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/octkey.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/octkey.js - Symmetric Octet Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"HS256\",\n  \"HS384\",\n  \"HS512\"\n];\nvar ENC_ALGS = [\n  \"A128GCM\",\n  \"A192GCM\",\n  \"A256GCM\",\n  \"A128CBC-HS256\",\n  \"A192CBC-HS384\",\n  \"A256CBC-HS512\",\n  \"A128CBC+HS256\",\n  \"A192CBC+HS384\",\n  \"A256CBC+HS512\"\n];\nvar WRAP_ALGS = [\n  \"A128KW\",\n  \"A192KW\",\n  \"A256KW\",\n  \"A128GCMKW\",\n  \"A192GCMKW\",\n  \"A256GCMKW\",\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\",\n  \"dir\"\n];\n\nfunction adjustDecryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ?\n               props.iv :\n               util.base64url.decode(props.iv || \"\");\n  }\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ?\n                  props.adata :\n                  Buffer.from(props.adata || \"\", \"utf8\");\n  }\n  if (\"mac\" in props) {\n    props.mac = Buffer.isBuffer(props.mac) ?\n                props.mac :\n                util.base64url.decode(props.mac || \"\");\n  }\n  if (\"tag\" in props) {\n    props.tag = Buffer.isBuffer(props.tag) ?\n                props.tag :\n                util.base64url.decode(props.tag || \"\");\n  }\n\n  return props;\n}\nfunction adjustEncryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ?\n               props.iv :\n               util.base64url.decode(props.iv || \"\");\n  }\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ?\n                  props.adata :\n                  Buffer.from(props.adata || \"\", \"utf8\");\n  }\n\n  return props;\n}\n\nvar JWKOctetCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"k\", type: \"binary\"}\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.k) {\n      pk.length = pk.k.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n\n  thumbprint: function(json) {\n    if (json.private) {\n      json = json.private;\n    }\n    var fields;\n    fields = {\n      k: json.k || \"\",\n      kty: \"oct\"\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    var len = keys.private && (keys.private.k.length * 8);\n    var mins = [256, 384, 512];\n\n    if (!len) {\n      return [];\n    }\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return ENC_ALGS.filter(function(a) {\n          return (a === (\"A\" + (len / 2) + \"CBC-HS\" + len)) ||\n                 (a === (\"A\" + (len / 2) + \"CBC+HS\" + len)) ||\n                 (a === (\"A\" + len + \"GCM\"));\n        });\n      case \"sign\":\n      case \"verify\":\n        // TODO: allow for HS{less-than-keysize}\n        return SIG_ALGS.filter(function(a) {\n          var result = false;\n          mins.forEach(function(m) {\n            if (m > len) { return; }\n            result = result | (a === (\"HS\" + m));\n          });\n          return result;\n        });\n      case \"wrap\":\n      case \"unwrap\":\n        return WRAP_ALGS.filter(function(a) {\n          return (a === (\"A\" + len + \"KW\")) ||\n                 (a === (\"A\" + len + \"GCMKW\")) ||\n                 (a.indexOf(\"PBES2-\") === 0) ||\n                 (a === \"dir\");\n        });\n    }\n\n    return [];\n  },\n  encryptKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  encryptProps: adjustEncryptProps,\n\n  decryptKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  decryptProps: adjustDecryptProps,\n\n  wrapKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  wrapProps: adjustEncryptProps,\n\n  unwrapKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  unwrapProps: adjustDecryptProps,\n\n  signKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  }\n};\n\n// Factory\nvar JWKOctetFactory = {\n  kty: \"oct\",\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKOctetCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    // TODO: validate key sizes\n    var key = util.randomBytes(size / 8);\n\n    return Promise.resolve({\n      k: key\n    });\n  }\n};\n\n// public API\nmodule.exports = Object.freeze({\n  config: JWKOctetCfg,\n  factory: JWKOctetFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKOctetFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svb2N0a2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyx1RUFBYztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9vY3RrZXkuanM/ODU5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9vY3RrZXkuanMgLSBTeW1tZXRyaWMgT2N0ZXQgS2V5IFJlcHJlc2VudGF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbnZhciBKV0sgPSB7XG4gIEJhc2VLZXk6IHJlcXVpcmUoXCIuL2Jhc2VrZXkuanNcIiksXG4gIGhlbHBlcnM6IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIilcbn07XG5cbnZhciBTSUdfQUxHUyA9IFtcbiAgXCJIUzI1NlwiLFxuICBcIkhTMzg0XCIsXG4gIFwiSFM1MTJcIlxuXTtcbnZhciBFTkNfQUxHUyA9IFtcbiAgXCJBMTI4R0NNXCIsXG4gIFwiQTE5MkdDTVwiLFxuICBcIkEyNTZHQ01cIixcbiAgXCJBMTI4Q0JDLUhTMjU2XCIsXG4gIFwiQTE5MkNCQy1IUzM4NFwiLFxuICBcIkEyNTZDQkMtSFM1MTJcIixcbiAgXCJBMTI4Q0JDK0hTMjU2XCIsXG4gIFwiQTE5MkNCQytIUzM4NFwiLFxuICBcIkEyNTZDQkMrSFM1MTJcIlxuXTtcbnZhciBXUkFQX0FMR1MgPSBbXG4gIFwiQTEyOEtXXCIsXG4gIFwiQTE5MktXXCIsXG4gIFwiQTI1NktXXCIsXG4gIFwiQTEyOEdDTUtXXCIsXG4gIFwiQTE5MkdDTUtXXCIsXG4gIFwiQTI1NkdDTUtXXCIsXG4gIFwiUEJFUzItSFMyNTYrQTEyOEtXXCIsXG4gIFwiUEJFUzItSFMzODQrQTE5MktXXCIsXG4gIFwiUEJFUzItSFM1MTIrQTI1NktXXCIsXG4gIFwiZGlyXCJcbl07XG5cbmZ1bmN0aW9uIGFkanVzdERlY3J5cHRQcm9wcyhhbGcsIHByb3BzKSB7XG4gIGlmIChcIml2XCIgaW4gcHJvcHMpIHtcbiAgICBwcm9wcy5pdiA9IEJ1ZmZlci5pc0J1ZmZlcihwcm9wcy5pdikgP1xuICAgICAgICAgICAgICAgcHJvcHMuaXYgOlxuICAgICAgICAgICAgICAgdXRpbC5iYXNlNjR1cmwuZGVjb2RlKHByb3BzLml2IHx8IFwiXCIpO1xuICB9XG4gIGlmIChcImFkYXRhXCIgaW4gcHJvcHMpIHtcbiAgICBwcm9wcy5hZGF0YSA9IEJ1ZmZlci5pc0J1ZmZlcihwcm9wcy5hZGF0YSkgP1xuICAgICAgICAgICAgICAgICAgcHJvcHMuYWRhdGEgOlxuICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20ocHJvcHMuYWRhdGEgfHwgXCJcIiwgXCJ1dGY4XCIpO1xuICB9XG4gIGlmIChcIm1hY1wiIGluIHByb3BzKSB7XG4gICAgcHJvcHMubWFjID0gQnVmZmVyLmlzQnVmZmVyKHByb3BzLm1hYykgP1xuICAgICAgICAgICAgICAgIHByb3BzLm1hYyA6XG4gICAgICAgICAgICAgICAgdXRpbC5iYXNlNjR1cmwuZGVjb2RlKHByb3BzLm1hYyB8fCBcIlwiKTtcbiAgfVxuICBpZiAoXCJ0YWdcIiBpbiBwcm9wcykge1xuICAgIHByb3BzLnRhZyA9IEJ1ZmZlci5pc0J1ZmZlcihwcm9wcy50YWcpID9cbiAgICAgICAgICAgICAgICBwcm9wcy50YWcgOlxuICAgICAgICAgICAgICAgIHV0aWwuYmFzZTY0dXJsLmRlY29kZShwcm9wcy50YWcgfHwgXCJcIik7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBhZGp1c3RFbmNyeXB0UHJvcHMoYWxnLCBwcm9wcykge1xuICBpZiAoXCJpdlwiIGluIHByb3BzKSB7XG4gICAgcHJvcHMuaXYgPSBCdWZmZXIuaXNCdWZmZXIocHJvcHMuaXYpID9cbiAgICAgICAgICAgICAgIHByb3BzLml2IDpcbiAgICAgICAgICAgICAgIHV0aWwuYmFzZTY0dXJsLmRlY29kZShwcm9wcy5pdiB8fCBcIlwiKTtcbiAgfVxuICBpZiAoXCJhZGF0YVwiIGluIHByb3BzKSB7XG4gICAgcHJvcHMuYWRhdGEgPSBCdWZmZXIuaXNCdWZmZXIocHJvcHMuYWRhdGEpID9cbiAgICAgICAgICAgICAgICAgIHByb3BzLmFkYXRhIDpcbiAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHByb3BzLmFkYXRhIHx8IFwiXCIsIFwidXRmOFwiKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cblxudmFyIEpXS09jdGV0Q2ZnID0ge1xuICBwdWJsaWNLZXk6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGZpZWxkcyA9IEpXSy5oZWxwZXJzLkNPTU1PTl9QUk9QUy5jb25jYXQoW1xuICAgIF0pO1xuXG4gICAgdmFyIHBrO1xuICAgIHBrID0gSldLLmhlbHBlcnMudW5wYWNrUHJvcHMocHJvcHMsIGZpZWxkcyk7XG5cbiAgICByZXR1cm4gcGs7XG4gIH0sXG4gIHByaXZhdGVLZXk6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGZpZWxkcyA9IEpXSy5oZWxwZXJzLkNPTU1PTl9QUk9QUy5jb25jYXQoW1xuICAgICAge25hbWU6IFwia1wiLCB0eXBlOiBcImJpbmFyeVwifVxuICAgIF0pO1xuXG4gICAgdmFyIHBrO1xuICAgIHBrID0gSldLLmhlbHBlcnMudW5wYWNrUHJvcHMocHJvcHMsIGZpZWxkcyk7XG4gICAgaWYgKHBrICYmIHBrLmspIHtcbiAgICAgIHBrLmxlbmd0aCA9IHBrLmsubGVuZ3RoICogODtcbiAgICB9IGVsc2Uge1xuICAgICAgcGsgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBrO1xuICB9LFxuXG4gIHRodW1icHJpbnQ6IGZ1bmN0aW9uKGpzb24pIHtcbiAgICBpZiAoanNvbi5wcml2YXRlKSB7XG4gICAgICBqc29uID0ganNvbi5wcml2YXRlO1xuICAgIH1cbiAgICB2YXIgZmllbGRzO1xuICAgIGZpZWxkcyA9IHtcbiAgICAgIGs6IGpzb24uayB8fCBcIlwiLFxuICAgICAga3R5OiBcIm9jdFwiXG4gICAgfTtcbiAgICByZXR1cm4gZmllbGRzO1xuICB9LFxuICBhbGdvcml0aG1zOiBmdW5jdGlvbihrZXlzLCBtb2RlKSB7XG4gICAgdmFyIGxlbiA9IGtleXMucHJpdmF0ZSAmJiAoa2V5cy5wcml2YXRlLmsubGVuZ3RoICogOCk7XG4gICAgdmFyIG1pbnMgPSBbMjU2LCAzODQsIDUxMl07XG5cbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgXCJlbmNyeXB0XCI6XG4gICAgICBjYXNlIFwiZGVjcnlwdFwiOlxuICAgICAgICByZXR1cm4gRU5DX0FMR1MuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gKGEgPT09IChcIkFcIiArIChsZW4gLyAyKSArIFwiQ0JDLUhTXCIgKyBsZW4pKSB8fFxuICAgICAgICAgICAgICAgICAoYSA9PT0gKFwiQVwiICsgKGxlbiAvIDIpICsgXCJDQkMrSFNcIiArIGxlbikpIHx8XG4gICAgICAgICAgICAgICAgIChhID09PSAoXCJBXCIgKyBsZW4gKyBcIkdDTVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcInNpZ25cIjpcbiAgICAgIGNhc2UgXCJ2ZXJpZnlcIjpcbiAgICAgICAgLy8gVE9ETzogYWxsb3cgZm9yIEhTe2xlc3MtdGhhbi1rZXlzaXplfVxuICAgICAgICByZXR1cm4gU0lHX0FMR1MuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgbWlucy5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgIGlmIChtID4gbGVuKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHwgKGEgPT09IChcIkhTXCIgKyBtKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwid3JhcFwiOlxuICAgICAgY2FzZSBcInVud3JhcFwiOlxuICAgICAgICByZXR1cm4gV1JBUF9BTEdTLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIChhID09PSAoXCJBXCIgKyBsZW4gKyBcIktXXCIpKSB8fFxuICAgICAgICAgICAgICAgICAoYSA9PT0gKFwiQVwiICsgbGVuICsgXCJHQ01LV1wiKSkgfHxcbiAgICAgICAgICAgICAgICAgKGEuaW5kZXhPZihcIlBCRVMyLVwiKSA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAgKGEgPT09IFwiZGlyXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGVuY3J5cHRLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLms7XG4gIH0sXG4gIGVuY3J5cHRQcm9wczogYWRqdXN0RW5jcnlwdFByb3BzLFxuXG4gIGRlY3J5cHRLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLms7XG4gIH0sXG4gIGRlY3J5cHRQcm9wczogYWRqdXN0RGVjcnlwdFByb3BzLFxuXG4gIHdyYXBLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLms7XG4gIH0sXG4gIHdyYXBQcm9wczogYWRqdXN0RW5jcnlwdFByb3BzLFxuXG4gIHVud3JhcEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUuaztcbiAgfSxcbiAgdW53cmFwUHJvcHM6IGFkanVzdERlY3J5cHRQcm9wcyxcblxuICBzaWduS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5rO1xuICB9LFxuICB2ZXJpZnlLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLms7XG4gIH1cbn07XG5cbi8vIEZhY3RvcnlcbnZhciBKV0tPY3RldEZhY3RvcnkgPSB7XG4gIGt0eTogXCJvY3RcIixcbiAgcHJlcGFyZTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICAvLyBUT0RPOiB2YWxpZGF0ZSBrZXkgcHJvcGVydGllc1xuICAgIHZhciBjZmcgPSBKV0tPY3RldENmZztcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZShwcm9wcyk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICByZXR1cm4gSldLLmhlbHBlcnMudGh1bWJwcmludChjZmcsIGpzb24pO1xuICAgIH0pO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaGFzaCkge1xuICAgICAgdmFyIHByaW50cyA9IHt9O1xuICAgICAgcHJpbnRzW0pXSy5oZWxwZXJzLklOVEVSTkFMUy5USFVNQlBSSU5UX0hBU0hdID0gaGFzaDtcbiAgICAgIHByb3BzW0pXSy5oZWxwZXJzLklOVEVSTkFMUy5USFVNQlBSSU5UX0tFWV0gPSBwcmludHM7XG4gICAgICByZXR1cm4gY2ZnO1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xuICB9LFxuICBnZW5lcmF0ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBzaXplc1xuICAgIHZhciBrZXkgPSB1dGlsLnJhbmRvbUJ5dGVzKHNpemUgLyA4KTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgazoga2V5XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNvbmZpZzogSldLT2N0ZXRDZmcsXG4gIGZhY3Rvcnk6IEpXS09jdGV0RmFjdG9yeVxufSk7XG5cbi8vIHJlZ2lzdHJhdGlvblxuKGZ1bmN0aW9uKFJFR0lTVFJZKSB7XG4gIFJFR0lTVFJZLnJlZ2lzdGVyKEpXS09jdGV0RmFjdG9yeSk7XG59KShyZXF1aXJlKFwiLi9rZXlzdG9yZVwiKS5yZWdpc3RyeSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/octkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/rsakey.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    rsau = __webpack_require__(/*! ../algorithms/rsa-util */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\"),\n    nodeCrypto = (__webpack_require__(/*! ../algorithms/helpers */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\").nodeCrypto);\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"RS256\",\n  \"RS384\",\n  \"RS512\",\n  \"PS256\",\n  \"PS384\",\n  \"PS512\"\n];\nvar WRAP_ALGS = [\n  \"RSA-OAEP\",\n  \"RSA-OAEP-256\",\n  \"RSA1_5\"\n];\n\nvar JWKRsaCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"n\", type: \"binary\"},\n      {name: \"e\", type: \"binary\"}\n    ]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.n && pk.e) {\n      pk.length = pk.n.length * 8;\n    } else {\n      delete pk.e;\n      delete pk.n;\n    }\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"n\", type: \"binary\"},\n      {name: \"e\", type: \"binary\"},\n      {name: \"d\", type: \"binary\"},\n      {name: \"p\", type: \"binary\"},\n      {name: \"q\", type: \"binary\"},\n      {name: \"dp\", type: \"binary\"},\n      {name: \"dq\", type: \"binary\"},\n      {name: \"qi\", type: \"binary\"}\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.d && pk.n && pk.e && pk.p && pk.q && pk.dp && pk.dq && pk.qi) {\n      pk.length = pk.d.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function(json) {\n    if (json.public) {\n      json = json.public;\n    }\n    var fields = {\n      e: json.e,\n      kty: \"RSA\",\n      n: json.n\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    switch (mode) {\n    case \"encrypt\":\n    case \"decrypt\":\n      return [];\n    case \"wrap\":\n      return (keys.public && WRAP_ALGS.slice()) || [];\n    case \"unwrap\":\n      return (keys.private && WRAP_ALGS.slice()) || [];\n    case \"sign\":\n      return (keys.private && SIG_ALGS.slice()) || [];\n    case \"verify\":\n      return (keys.public && SIG_ALGS.slice()) || [];\n    }\n\n    return [];\n  },\n\n  wrapKey: function(alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  signKey: function(alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.public;\n  },\n\n  convertToPEM: function(key, isPrivate) {\n    var k = rsau.convertToForge(key, !isPrivate);\n    if (!isPrivate) {\n      return forge.pki.publicKeyToPem(k);\n    }\n    return forge.pki.privateKeyToPem(k);\n  }\n};\n\nfunction convertBNtoBuffer(bn) {\n  bn = bn.toString(16);\n  if (bn.length % 2) {\n    bn = \"0\" + bn;\n  }\n  return Buffer.from(bn, \"hex\");\n}\n\n// Adapted from digitalbaazar/node-forge/js/rsa.js\nvar validators = {\n  oid: \"1.2.840.113549.1.1.1\",\n  privateKey: {\n    name: \"RSAPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // Version (INTEGER)\n        name: \"RSAPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"version\"\n      },\n      {\n        // modulus (n)\n        name: \"RSAPrivateKey.modulus\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"n\"\n      },\n      {\n        // publicExponent (e)\n        name: \"RSAPrivateKey.publicExponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"e\"\n      },\n      {\n        // privateExponent (d)\n        name: \"RSAPrivateKey.privateExponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // prime1 (p)\n        name: \"RSAPrivateKey.prime1\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"p\"\n      },\n      {\n        // prime2 (q)\n        name: \"RSAPrivateKey.prime2\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"q\"\n      },\n      {\n        // exponent1 (d mod (p-1))\n        name: \"RSAPrivateKey.exponent1\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"dp\"\n      },\n      {\n        // exponent2 (d mod (q-1))\n        name: \"RSAPrivateKey.exponent2\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"dq\"\n      },\n      {\n        // coefficient ((inverse of q) mod p)\n        name: \"RSAPrivateKey.coefficient\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"qi\"\n      }\n    ]\n  },\n  publicKey: {\n    // RSAPublicKey\n    name: \"RSAPublicKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // modulus (n)\n        name: \"RSAPublicKey.modulus\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"n\"\n      },\n      {\n        // publicExponent (e)\n        name: \"RSAPublicKey.exponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"e\"\n      }\n    ]\n  }\n};\n\n// Factory\nvar JWKRsaFactory = {\n  kty: \"RSA\",\n  validators: validators,\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKRsaCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    // TODO: validate key sizes\n    var promise;\n\n    if (nodeCrypto) {\n      promise = new Promise(function (resolve, reject) {\n        forge.pki.rsa.generateKeyPair({\n          bits: size,\n          e: 0x010001\n        }, function (err, key) {\n          if (err) return reject(err);\n          resolve(key.privateKey);\n        });\n      });\n    } else {\n      var key = forge.pki.rsa.generateKeyPair({\n        bits: size,\n        e: 0x010001\n      });\n      promise = Promise.resolve(key.privateKey);\n    }\n\n    return promise.then(function (key) {\n\n      // convert to JSON-ish\n      var result = {};\n      [\n        \"e\",\n        \"n\",\n        \"d\",\n        \"p\",\n        \"q\",\n        {incoming: \"dP\", outgoing: \"dp\"},\n        {incoming: \"dQ\", outgoing: \"dq\"},\n        {incoming: \"qInv\", outgoing: \"qi\"}\n      ].forEach(function(f) {\n        var incoming,\n            outgoing;\n\n        if (\"string\" === typeof f) {\n          incoming = outgoing = f;\n        } else {\n          incoming = f.incoming;\n          outgoing = f.outgoing;\n        }\n\n        if (incoming in key) {\n          result[outgoing] = convertBNtoBuffer(key[incoming]);\n        }\n      });\n\n      return result;\n    });\n  },\n  import: function(input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      // coerce capture.keyValue to DER\n      if (\"string\" === typeof input.keyValue) {\n        input.keyValue = forge.asn1.fromDer(input.keyValue);\n      } else if (Array.isArray(input.keyValue)) {\n        input.keyValue = input.keyValue[0];\n      }\n      // capture key factors\n      var validator = (\"private\" === input.type) ?\n                      validators.privateKey :\n                      validators.publicKey;\n      var capture = {},\n          errors = [];\n      if (!forge.asn1.validate(input.keyValue, validator, capture, errors)) {\n        return null;\n      }\n      input = capture;\n    }\n\n    // convert factors to Buffers\n    var output = {\n      kty: \"RSA\"\n    };\n    [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].forEach(function(f) {\n      if (!(f in input)) {\n        return;\n      }\n      var b = Buffer.from(input[f], \"binary\");\n      // remove leading zero padding if any\n      if (0 === b[0]) {\n        b = b.slice(1);\n      }\n      output[f] = b;\n    });\n    return output;\n  }\n};\n\n// public API\nmodule.exports = Object.freeze({\n  config: JWKRsaCfg,\n  factory: JWKRsaFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKRsaFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svcnNha2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDM0MsaUJBQWlCLHlIQUEyQzs7QUFFNUQ7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBK0I7QUFDeEMsU0FBUywrQkFBK0I7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9yc2FrZXkuanM/N2E5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9yc2EuanMgLSBSU0EgS2V5IFJlcHJlc2VudGF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIHJzYXUgPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtcy9yc2EtdXRpbFwiKSxcbiAgICBub2RlQ3J5cHRvID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXMvaGVscGVyc1wiKS5ub2RlQ3J5cHRvO1xuXG52YXIgSldLID0ge1xuICBCYXNlS2V5OiByZXF1aXJlKFwiLi9iYXNla2V5LmpzXCIpLFxuICBoZWxwZXJzOiByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpXG59O1xuXG52YXIgU0lHX0FMR1MgPSBbXG4gIFwiUlMyNTZcIixcbiAgXCJSUzM4NFwiLFxuICBcIlJTNTEyXCIsXG4gIFwiUFMyNTZcIixcbiAgXCJQUzM4NFwiLFxuICBcIlBTNTEyXCJcbl07XG52YXIgV1JBUF9BTEdTID0gW1xuICBcIlJTQS1PQUVQXCIsXG4gIFwiUlNBLU9BRVAtMjU2XCIsXG4gIFwiUlNBMV81XCJcbl07XG5cbnZhciBKV0tSc2FDZmcgPSB7XG4gIHB1YmxpY0tleTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgZmllbGRzID0gSldLLmhlbHBlcnMuQ09NTU9OX1BST1BTLmNvbmNhdChbXG4gICAgICB7bmFtZTogXCJuXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwiZVwiLCB0eXBlOiBcImJpbmFyeVwifVxuICAgIF0pO1xuICAgIHZhciBwaztcbiAgICBwayA9IEpXSy5oZWxwZXJzLnVucGFja1Byb3BzKHByb3BzLCBmaWVsZHMpO1xuICAgIGlmIChwayAmJiBway5uICYmIHBrLmUpIHtcbiAgICAgIHBrLmxlbmd0aCA9IHBrLm4ubGVuZ3RoICogODtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHBrLmU7XG4gICAgICBkZWxldGUgcGsubjtcbiAgICB9XG5cbiAgICByZXR1cm4gcGs7XG4gIH0sXG4gIHByaXZhdGVLZXk6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGZpZWxkcyA9IEpXSy5oZWxwZXJzLkNPTU1PTl9QUk9QUy5jb25jYXQoW1xuICAgICAge25hbWU6IFwiblwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcImVcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJkXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwicFwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcInFcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJkcFwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcImRxXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwicWlcIiwgdHlwZTogXCJiaW5hcnlcIn1cbiAgICBdKTtcblxuICAgIHZhciBwaztcbiAgICBwayA9IEpXSy5oZWxwZXJzLnVucGFja1Byb3BzKHByb3BzLCBmaWVsZHMpO1xuICAgIGlmIChwayAmJiBway5kICYmIHBrLm4gJiYgcGsuZSAmJiBway5wICYmIHBrLnEgJiYgcGsuZHAgJiYgcGsuZHEgJiYgcGsucWkpIHtcbiAgICAgIHBrLmxlbmd0aCA9IHBrLmQubGVuZ3RoICogODtcbiAgICB9IGVsc2Uge1xuICAgICAgcGsgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBrO1xuICB9LFxuICB0aHVtYnByaW50OiBmdW5jdGlvbihqc29uKSB7XG4gICAgaWYgKGpzb24ucHVibGljKSB7XG4gICAgICBqc29uID0ganNvbi5wdWJsaWM7XG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSB7XG4gICAgICBlOiBqc29uLmUsXG4gICAgICBrdHk6IFwiUlNBXCIsXG4gICAgICBuOiBqc29uLm5cbiAgICB9O1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH0sXG4gIGFsZ29yaXRobXM6IGZ1bmN0aW9uKGtleXMsIG1vZGUpIHtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIFwiZW5jcnlwdFwiOlxuICAgIGNhc2UgXCJkZWNyeXB0XCI6XG4gICAgICByZXR1cm4gW107XG4gICAgY2FzZSBcIndyYXBcIjpcbiAgICAgIHJldHVybiAoa2V5cy5wdWJsaWMgJiYgV1JBUF9BTEdTLnNsaWNlKCkpIHx8IFtdO1xuICAgIGNhc2UgXCJ1bndyYXBcIjpcbiAgICAgIHJldHVybiAoa2V5cy5wcml2YXRlICYmIFdSQVBfQUxHUy5zbGljZSgpKSB8fCBbXTtcbiAgICBjYXNlIFwic2lnblwiOlxuICAgICAgcmV0dXJuIChrZXlzLnByaXZhdGUgJiYgU0lHX0FMR1Muc2xpY2UoKSkgfHwgW107XG4gICAgY2FzZSBcInZlcmlmeVwiOlxuICAgICAgcmV0dXJuIChrZXlzLnB1YmxpYyAmJiBTSUdfQUxHUy5zbGljZSgpKSB8fCBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH0sXG5cbiAgd3JhcEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHVibGljO1xuICB9LFxuICB1bndyYXBLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGU7XG4gIH0sXG5cbiAgc2lnbktleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZTtcbiAgfSxcbiAgdmVyaWZ5S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wdWJsaWM7XG4gIH0sXG5cbiAgY29udmVydFRvUEVNOiBmdW5jdGlvbihrZXksIGlzUHJpdmF0ZSkge1xuICAgIHZhciBrID0gcnNhdS5jb252ZXJ0VG9Gb3JnZShrZXksICFpc1ByaXZhdGUpO1xuICAgIGlmICghaXNQcml2YXRlKSB7XG4gICAgICByZXR1cm4gZm9yZ2UucGtpLnB1YmxpY0tleVRvUGVtKGspO1xuICAgIH1cbiAgICByZXR1cm4gZm9yZ2UucGtpLnByaXZhdGVLZXlUb1BlbShrKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29udmVydEJOdG9CdWZmZXIoYm4pIHtcbiAgYm4gPSBibi50b1N0cmluZygxNik7XG4gIGlmIChibi5sZW5ndGggJSAyKSB7XG4gICAgYm4gPSBcIjBcIiArIGJuO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShibiwgXCJoZXhcIik7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBkaWdpdGFsYmFhemFyL25vZGUtZm9yZ2UvanMvcnNhLmpzXG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgb2lkOiBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCIsXG4gIHByaXZhdGVLZXk6IHtcbiAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXlcIixcbiAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbXG4gICAgICB7XG4gICAgICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS52ZXJzaW9uXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJ2ZXJzaW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5tb2R1bHVzXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkucHVibGljRXhwb25lbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImVcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHJpdmF0ZUV4cG9uZW50IChkKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkucHJpdmF0ZUV4cG9uZW50XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJkXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByaW1lMSAocClcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnByaW1lMVwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwcmltZTIgKHEpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5wcmltZTJcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInFcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gZXhwb25lbnQxIChkIG1vZCAocC0xKSlcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LmV4cG9uZW50MVwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZHBcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gZXhwb25lbnQyIChkIG1vZCAocS0xKSlcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LmV4cG9uZW50MlwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZHFcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gY29lZmZpY2llbnQgKChpbnZlcnNlIG9mIHEpIG1vZCBwKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkuY29lZmZpY2llbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInFpXCJcbiAgICAgIH1cbiAgICBdXG4gIH0sXG4gIHB1YmxpY0tleToge1xuICAgIC8vIFJTQVB1YmxpY0tleVxuICAgIG5hbWU6IFwiUlNBUHVibGljS2V5XCIsXG4gICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICB2YWx1ZTogW1xuICAgICAge1xuICAgICAgICAvLyBtb2R1bHVzIChuKVxuICAgICAgICBuYW1lOiBcIlJTQVB1YmxpY0tleS5tb2R1bHVzXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJuXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHB1YmxpY0V4cG9uZW50IChlKVxuICAgICAgICBuYW1lOiBcIlJTQVB1YmxpY0tleS5leHBvbmVudFwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZVwiXG4gICAgICB9XG4gICAgXVxuICB9XG59O1xuXG4vLyBGYWN0b3J5XG52YXIgSldLUnNhRmFjdG9yeSA9IHtcbiAga3R5OiBcIlJTQVwiLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzLFxuICBwcmVwYXJlOiBmdW5jdGlvbihwcm9wcykge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBwcm9wZXJ0aWVzXG4gICAgdmFyIGNmZyA9IEpXS1JzYUNmZztcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZShwcm9wcyk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICByZXR1cm4gSldLLmhlbHBlcnMudGh1bWJwcmludChjZmcsIGpzb24pO1xuICAgIH0pO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oaGFzaCkge1xuICAgICAgdmFyIHByaW50cyA9IHt9O1xuICAgICAgcHJpbnRzW0pXSy5oZWxwZXJzLklOVEVSTkFMUy5USFVNQlBSSU5UX0hBU0hdID0gaGFzaDtcbiAgICAgIHByb3BzW0pXSy5oZWxwZXJzLklOVEVSTkFMUy5USFVNQlBSSU5UX0tFWV0gPSBwcmludHM7XG4gICAgICByZXR1cm4gY2ZnO1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xuICB9LFxuICBnZW5lcmF0ZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBzaXplc1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKG5vZGVDcnlwdG8pIHtcbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZvcmdlLnBraS5yc2EuZ2VuZXJhdGVLZXlQYWlyKHtcbiAgICAgICAgICBiaXRzOiBzaXplLFxuICAgICAgICAgIGU6IDB4MDEwMDAxXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIGtleSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXNvbHZlKGtleS5wcml2YXRlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleSA9IGZvcmdlLnBraS5yc2EuZ2VuZXJhdGVLZXlQYWlyKHtcbiAgICAgICAgYml0czogc2l6ZSxcbiAgICAgICAgZTogMHgwMTAwMDFcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShrZXkucHJpdmF0ZUtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgIC8vIGNvbnZlcnQgdG8gSlNPTi1pc2hcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIFtcbiAgICAgICAgXCJlXCIsXG4gICAgICAgIFwiblwiLFxuICAgICAgICBcImRcIixcbiAgICAgICAgXCJwXCIsXG4gICAgICAgIFwicVwiLFxuICAgICAgICB7aW5jb21pbmc6IFwiZFBcIiwgb3V0Z29pbmc6IFwiZHBcIn0sXG4gICAgICAgIHtpbmNvbWluZzogXCJkUVwiLCBvdXRnb2luZzogXCJkcVwifSxcbiAgICAgICAge2luY29taW5nOiBcInFJbnZcIiwgb3V0Z29pbmc6IFwicWlcIn1cbiAgICAgIF0uZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgIHZhciBpbmNvbWluZyxcbiAgICAgICAgICAgIG91dGdvaW5nO1xuXG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZikge1xuICAgICAgICAgIGluY29taW5nID0gb3V0Z29pbmcgPSBmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY29taW5nID0gZi5pbmNvbWluZztcbiAgICAgICAgICBvdXRnb2luZyA9IGYub3V0Z29pbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jb21pbmcgaW4ga2V5KSB7XG4gICAgICAgICAgcmVzdWx0W291dGdvaW5nXSA9IGNvbnZlcnRCTnRvQnVmZmVyKGtleVtpbmNvbWluZ10pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfSxcbiAgaW1wb3J0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh2YWxpZGF0b3JzLm9pZCAhPT0gaW5wdXQua2V5T2lkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWlucHV0LnBhcnNlZCkge1xuICAgICAgLy8gY29lcmNlIGNhcHR1cmUua2V5VmFsdWUgdG8gREVSXG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0LmtleVZhbHVlKSB7XG4gICAgICAgIGlucHV0LmtleVZhbHVlID0gZm9yZ2UuYXNuMS5mcm9tRGVyKGlucHV0LmtleVZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dC5rZXlWYWx1ZSkpIHtcbiAgICAgICAgaW5wdXQua2V5VmFsdWUgPSBpbnB1dC5rZXlWYWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIC8vIGNhcHR1cmUga2V5IGZhY3RvcnNcbiAgICAgIHZhciB2YWxpZGF0b3IgPSAoXCJwcml2YXRlXCIgPT09IGlucHV0LnR5cGUpID9cbiAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3JzLnByaXZhdGVLZXkgOlxuICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMucHVibGljS2V5O1xuICAgICAgdmFyIGNhcHR1cmUgPSB7fSxcbiAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgIGlmICghZm9yZ2UuYXNuMS52YWxpZGF0ZShpbnB1dC5rZXlWYWx1ZSwgdmFsaWRhdG9yLCBjYXB0dXJlLCBlcnJvcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5wdXQgPSBjYXB0dXJlO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZmFjdG9ycyB0byBCdWZmZXJzXG4gICAgdmFyIG91dHB1dCA9IHtcbiAgICAgIGt0eTogXCJSU0FcIlxuICAgIH07XG4gICAgW1wiblwiLCBcImVcIiwgXCJkXCIsIFwicFwiLCBcInFcIiwgXCJkcFwiLCBcImRxXCIsIFwicWlcIl0uZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICBpZiAoIShmIGluIGlucHV0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYiA9IEJ1ZmZlci5mcm9tKGlucHV0W2ZdLCBcImJpbmFyeVwiKTtcbiAgICAgIC8vIHJlbW92ZSBsZWFkaW5nIHplcm8gcGFkZGluZyBpZiBhbnlcbiAgICAgIGlmICgwID09PSBiWzBdKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgb3V0cHV0W2ZdID0gYjtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG4vLyBwdWJsaWMgQVBJXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICBjb25maWc6IEpXS1JzYUNmZyxcbiAgZmFjdG9yeTogSldLUnNhRmFjdG9yeVxufSk7XG5cbi8vIHJlZ2lzdHJhdGlvblxuKGZ1bmN0aW9uKFJFR0lTVFJZKSB7XG4gIFJFR0lTVFJZLnJlZ2lzdGVyKEpXS1JzYUZhY3RvcnkpO1xufSkocmVxdWlyZShcIi4va2V5c3RvcmVcIikucmVnaXN0cnkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/defaults.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/defaults.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/*!\n * jws/defaults.js - Defaults for JWSs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\n/**\n * @description\n * The default options for {@link JWS.createSign}.\n *\n * @property {Boolean} compact Determines if the output is the Compact\n *           serialization (`true`) or the JSON serialization (**`false`**,\n *           the default).\n * @property {String|String[]} protect The names of the headers to integrity\n *           protect.  The value `\"\"` means that none of header parameters\n *           are integrity protected, while `\"*\"` (the default) means that all\n *           headers parameter sare integrity protected.\n */\nvar JWSDefaults = {\n    compact: false,\n    protect: \"*\"\n};\n\nmodule.exports = JWSDefaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy9kZWZhdWx0cy5qcz9kN2Q2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandzL2RlZmF1bHRzLmpzIC0gRGVmYXVsdHMgZm9yIEpXU3NcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHtAbGluayBKV1MuY3JlYXRlU2lnbn0uXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufSBjb21wYWN0IERldGVybWluZXMgaWYgdGhlIG91dHB1dCBpcyB0aGUgQ29tcGFjdFxuICogICAgICAgICAgIHNlcmlhbGl6YXRpb24gKGB0cnVlYCkgb3IgdGhlIEpTT04gc2VyaWFsaXphdGlvbiAoKipgZmFsc2VgKiosXG4gKiAgICAgICAgICAgdGhlIGRlZmF1bHQpLlxuICogQHByb3BlcnR5IHtTdHJpbmd8U3RyaW5nW119IHByb3RlY3QgVGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzIHRvIGludGVncml0eVxuICogICAgICAgICAgIHByb3RlY3QuICBUaGUgdmFsdWUgYFwiXCJgIG1lYW5zIHRoYXQgbm9uZSBvZiBoZWFkZXIgcGFyYW1ldGVyc1xuICogICAgICAgICAgIGFyZSBpbnRlZ3JpdHkgcHJvdGVjdGVkLCB3aGlsZSBgXCIqXCJgICh0aGUgZGVmYXVsdCkgbWVhbnMgdGhhdCBhbGxcbiAqICAgICAgICAgICBoZWFkZXJzIHBhcmFtZXRlciBzYXJlIGludGVncml0eSBwcm90ZWN0ZWQuXG4gKi9cbnZhciBKV1NEZWZhdWx0cyA9IHtcbiAgICBjb21wYWN0OiBmYWxzZSxcbiAgICBwcm90ZWN0OiBcIipcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKV1NEZWZhdWx0cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/helpers.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*!\n * jws/helpers.js - JWS Internal Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nmodule.exports = {\n  slice: function(input, start) {\n    return Array.prototype.slice.call(input, start || 0);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaGVscGVycy5qcz9lOGVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandzL2hlbHBlcnMuanMgLSBKV1MgSW50ZXJuYWwgSGVscGVyIEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2xpY2U6IGZ1bmN0aW9uKGlucHV0LCBzdGFydCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dCwgc3RhcnQgfHwgMCk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/index.js - JSON Web Signature (JWS) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWS = {\n  createSign: (__webpack_require__(/*! ./sign */ \"(ssr)/./node_modules/node-jose/lib/jws/sign.js\").createSign),\n  createVerify: (__webpack_require__(/*! ./verify */ \"(ssr)/./node_modules/node-jose/lib/jws/verify.js\").createVerify)\n};\n\nmodule.exports = JWS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0EsY0FBYyxnR0FBNEI7QUFDMUMsZ0JBQWdCLHNHQUFnQztBQUNoRDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaW5kZXguanM/ZjY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3cy9pbmRleC5qcyAtIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKSBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgSldTID0ge1xuICBjcmVhdGVTaWduOiByZXF1aXJlKFwiLi9zaWduXCIpLmNyZWF0ZVNpZ24sXG4gIGNyZWF0ZVZlcmlmeTogcmVxdWlyZShcIi4vdmVyaWZ5XCIpLmNyZWF0ZVZlcmlmeVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKV1M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/sign.js":
/*!************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/sign.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/sign.js - Sign to JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    slice = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jws/helpers.js\").slice);\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\");\n\nvar DEFAULTS = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/node-jose/lib/jws/defaults.js\");\n\n/**\n * @class JWS.Signer\n * @classdesc Generator of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createSign}.\n */\nvar JWSSigner = function(cfg, signatories) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      content = Buffer.alloc(0);\n\n  /**\n  * @member {Boolean} JWS.Signer#compact\n  * @description\n  * Indicates whether the outuput of this signature generator is using\n  * the Compact serialization (`true`) or the JSON serialization\n  * (`false`).\n  */\n  Object.defineProperty(this, \"compact\", {\n    get: function() {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"format\", {\n    get: function() {\n      return format;\n    },\n    enumerable: true\n  });\n\n  /**\n  * @method JWS.Signer#update\n  * @description\n  * Updates the signing content for this signature content. The content\n  * is appended to the end of any other content already applied.\n  *\n  * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n  * converted to a Buffer internally to {encoding}.\n  *\n  * @param {Buffer|String} data The data to sign.\n  * @param {String} [encoding=\"binary\"] The encoding of {data}.\n  * @returns {JWS.Signer} This signature generator.\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n  * @method JWS.Signer#final\n  * @description\n  * Finishes the signature operation.\n  *\n  * The returned Promise, when fulfilled, is the JSON Web Signature (JWS)\n  * object, either in the Compact (if {@link JWS.Signer#format} is\n  * `\"compact\"`), the flattened JSON (if {@link JWS.Signer#format} is\n  * \"flattened\"), or the general JSON serialization.\n  *\n  * @param {Buffer|String} [data] The final content to apply.\n  * @param {String} [encoding=\"binary\"] The encoding of the final content\n  *        (if any).\n  * @returns {Promise} The promise for the signatures\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise;\n\n      // map signatory promises to just signatories\n      promise = Promise.all(signatories);\n      promise = promise.then(function(sigs) {\n        // prepare content\n        content = util.base64url.encode(content);\n\n        sigs = sigs.map(function(s) {\n          // prepare protected\n          var protect = {},\n              lenProtect = 0,\n              unprotect = clone(s.header),\n              lenUnprotect = Object.keys(unprotect).length;\n          s.protected.forEach(function(h) {\n            if (!(h in unprotect)) {\n              return;\n            }\n            protect[h] = unprotect[h];\n            lenProtect++;\n            delete unprotect[h];\n            lenUnprotect--;\n          });\n          if (lenProtect > 0) {\n            protect = JSON.stringify(protect);\n            protect = util.base64url.encode(protect);\n          } else {\n            protect = \"\";\n          }\n\n          // signit!\n          var data = Buffer.from(protect + \".\" + content, \"ascii\");\n          s = s.key.sign(s.header.alg, data, s.header);\n          s = s.then(function(result) {\n            var sig = {};\n            if (0 < lenProtect) {\n              sig.protected = protect;\n            }\n            if (0 < lenUnprotect) {\n              sig.header = unprotect;\n            }\n            sig.signature = util.base64url.encode(result.mac);\n            return sig;\n          });\n          return s;\n        });\n        sigs = [Promise.resolve(content)].concat(sigs);\n        return Promise.all(sigs);\n      });\n      promise = promise.then(function(results) {\n        var content = results[0];\n        return {\n          payload: content,\n          signatures: results.slice(1)\n        };\n      });\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jws) {\n            var compact = [\n              jws.signatures[0].protected,\n              jws.payload,\n              jws.signatures[0].signature\n            ];\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jws) {\n            var flattened = {};\n            flattened.payload = jws.payload;\n\n            var sig = jws.signatures[0];\n            if (sig.protected) {\n              flattened.protected = sig.protected;\n            }\n            if (sig.header) {\n              flattened.header = sig.header;\n            }\n            flattened.signature = sig.signature;\n\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n};\n\n\n/**\n * @description\n * Creates a new JWS.Signer with the given options and signatories.\n *\n * @param {Object} [opts] The signing options\n * @param {Boolean} [opts.compact] Use compact serialization?\n * @param {String} [opts.format] The serialization format to use (\"compact\",\n *                 \"flattened\", \"general\")\n * @param {Object} [opts.fields] Additional header fields\n * @param {JWK.Key[]|Object[]} [signs] Signatories, either as an array of\n *        JWK.Key instances; or an array of objects, each with the following\n *        properties\n * @param {JWK.Key} signs.key Key used to sign content\n * @param {Object} [signs.header] Per-signatory header fields\n * @param {String} [signs.reference] Reference field to identify the key\n * @param {String[]|String} [signs.protect] List of fields to integrity\n *        protect (\"*\" to protect all fields)\n * @returns {JWS.Signer} The signature generator.\n * @throws {Error} If Compact serialization is requested but there are\n *         multiple signatories\n */\nfunction createSign(opts, signs) {\n  // fixup signatories\n  var options = opts,\n      signStart = 1,\n      signList = signs;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one signatory must be provided\");\n  }\n  if (arguments.length === 1) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n            (opts && \"kty\" in opts) ||\n            (opts && \"key\" in opts &&\n            (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(signList)) {\n    signList = slice(arguments, signStart);\n  }\n\n  // fixup options\n  options = merge(clone(DEFAULTS), options);\n\n  // setup header fields\n  var allFields = options.fields || {};\n  // setup serialization format\n  var format = options.format;\n  if (!format) {\n    format = options.compact ? \"compact\" : \"general\";\n  }\n  if ((\"compact\" === format || \"flattened\" === format) && 1 < signList.length) {\n    throw new Error(\"too many signatories for compact or flattened JSON serialization\");\n  }\n\n  // note protected fields (globally)\n  // protected fields are per signature\n  var protectAll = (\"*\" === options.protect);\n  if (options.compact) {\n    protectAll = true;\n  }\n\n  signList = signList.map(function(s, idx) {\n    var p;\n\n    // resolve a key\n    if (s && \"kty\" in s) {\n      p = JWK.asKey(s);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (s) {\n      p = JWK.asKey(s.key);\n      p = p.then(function(k) {\n        return {\n          header: s.header,\n          reference: s.reference,\n          protect: s.protect,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for signatory \" + idx));\n    }\n\n    // resolve the complete signatory\n    p = p.then(function(signatory) {\n      var key = signatory.key;\n\n      // make sure there is a header\n      var header = signatory.header || {};\n      header = merge(merge({}, allFields), header);\n      signatory.header = header;\n\n      // ensure an algorithm\n      if (!header.alg) {\n        header.alg = key.algorithms(JWK.MODE_SIGN)[0] || \"\";\n      }\n\n      // determine the key reference\n      var ref = signatory.reference;\n      delete signatory.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // determine protected fields\n      var protect = signatory.protect;\n      if (protectAll || \"*\" === protect) {\n        protect = Object.keys(header);\n      } else if (\"string\" === protect) {\n        protect = [protect];\n      } else if (Array.isArray(protect)) {\n        protect = protect.concat();\n      } else if (!protect) {\n        protect = [];\n      } else {\n        return Promise.reject(new Error(\"protect must be a list of fields\"));\n      }\n      protect = uniq(protect);\n      signatory.protected = protect;\n\n      // freeze signatory\n      signatory = Object.freeze(signatory);\n      return signatory;\n    });\n\n    return p;\n  });\n\n  var cfg = {\n    format: format\n  };\n  return new JWSSigner(cfg,\n                       signList);\n}\n\nmodule.exports = {\n  signer: JWSSigner,\n  createSign: createSign\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3Mvc2lnbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QixVQUFVLG1CQUFPLENBQUMsK0RBQVE7QUFDMUIsWUFBWSxpR0FBMEI7O0FBRXRDLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNLGNBQWMsVUFBVSx3QkFBd0IsTUFBTTtBQUNwRSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVEscUNBQXFDLEtBQUs7QUFDOUQsY0FBYyxZQUFZO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEUsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWMsU0FBUztBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0IsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxhQUFhLFlBQVk7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy9zaWduLmpzPzYxNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd3Mvc2lnbi5qcyAtIFNpZ24gdG8gSldTXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBKV0sgPSByZXF1aXJlKFwiLi4vandrXCIpLFxuICAgIHNsaWNlID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKS5zbGljZTtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKTtcbnZhciB1bmlxID0gcmVxdWlyZShcImxvZGFzaC91bmlxXCIpO1xuXG52YXIgREVGQVVMVFMgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgSldTLlNpZ25lclxuICogQGNsYXNzZGVzYyBHZW5lcmF0b3Igb2Ygc2lnbmVkIGNvbnRlbnQuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogdGhpcyBjbGFzcyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNhbGwge0BsaW5rXG4gKiBKV1MuY3JlYXRlU2lnbn0uXG4gKi9cbnZhciBKV1NTaWduZXIgPSBmdW5jdGlvbihjZmcsIHNpZ25hdG9yaWVzKSB7XG4gIHZhciBmaW5hbGl6ZWQgPSBmYWxzZSxcbiAgICAgIGZvcm1hdCA9IGNmZy5mb3JtYXQgfHwgXCJnZW5lcmFsXCIsXG4gICAgICBjb250ZW50ID0gQnVmZmVyLmFsbG9jKDApO1xuXG4gIC8qKlxuICAqIEBtZW1iZXIge0Jvb2xlYW59IEpXUy5TaWduZXIjY29tcGFjdFxuICAqIEBkZXNjcmlwdGlvblxuICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBvdXR1cHV0IG9mIHRoaXMgc2lnbmF0dXJlIGdlbmVyYXRvciBpcyB1c2luZ1xuICAqIHRoZSBDb21wYWN0IHNlcmlhbGl6YXRpb24gKGB0cnVlYCkgb3IgdGhlIEpTT04gc2VyaWFsaXphdGlvblxuICAqIChgZmFsc2VgKS5cbiAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tcGFjdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImNvbXBhY3RcIiA9PT0gZm9ybWF0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZm9ybWF0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG5cbiAgLyoqXG4gICogQG1ldGhvZCBKV1MuU2lnbmVyI3VwZGF0ZVxuICAqIEBkZXNjcmlwdGlvblxuICAqIFVwZGF0ZXMgdGhlIHNpZ25pbmcgY29udGVudCBmb3IgdGhpcyBzaWduYXR1cmUgY29udGVudC4gVGhlIGNvbnRlbnRcbiAgKiBpcyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIGFueSBvdGhlciBjb250ZW50IGFscmVhZHkgYXBwbGllZC5cbiAgKlxuICAqIElmIHtkYXRhfSBpcyBhIEJ1ZmZlciwge2VuY29kaW5nfSBpcyBpZ25vcmVkLiBPdGhlcndpc2UsIHtkYXRhfSBpc1xuICAqIGNvbnZlcnRlZCB0byBhIEJ1ZmZlciBpbnRlcm5hbGx5IHRvIHtlbmNvZGluZ30uXG4gICpcbiAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gc2lnbi5cbiAgKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nPVwiYmluYXJ5XCJdIFRoZSBlbmNvZGluZyBvZiB7ZGF0YX0uXG4gICogQHJldHVybnMge0pXUy5TaWduZXJ9IFRoaXMgc2lnbmF0dXJlIGdlbmVyYXRvci5cbiAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBzaWduYXR1cmUgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQuXG4gICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVwZGF0ZVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICBpZiAoZmluYWxpemVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGRhdGEgPSB1dGlsLmFzQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGVudCA9IEJ1ZmZlci5jb25jYXQoW2NvbnRlbnQsIGRhdGFdLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQubGVuZ3RoICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAqIEBtZXRob2QgSldTLlNpZ25lciNmaW5hbFxuICAqIEBkZXNjcmlwdGlvblxuICAqIEZpbmlzaGVzIHRoZSBzaWduYXR1cmUgb3BlcmF0aW9uLlxuICAqXG4gICogVGhlIHJldHVybmVkIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCBpcyB0aGUgSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICogb2JqZWN0LCBlaXRoZXIgaW4gdGhlIENvbXBhY3QgKGlmIHtAbGluayBKV1MuU2lnbmVyI2Zvcm1hdH0gaXNcbiAgKiBgXCJjb21wYWN0XCJgKSwgdGhlIGZsYXR0ZW5lZCBKU09OIChpZiB7QGxpbmsgSldTLlNpZ25lciNmb3JtYXR9IGlzXG4gICogXCJmbGF0dGVuZWRcIiksIG9yIHRoZSBnZW5lcmFsIEpTT04gc2VyaWFsaXphdGlvbi5cbiAgKlxuICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gW2RhdGFdIFRoZSBmaW5hbCBjb250ZW50IHRvIGFwcGx5LlxuICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9XCJiaW5hcnlcIl0gVGhlIGVuY29kaW5nIG9mIHRoZSBmaW5hbCBjb250ZW50XG4gICogICAgICAgIChpZiBhbnkpLlxuICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHNpZ25hdHVyZXNcbiAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBzaWduYXR1cmUgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQuXG4gICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbmFsXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgIGlmIChmaW5hbGl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImFscmVhZHkgZmluYWxcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBsYXN0LW1pbnV0ZSBkYXRhXG4gICAgICB0aGlzLnVwZGF0ZShkYXRhLCBlbmNvZGluZyk7XG5cbiAgICAgIC8vIG1hcmsgYXMgZG9uZS4uLmlzaFxuICAgICAgZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAvLyBtYXAgc2lnbmF0b3J5IHByb21pc2VzIHRvIGp1c3Qgc2lnbmF0b3JpZXNcbiAgICAgIHByb21pc2UgPSBQcm9taXNlLmFsbChzaWduYXRvcmllcyk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNpZ3MpIHtcbiAgICAgICAgLy8gcHJlcGFyZSBjb250ZW50XG4gICAgICAgIGNvbnRlbnQgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUoY29udGVudCk7XG5cbiAgICAgICAgc2lncyA9IHNpZ3MubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAvLyBwcmVwYXJlIHByb3RlY3RlZFxuICAgICAgICAgIHZhciBwcm90ZWN0ID0ge30sXG4gICAgICAgICAgICAgIGxlblByb3RlY3QgPSAwLFxuICAgICAgICAgICAgICB1bnByb3RlY3QgPSBjbG9uZShzLmhlYWRlciksXG4gICAgICAgICAgICAgIGxlblVucHJvdGVjdCA9IE9iamVjdC5rZXlzKHVucHJvdGVjdCkubGVuZ3RoO1xuICAgICAgICAgIHMucHJvdGVjdGVkLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgaWYgKCEoaCBpbiB1bnByb3RlY3QpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3RlY3RbaF0gPSB1bnByb3RlY3RbaF07XG4gICAgICAgICAgICBsZW5Qcm90ZWN0Kys7XG4gICAgICAgICAgICBkZWxldGUgdW5wcm90ZWN0W2hdO1xuICAgICAgICAgICAgbGVuVW5wcm90ZWN0LS07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGxlblByb3RlY3QgPiAwKSB7XG4gICAgICAgICAgICBwcm90ZWN0ID0gSlNPTi5zdHJpbmdpZnkocHJvdGVjdCk7XG4gICAgICAgICAgICBwcm90ZWN0ID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHByb3RlY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90ZWN0ID0gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBzaWduaXQhXG4gICAgICAgICAgdmFyIGRhdGEgPSBCdWZmZXIuZnJvbShwcm90ZWN0ICsgXCIuXCIgKyBjb250ZW50LCBcImFzY2lpXCIpO1xuICAgICAgICAgIHMgPSBzLmtleS5zaWduKHMuaGVhZGVyLmFsZywgZGF0YSwgcy5oZWFkZXIpO1xuICAgICAgICAgIHMgPSBzLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgc2lnID0ge307XG4gICAgICAgICAgICBpZiAoMCA8IGxlblByb3RlY3QpIHtcbiAgICAgICAgICAgICAgc2lnLnByb3RlY3RlZCA9IHByb3RlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA8IGxlblVucHJvdGVjdCkge1xuICAgICAgICAgICAgICBzaWcuaGVhZGVyID0gdW5wcm90ZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnLnNpZ25hdHVyZSA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHQubWFjKTtcbiAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH0pO1xuICAgICAgICBzaWdzID0gW1Byb21pc2UucmVzb2x2ZShjb250ZW50KV0uY29uY2F0KHNpZ3MpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2lncyk7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICB2YXIgY29udGVudCA9IHJlc3VsdHNbMF07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF5bG9hZDogY29udGVudCxcbiAgICAgICAgICBzaWduYXR1cmVzOiByZXN1bHRzLnNsaWNlKDEpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgXCJjb21wYWN0XCI6XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd3MpIHtcbiAgICAgICAgICAgIHZhciBjb21wYWN0ID0gW1xuICAgICAgICAgICAgICBqd3Muc2lnbmF0dXJlc1swXS5wcm90ZWN0ZWQsXG4gICAgICAgICAgICAgIGp3cy5wYXlsb2FkLFxuICAgICAgICAgICAgICBqd3Muc2lnbmF0dXJlc1swXS5zaWduYXR1cmVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb21wYWN0ID0gY29tcGFjdC5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wYWN0O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZmxhdHRlbmVkXCI6XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd3MpIHtcbiAgICAgICAgICAgIHZhciBmbGF0dGVuZWQgPSB7fTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5wYXlsb2FkID0gandzLnBheWxvYWQ7XG5cbiAgICAgICAgICAgIHZhciBzaWcgPSBqd3Muc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgIGlmIChzaWcucHJvdGVjdGVkKSB7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZC5wcm90ZWN0ZWQgPSBzaWcucHJvdGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpZy5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkLmhlYWRlciA9IHNpZy5oZWFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbGF0dGVuZWQuc2lnbmF0dXJlID0gc2lnLnNpZ25hdHVyZTtcblxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9KTtcbn07XG5cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBuZXcgSldTLlNpZ25lciB3aXRoIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBzaWduYXRvcmllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIFRoZSBzaWduaW5nIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuY29tcGFjdF0gVXNlIGNvbXBhY3Qgc2VyaWFsaXphdGlvbj9cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5mb3JtYXRdIFRoZSBzZXJpYWxpemF0aW9uIGZvcm1hdCB0byB1c2UgKFwiY29tcGFjdFwiLFxuICogICAgICAgICAgICAgICAgIFwiZmxhdHRlbmVkXCIsIFwiZ2VuZXJhbFwiKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmZpZWxkc10gQWRkaXRpb25hbCBoZWFkZXIgZmllbGRzXG4gKiBAcGFyYW0ge0pXSy5LZXlbXXxPYmplY3RbXX0gW3NpZ25zXSBTaWduYXRvcmllcywgZWl0aGVyIGFzIGFuIGFycmF5IG9mXG4gKiAgICAgICAgSldLLktleSBpbnN0YW5jZXM7IG9yIGFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICAgcHJvcGVydGllc1xuICogQHBhcmFtIHtKV0suS2V5fSBzaWducy5rZXkgS2V5IHVzZWQgdG8gc2lnbiBjb250ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW3NpZ25zLmhlYWRlcl0gUGVyLXNpZ25hdG9yeSBoZWFkZXIgZmllbGRzXG4gKiBAcGFyYW0ge1N0cmluZ30gW3NpZ25zLnJlZmVyZW5jZV0gUmVmZXJlbmNlIGZpZWxkIHRvIGlkZW50aWZ5IHRoZSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfSBbc2lnbnMucHJvdGVjdF0gTGlzdCBvZiBmaWVsZHMgdG8gaW50ZWdyaXR5XG4gKiAgICAgICAgcHJvdGVjdCAoXCIqXCIgdG8gcHJvdGVjdCBhbGwgZmllbGRzKVxuICogQHJldHVybnMge0pXUy5TaWduZXJ9IFRoZSBzaWduYXR1cmUgZ2VuZXJhdG9yLlxuICogQHRocm93cyB7RXJyb3J9IElmIENvbXBhY3Qgc2VyaWFsaXphdGlvbiBpcyByZXF1ZXN0ZWQgYnV0IHRoZXJlIGFyZVxuICogICAgICAgICBtdWx0aXBsZSBzaWduYXRvcmllc1xuICovXG5mdW5jdGlvbiBjcmVhdGVTaWduKG9wdHMsIHNpZ25zKSB7XG4gIC8vIGZpeHVwIHNpZ25hdG9yaWVzXG4gIHZhciBvcHRpb25zID0gb3B0cyxcbiAgICAgIHNpZ25TdGFydCA9IDEsXG4gICAgICBzaWduTGlzdCA9IHNpZ25zO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXQgbGVhc3Qgb25lIHNpZ25hdG9yeSBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgc2lnbkxpc3QgPSBvcHRzO1xuICAgIHNpZ25TdGFydCA9IDA7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IGVsc2UgaWYgKEpXSy5pc0tleShvcHRzKSB8fFxuICAgICAgICAgICAgKG9wdHMgJiYgXCJrdHlcIiBpbiBvcHRzKSB8fFxuICAgICAgICAgICAgKG9wdHMgJiYgXCJrZXlcIiBpbiBvcHRzICYmXG4gICAgICAgICAgICAoSldLLmlzS2V5KG9wdHMua2V5KSB8fCBcImt0eVwiIGluIG9wdHMua2V5KSkpIHtcbiAgICBzaWduTGlzdCA9IG9wdHM7XG4gICAgc2lnblN0YXJ0ID0gMDtcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IGNsb25lKG9wdHMpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzaWduTGlzdCkpIHtcbiAgICBzaWduTGlzdCA9IHNsaWNlKGFyZ3VtZW50cywgc2lnblN0YXJ0KTtcbiAgfVxuXG4gIC8vIGZpeHVwIG9wdGlvbnNcbiAgb3B0aW9ucyA9IG1lcmdlKGNsb25lKERFRkFVTFRTKSwgb3B0aW9ucyk7XG5cbiAgLy8gc2V0dXAgaGVhZGVyIGZpZWxkc1xuICB2YXIgYWxsRmllbGRzID0gb3B0aW9ucy5maWVsZHMgfHwge307XG4gIC8vIHNldHVwIHNlcmlhbGl6YXRpb24gZm9ybWF0XG4gIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgaWYgKCFmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSBvcHRpb25zLmNvbXBhY3QgPyBcImNvbXBhY3RcIiA6IFwiZ2VuZXJhbFwiO1xuICB9XG4gIGlmICgoXCJjb21wYWN0XCIgPT09IGZvcm1hdCB8fCBcImZsYXR0ZW5lZFwiID09PSBmb3JtYXQpICYmIDEgPCBzaWduTGlzdC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBzaWduYXRvcmllcyBmb3IgY29tcGFjdCBvciBmbGF0dGVuZWQgSlNPTiBzZXJpYWxpemF0aW9uXCIpO1xuICB9XG5cbiAgLy8gbm90ZSBwcm90ZWN0ZWQgZmllbGRzIChnbG9iYWxseSlcbiAgLy8gcHJvdGVjdGVkIGZpZWxkcyBhcmUgcGVyIHNpZ25hdHVyZVxuICB2YXIgcHJvdGVjdEFsbCA9IChcIipcIiA9PT0gb3B0aW9ucy5wcm90ZWN0KTtcbiAgaWYgKG9wdGlvbnMuY29tcGFjdCkge1xuICAgIHByb3RlY3RBbGwgPSB0cnVlO1xuICB9XG5cbiAgc2lnbkxpc3QgPSBzaWduTGlzdC5tYXAoZnVuY3Rpb24ocywgaWR4KSB7XG4gICAgdmFyIHA7XG5cbiAgICAvLyByZXNvbHZlIGEga2V5XG4gICAgaWYgKHMgJiYgXCJrdHlcIiBpbiBzKSB7XG4gICAgICBwID0gSldLLmFzS2V5KHMpO1xuICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5OiBrXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHMpIHtcbiAgICAgIHAgPSBKV0suYXNLZXkocy5rZXkpO1xuICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihrKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhZGVyOiBzLmhlYWRlcixcbiAgICAgICAgICByZWZlcmVuY2U6IHMucmVmZXJlbmNlLFxuICAgICAgICAgIHByb3RlY3Q6IHMucHJvdGVjdCxcbiAgICAgICAgICBrZXk6IGtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBrZXkgZm9yIHNpZ25hdG9yeSBcIiArIGlkeCkpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgdGhlIGNvbXBsZXRlIHNpZ25hdG9yeVxuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oc2lnbmF0b3J5KSB7XG4gICAgICB2YXIga2V5ID0gc2lnbmF0b3J5LmtleTtcblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIGEgaGVhZGVyXG4gICAgICB2YXIgaGVhZGVyID0gc2lnbmF0b3J5LmhlYWRlciB8fCB7fTtcbiAgICAgIGhlYWRlciA9IG1lcmdlKG1lcmdlKHt9LCBhbGxGaWVsZHMpLCBoZWFkZXIpO1xuICAgICAgc2lnbmF0b3J5LmhlYWRlciA9IGhlYWRlcjtcblxuICAgICAgLy8gZW5zdXJlIGFuIGFsZ29yaXRobVxuICAgICAgaWYgKCFoZWFkZXIuYWxnKSB7XG4gICAgICAgIGhlYWRlci5hbGcgPSBrZXkuYWxnb3JpdGhtcyhKV0suTU9ERV9TSUdOKVswXSB8fCBcIlwiO1xuICAgICAgfVxuXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIGtleSByZWZlcmVuY2VcbiAgICAgIHZhciByZWYgPSBzaWduYXRvcnkucmVmZXJlbmNlO1xuICAgICAgZGVsZXRlIHNpZ25hdG9yeS5yZWZlcmVuY2U7XG4gICAgICBpZiAodW5kZWZpbmVkID09PSByZWYpIHtcbiAgICAgICAgLy8gaGVhZGVyIGFscmVhZHkgY29udGFpbnMgdGhlIGtleSByZWZlcmVuY2VcbiAgICAgICAgcmVmID0gW1wia2lkXCIsIFwiamt1XCIsIFwieDVjXCIsIFwieDV0XCIsIFwieDV1XCJdLnNvbWUoZnVuY3Rpb24oaykge1xuICAgICAgICAgIHJldHVybiAoayBpbiBoZWFkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVmID0gIXJlZiA/IFwia2lkXCIgOiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChcImJvb2xlYW5cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgICAgICAvLyBleHBsaWNpdCAocG9zaXRpdmUgfCBuZWdhdGl2ZSkgcmVxdWVzdCBmb3Iga2V5IHJlZmVyZW5jZVxuICAgICAgICByZWYgPSByZWYgPyBcImtpZFwiIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBqd2s7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGp3ayA9IGtleS50b0pTT04oKTtcbiAgICAgICAgaWYgKFwiandrXCIgPT09IHJlZikge1xuICAgICAgICAgIGlmIChcIm9jdFwiID09PSBrZXkua3R5KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiY2Fubm90IGVtYmVkIGtleVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhlYWRlci5qd2sgPSBqd2s7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmIGluIGp3aykge1xuICAgICAgICAgIGhlYWRlcltyZWZdID0gandrW3JlZl07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHByb3RlY3RlZCBmaWVsZHNcbiAgICAgIHZhciBwcm90ZWN0ID0gc2lnbmF0b3J5LnByb3RlY3Q7XG4gICAgICBpZiAocHJvdGVjdEFsbCB8fCBcIipcIiA9PT0gcHJvdGVjdCkge1xuICAgICAgICBwcm90ZWN0ID0gT2JqZWN0LmtleXMoaGVhZGVyKTtcbiAgICAgIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gcHJvdGVjdCkge1xuICAgICAgICBwcm90ZWN0ID0gW3Byb3RlY3RdO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByb3RlY3QpKSB7XG4gICAgICAgIHByb3RlY3QgPSBwcm90ZWN0LmNvbmNhdCgpO1xuICAgICAgfSBlbHNlIGlmICghcHJvdGVjdCkge1xuICAgICAgICBwcm90ZWN0ID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwicHJvdGVjdCBtdXN0IGJlIGEgbGlzdCBvZiBmaWVsZHNcIikpO1xuICAgICAgfVxuICAgICAgcHJvdGVjdCA9IHVuaXEocHJvdGVjdCk7XG4gICAgICBzaWduYXRvcnkucHJvdGVjdGVkID0gcHJvdGVjdDtcblxuICAgICAgLy8gZnJlZXplIHNpZ25hdG9yeVxuICAgICAgc2lnbmF0b3J5ID0gT2JqZWN0LmZyZWV6ZShzaWduYXRvcnkpO1xuICAgICAgcmV0dXJuIHNpZ25hdG9yeTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwO1xuICB9KTtcblxuICB2YXIgY2ZnID0ge1xuICAgIGZvcm1hdDogZm9ybWF0XG4gIH07XG4gIHJldHVybiBuZXcgSldTU2lnbmVyKGNmZyxcbiAgICAgICAgICAgICAgICAgICAgICAgc2lnbkxpc3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lnbmVyOiBKV1NTaWduZXIsXG4gIGNyZWF0ZVNpZ246IGNyZWF0ZVNpZ25cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/sign.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/verify.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/verify.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/verify.js - Verifies from a JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    base64url = __webpack_require__(/*! ../util/base64url */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n    AlgConfig = __webpack_require__(/*! ../util/algconfig */ \"(ssr)/./node_modules/node-jose/lib/util/algconfig.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\",\n  allowEmbeddedKey: false\n};\n\n/**\n * @class JWS.Verifier\n * @classdesc Parser of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createVerify}.\n */\nvar JWSVerifier = function(ks, globalOpts) {\n  var assumedKey,\n      keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    keystore = JWK.createKeyStore();\n  }\n\n  globalOpts = merge(DEFAULT_OPTIONS, globalOpts);\n\n  Object.defineProperty(this, \"defaultKey\", {\n    value: assumedKey || undefined,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"keystore\", {\n    value: keystore,\n    enumerable: true\n  });\n\n  Object.defineProperty(this, \"verify\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      if (\"string\" === typeof input) {\n        input = input.split(\".\");\n        input = {\n          payload: input[1],\n          signatures: [\n            {\n              protected: input[0],\n              signature: input[2]\n            }\n          ]\n        };\n      } else if (!input || \"object\" !== typeof input) {\n        throw new Error(\"invalid input\");\n      }\n\n      // fixup \"flattened JSON\" to look like \"general JSON\"\n      if (input.signature) {\n        input.signatures = [\n          {\n            protected: input.protected || undefined,\n            header: input.header || undefined,\n            signature: input.signature\n          }\n        ];\n      }\n\n      // ensure signatories exists\n      var sigList = input.signatures || [{}];\n\n      // combine fields and decode signature per signatory\n      sigList = sigList.map(function(s) {\n        var header = clone(s.header || {});\n        var protect = s.protected ?\n                      JSON.parse(base64url.decode(s.protected, \"utf8\")) :\n                      {};\n        header = merge(header, protect);\n        var signature = base64url.decode(s.signature);\n\n        // process allowed algorithims\n        if (!algSpec.match(header.alg)) {\n          return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n        }\n\n        // process \"crit\" first\n        var crit = protect.crit;\n        if (crit) {\n          if (!Array.isArray(crit)) {\n            return Promise.reject(new Error(\"Invalid 'crit' header\"));\n          }\n          for (var idx = 0; crit.length > idx; idx++) {\n            if (-1 === handlerKeys.indexOf(crit[idx])) {\n              return Promise.reject(new Error(\n                  \"Critical extension is not supported: \" + crit[idx]\n              ));\n            }\n          }\n        }\n        protect = Object.keys(protect);\n\n        return Promise.resolve({\n          protected: protect,\n          aad: s.protected || \"\",\n          header: header,\n          signature: signature\n        });\n      });\n\n      var promise = Promise.all(sigList);\n      promise = promise.then(function(sigList) {\n        return new Promise(function(resolve, reject) {\n          var processSig = function() {\n            var sig = sigList.shift();\n            if (!sig) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            sig = merge({}, sig, {\n              payload: input.payload\n            });\n            var p = Promise.resolve(sig);\n            // find the key\n            p = p.then(function(sig) {\n              var algKey;\n              // TODO: resolve jku, x5c, x5u\n              if (opts.allowEmbeddedKey && sig.header.jwk) {\n                algKey = JWK.asKey(sig.header.jwk);\n              } else if (opts.allowEmbeddedKey && sig.header.x5c) {\n                algKey = sig.header.x5c[0];\n                algKey = Buffer.from(algKey, \"base64\");\n                // TODO: callback to validate chain\n                algKey = JWK.asKey(algKey, \"pkix\");\n              } else {\n                algKey = Promise.resolve(assumedKey || keystore.get({\n                  use: \"sig\",\n                  alg: sig.header.alg,\n                  kid: sig.header.kid\n                }));\n              }\n              return algKey.then(function(k) {\n                if (!k) {\n                  return Promise.reject(new Error(\"key does not match\"));\n                }\n                sig.key = k;\n                return sig;\n              });\n            });\n\n            // process any prepare-verify handlers\n            p = p.then(function(sig) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"function\" === typeof h) {\n                  p = h(sig);\n                } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n                  p = h.prepare(sig);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {sig} is updated\n                return sig;\n              });\n            });\n\n            // prepare verify inputs\n            p = p.then(function(sig) {\n              var aad = sig.aad || \"\",\n                  payload = sig.payload || \"\";\n              var content = Buffer.alloc(1 + aad.length + payload.length),\n                  pos = 0;\n              content.write(aad, pos, \"ascii\");\n              pos += aad.length;\n              content.write(\".\", pos, \"ascii\");\n              pos++;\n\n              if (Buffer.isBuffer(payload)) {\n                payload.copy(content, pos);\n              } else {\n                content.write(payload, pos, \"binary\");\n              }\n              sig.content = content;\n              return sig;\n            });\n\n            p = p.then(function(sig) {\n              return sig.key.verify(sig.header.alg,\n                                    sig.content,\n                                    sig.signature);\n            });\n\n            p = p.then(function(result) {\n              var payload = sig.payload;\n              payload = base64url.decode(payload);\n              return {\n                protected: sig.protected,\n                header: sig.header,\n                payload: payload,\n                signature: result.mac,\n                key: sig.key\n              };\n            });\n\n            // process any post-verify handlers\n            p = p.then(function(jws) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n                  p = h.complete(jws);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {jws} is updated\n                return jws;\n              });\n            });\n            p.then(resolve, processSig);\n          };\n          processSig();\n        });\n      });\n      return promise;\n    }\n  });\n};\n\n/**\n * @description\n * Creates a new JWS.Verifier with the given Key or KeyStore.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for verification.\n * @returns {JWS.Verifier} The new Verifier.\n */\nfunction createVerify(ks, opts) {\n  var vfy = new JWSVerifier(ks, opts);\n\n  return vfy;\n}\n\nmodule.exports = {\n  verifier: JWSVerifier,\n  createVerify: createVerify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLCtEQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy92ZXJpZnkuanM/ZjgwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3cy92ZXJpZnkuanMgLSBWZXJpZmllcyBmcm9tIGEgSldTXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIiksXG4gICAgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKSxcbiAgICBiYXNlNjR1cmwgPSByZXF1aXJlKFwiLi4vdXRpbC9iYXNlNjR1cmxcIiksXG4gICAgQWxnQ29uZmlnID0gcmVxdWlyZShcIi4uL3V0aWwvYWxnY29uZmlnXCIpLFxuICAgIEpXSyA9IHJlcXVpcmUoXCIuLi9qd2tcIik7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGFsZ29yaXRobXM6IFwiKlwiLFxuICBhbGxvd0VtYmVkZGVkS2V5OiBmYWxzZVxufTtcblxuLyoqXG4gKiBAY2xhc3MgSldTLlZlcmlmaWVyXG4gKiBAY2xhc3NkZXNjIFBhcnNlciBvZiBzaWduZWQgY29udGVudC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiB0aGlzIGNsYXNzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQgY2FsbCB7QGxpbmtcbiAqIEpXUy5jcmVhdGVWZXJpZnl9LlxuICovXG52YXIgSldTVmVyaWZpZXIgPSBmdW5jdGlvbihrcywgZ2xvYmFsT3B0cykge1xuICB2YXIgYXNzdW1lZEtleSxcbiAgICAgIGtleXN0b3JlO1xuXG4gIGlmIChKV0suaXNLZXkoa3MpKSB7XG4gICAgYXNzdW1lZEtleSA9IGtzO1xuICAgIGtleXN0b3JlID0gYXNzdW1lZEtleS5rZXlzdG9yZTtcbiAgfSBlbHNlIGlmIChKV0suaXNLZXlTdG9yZShrcykpIHtcbiAgICBrZXlzdG9yZSA9IGtzO1xuICB9IGVsc2Uge1xuICAgIGtleXN0b3JlID0gSldLLmNyZWF0ZUtleVN0b3JlKCk7XG4gIH1cblxuICBnbG9iYWxPcHRzID0gbWVyZ2UoREVGQVVMVF9PUFRJT05TLCBnbG9iYWxPcHRzKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0S2V5XCIsIHtcbiAgICB2YWx1ZTogYXNzdW1lZEtleSB8fCB1bmRlZmluZWQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5c3RvcmVcIiwge1xuICAgIHZhbHVlOiBrZXlzdG9yZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcmlmeVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGlucHV0LCBvcHRzKSB7XG4gICAgICBvcHRzID0gbWVyZ2Uoe30sIGdsb2JhbE9wdHMsIG9wdHMgfHwge30pO1xuICAgICAgdmFyIGV4dHJhSGFuZGxlcnMgPSBvcHRzLmhhbmRsZXJzIHx8IHt9O1xuICAgICAgdmFyIGhhbmRsZXJLZXlzID0gT2JqZWN0LmtleXMoZXh0cmFIYW5kbGVycyk7XG4gICAgICB2YXIgYWxnU3BlYyA9IG5ldyBBbGdDb25maWcob3B0cy5hbGdvcml0aG1zKTtcblxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dCkge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgcGF5bG9hZDogaW5wdXRbMV0sXG4gICAgICAgICAgc2lnbmF0dXJlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwcm90ZWN0ZWQ6IGlucHV0WzBdLFxuICAgICAgICAgICAgICBzaWduYXR1cmU6IGlucHV0WzJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghaW5wdXQgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIGlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5wdXRcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIGZpeHVwIFwiZmxhdHRlbmVkIEpTT05cIiB0byBsb29rIGxpa2UgXCJnZW5lcmFsIEpTT05cIlxuICAgICAgaWYgKGlucHV0LnNpZ25hdHVyZSkge1xuICAgICAgICBpbnB1dC5zaWduYXR1cmVzID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHByb3RlY3RlZDogaW5wdXQucHJvdGVjdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhlYWRlcjogaW5wdXQuaGVhZGVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogaW5wdXQuc2lnbmF0dXJlXG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgc2lnbmF0b3JpZXMgZXhpc3RzXG4gICAgICB2YXIgc2lnTGlzdCA9IGlucHV0LnNpZ25hdHVyZXMgfHwgW3t9XTtcblxuICAgICAgLy8gY29tYmluZSBmaWVsZHMgYW5kIGRlY29kZSBzaWduYXR1cmUgcGVyIHNpZ25hdG9yeVxuICAgICAgc2lnTGlzdCA9IHNpZ0xpc3QubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IGNsb25lKHMuaGVhZGVyIHx8IHt9KTtcbiAgICAgICAgdmFyIHByb3RlY3QgPSBzLnByb3RlY3RlZCA/XG4gICAgICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHMucHJvdGVjdGVkLCBcInV0ZjhcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgICB7fTtcbiAgICAgICAgaGVhZGVyID0gbWVyZ2UoaGVhZGVyLCBwcm90ZWN0KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGJhc2U2NHVybC5kZWNvZGUocy5zaWduYXR1cmUpO1xuXG4gICAgICAgIC8vIHByb2Nlc3MgYWxsb3dlZCBhbGdvcml0aGltc1xuICAgICAgICBpZiAoIWFsZ1NwZWMubWF0Y2goaGVhZGVyLmFsZykpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiQWxnb3JpdGhtIG5vdCBhbGxvd2VkOiBcIiArIGhlYWRlci5hbGcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2Nlc3MgXCJjcml0XCIgZmlyc3RcbiAgICAgICAgdmFyIGNyaXQgPSBwcm90ZWN0LmNyaXQ7XG4gICAgICAgIGlmIChjcml0KSB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNyaXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCAnY3JpdCcgaGVhZGVyXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgY3JpdC5sZW5ndGggPiBpZHg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAoLTEgPT09IGhhbmRsZXJLZXlzLmluZGV4T2YoY3JpdFtpZHhdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJDcml0aWNhbCBleHRlbnNpb24gaXMgbm90IHN1cHBvcnRlZDogXCIgKyBjcml0W2lkeF1cbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3RlY3QgPSBPYmplY3Qua2V5cyhwcm90ZWN0KTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICBwcm90ZWN0ZWQ6IHByb3RlY3QsXG4gICAgICAgICAgYWFkOiBzLnByb3RlY3RlZCB8fCBcIlwiLFxuICAgICAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5hbGwoc2lnTGlzdCk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNpZ0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBwcm9jZXNzU2lnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2lnID0gc2lnTGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIm5vIGtleSBmb3VuZFwiKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2lnID0gbWVyZ2Uoe30sIHNpZywge1xuICAgICAgICAgICAgICBwYXlsb2FkOiBpbnB1dC5wYXlsb2FkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKHNpZyk7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBrZXlcbiAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgICAgICAgIHZhciBhbGdLZXk7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHJlc29sdmUgamt1LCB4NWMsIHg1dVxuICAgICAgICAgICAgICBpZiAob3B0cy5hbGxvd0VtYmVkZGVkS2V5ICYmIHNpZy5oZWFkZXIuandrKSB7XG4gICAgICAgICAgICAgICAgYWxnS2V5ID0gSldLLmFzS2V5KHNpZy5oZWFkZXIuandrKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmFsbG93RW1iZWRkZWRLZXkgJiYgc2lnLmhlYWRlci54NWMpIHtcbiAgICAgICAgICAgICAgICBhbGdLZXkgPSBzaWcuaGVhZGVyLng1Y1swXTtcbiAgICAgICAgICAgICAgICBhbGdLZXkgPSBCdWZmZXIuZnJvbShhbGdLZXksIFwiYmFzZTY0XCIpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNhbGxiYWNrIHRvIHZhbGlkYXRlIGNoYWluXG4gICAgICAgICAgICAgICAgYWxnS2V5ID0gSldLLmFzS2V5KGFsZ0tleSwgXCJwa2l4XCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFsZ0tleSA9IFByb21pc2UucmVzb2x2ZShhc3N1bWVkS2V5IHx8IGtleXN0b3JlLmdldCh7XG4gICAgICAgICAgICAgICAgICB1c2U6IFwic2lnXCIsXG4gICAgICAgICAgICAgICAgICBhbGc6IHNpZy5oZWFkZXIuYWxnLFxuICAgICAgICAgICAgICAgICAga2lkOiBzaWcuaGVhZGVyLmtpZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gYWxnS2V5LnRoZW4oZnVuY3Rpb24oaykge1xuICAgICAgICAgICAgICAgIGlmICghaykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImtleSBkb2VzIG5vdCBtYXRjaFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpZy5rZXkgPSBrO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgYW55IHByZXBhcmUtdmVyaWZ5IGhhbmRsZXJzXG4gICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2luZyA9IFtdO1xuICAgICAgICAgICAgICBoYW5kbGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgICBoID0gZXh0cmFIYW5kbGVyc1toXTtcbiAgICAgICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaCkge1xuICAgICAgICAgICAgICAgICAgcCA9IGgoc2lnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBoICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGgucHJlcGFyZSkge1xuICAgICAgICAgICAgICAgICAgcCA9IGgucHJlcGFyZShzaWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5wdXNoKFByb21pc2UucmVzb2x2ZShwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb2Nlc3NpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgY2FyZSBhYm91dCBpbmRpdmlkdWFsIGhhbmRsZXIgcmVzdWx0c1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSB7c2lnfSBpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcHJlcGFyZSB2ZXJpZnkgaW5wdXRzXG4gICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgICAgICB2YXIgYWFkID0gc2lnLmFhZCB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHNpZy5wYXlsb2FkIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gQnVmZmVyLmFsbG9jKDEgKyBhYWQubGVuZ3RoICsgcGF5bG9hZC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgICAgICAgY29udGVudC53cml0ZShhYWQsIHBvcywgXCJhc2NpaVwiKTtcbiAgICAgICAgICAgICAgcG9zICs9IGFhZC5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnRlbnQud3JpdGUoXCIuXCIsIHBvcywgXCJhc2NpaVwiKTtcbiAgICAgICAgICAgICAgcG9zKys7XG5cbiAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuY29weShjb250ZW50LCBwb3MpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQud3JpdGUocGF5bG9hZCwgcG9zLCBcImJpbmFyeVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzaWcuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBzaWc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpZy5rZXkudmVyaWZ5KHNpZy5oZWFkZXIuYWxnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWcuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHNpZy5wYXlsb2FkO1xuICAgICAgICAgICAgICBwYXlsb2FkID0gYmFzZTY0dXJsLmRlY29kZShwYXlsb2FkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQ6IHNpZy5wcm90ZWN0ZWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBzaWcuaGVhZGVyLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiByZXN1bHQubWFjLFxuICAgICAgICAgICAgICAgIGtleTogc2lnLmtleVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgYW55IHBvc3QtdmVyaWZ5IGhhbmRsZXJzXG4gICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGp3cykge1xuICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2luZyA9IFtdO1xuICAgICAgICAgICAgICBoYW5kbGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgICBoID0gZXh0cmFIYW5kbGVyc1toXTtcbiAgICAgICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGggJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaC5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgcCA9IGguY29tcGxldGUoandzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChQcm9taXNlLnJlc29sdmUocCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFjdHVhbGx5IGNhcmUgYWJvdXQgaW5kaXZpZHVhbCBoYW5kbGVyIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUge2p3c30gaXMgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiBqd3M7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwLnRoZW4ocmVzb2x2ZSwgcHJvY2Vzc1NpZyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBwcm9jZXNzU2lnKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSBuZXcgSldTLlZlcmlmaWVyIHdpdGggdGhlIGdpdmVuIEtleSBvciBLZXlTdG9yZS5cbiAqXG4gKiBAcGFyYW0ge0pXSy5LZXl8SldLLktleVN0b3JlfSBrcyBUaGUgS2V5IG9yIEtleVN0b3JlIHRvIHVzZSBmb3IgdmVyaWZpY2F0aW9uLlxuICogQHJldHVybnMge0pXUy5WZXJpZmllcn0gVGhlIG5ldyBWZXJpZmllci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVmVyaWZ5KGtzLCBvcHRzKSB7XG4gIHZhciB2ZnkgPSBuZXcgSldTVmVyaWZpZXIoa3MsIG9wdHMpO1xuXG4gIHJldHVybiB2Znk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB2ZXJpZmllcjogSldTVmVyaWZpZXIsXG4gIGNyZWF0ZVZlcmlmeTogY3JlYXRlVmVyaWZ5XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/compact.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/compact.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/compact.js - JOSE Compact Serialization Parser\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar jose = {\n  JWE: __webpack_require__(/*! ../jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWS: __webpack_require__(/*! ../jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\"),\n  util: __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\")\n};\n\nfunction parseCompact(input) {\n  var parts = input.split(\".\");\n\n  var type,\n      op;\n  if (3 === parts.length) {\n    // JWS\n    type = \"JWS\";\n    op = function(ks, opts) {\n      return jose.JWS.createVerify(ks).\n             verify(input, opts);\n    };\n  } else if (5 === parts.length) {\n    // JWE\n    type = \"JWE\";\n    op = function(ks, opts) {\n      return jose.JWE.createDecrypt(ks).\n             decrypt(input, opts);\n    };\n  } else {\n    throw new TypeError(\"invalid jose serialization\");\n  }\n\n  // parse header\n  var header;\n  header = jose.util.base64url.decode(parts[0], \"utf8\");\n  header = JSON.parse(header);\n  return {\n    type: type,\n    format: \"compact\",\n    input: input,\n    header: header,\n    perform: op\n  };\n}\n\nmodule.exports = parseCompact;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9jb21wYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBLE9BQU8sbUJBQU8sQ0FBQywrREFBUTtBQUN2QixPQUFPLG1CQUFPLENBQUMsK0RBQVE7QUFDdkIsUUFBUSxtQkFBTyxDQUFDLGlFQUFTO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9jb21wYWN0LmpzP2YwYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwYXJzZS9jb21wYWN0LmpzIC0gSk9TRSBDb21wYWN0IFNlcmlhbGl6YXRpb24gUGFyc2VyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBqb3NlID0ge1xuICBKV0U6IHJlcXVpcmUoXCIuLi9qd2VcIiksXG4gIEpXUzogcmVxdWlyZShcIi4uL2p3c1wiKSxcbiAgdXRpbDogcmVxdWlyZShcIi4uL3V0aWxcIilcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQ29tcGFjdChpbnB1dCkge1xuICB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdChcIi5cIik7XG5cbiAgdmFyIHR5cGUsXG4gICAgICBvcDtcbiAgaWYgKDMgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgIC8vIEpXU1xuICAgIHR5cGUgPSBcIkpXU1wiO1xuICAgIG9wID0gZnVuY3Rpb24oa3MsIG9wdHMpIHtcbiAgICAgIHJldHVybiBqb3NlLkpXUy5jcmVhdGVWZXJpZnkoa3MpLlxuICAgICAgICAgICAgIHZlcmlmeShpbnB1dCwgb3B0cyk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICg1ID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyBKV0VcbiAgICB0eXBlID0gXCJKV0VcIjtcbiAgICBvcCA9IGZ1bmN0aW9uKGtzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gam9zZS5KV0UuY3JlYXRlRGVjcnlwdChrcykuXG4gICAgICAgICAgICAgZGVjcnlwdChpbnB1dCwgb3B0cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBqb3NlIHNlcmlhbGl6YXRpb25cIik7XG4gIH1cblxuICAvLyBwYXJzZSBoZWFkZXJcbiAgdmFyIGhlYWRlcjtcbiAgaGVhZGVyID0gam9zZS51dGlsLmJhc2U2NHVybC5kZWNvZGUocGFydHNbMF0sIFwidXRmOFwiKTtcbiAgaGVhZGVyID0gSlNPTi5wYXJzZShoZWFkZXIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZm9ybWF0OiBcImNvbXBhY3RcIixcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgcGVyZm9ybTogb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUNvbXBhY3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/compact.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/index.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/index.js - JOSE Parser Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar compact = __webpack_require__(/*! ./compact */ \"(ssr)/./node_modules/node-jose/lib/parse/compact.js\"),\n    json = __webpack_require__(/*! ./json */ \"(ssr)/./node_modules/node-jose/lib/parse/json.js\");\n\nvar parse = module.exports = function(input) {\n  if (Buffer.isBuffer(input)) {\n    // assume buffer holds a Compact Serialization string\n    return compact(input.toString(\"ascii\"));\n  } else if (\"string\" === typeof input) {\n    return compact(input);\n  } else if (input) {\n    return json(input);\n  } else {\n    throw new TypeError(\"invalid input\");\n  }\n};\n\nparse.compact = compact;\nparse.json = json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNFQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvcGFyc2UvaW5kZXguanM/ZmQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHBhcnNlL2luZGV4LmpzIC0gSk9TRSBQYXJzZXIgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbXBhY3QgPSByZXF1aXJlKFwiLi9jb21wYWN0XCIpLFxuICAgIGpzb24gPSByZXF1aXJlKFwiLi9qc29uXCIpO1xuXG52YXIgcGFyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoaW5wdXQpKSB7XG4gICAgLy8gYXNzdW1lIGJ1ZmZlciBob2xkcyBhIENvbXBhY3QgU2VyaWFsaXphdGlvbiBzdHJpbmdcbiAgICByZXR1cm4gY29tcGFjdChpbnB1dC50b1N0cmluZyhcImFzY2lpXCIpKTtcbiAgfSBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpIHtcbiAgICByZXR1cm4gY29tcGFjdChpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaW5wdXQpIHtcbiAgICByZXR1cm4ganNvbihpbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgaW5wdXRcIik7XG4gIH1cbn07XG5cbnBhcnNlLmNvbXBhY3QgPSBjb21wYWN0O1xucGFyc2UuanNvbiA9IGpzb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/json.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/json.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/compact.js - JOSE JSON Serialization Parser\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\");\n\nvar jose = {\n  JWE: __webpack_require__(/*! ../jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWS: __webpack_require__(/*! ../jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\"),\n  util: __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\")\n};\n\nfunction parseJSON(input) {\n  var type,\n      op,\n      headers;\n\n  if (\"signatures\" in input || \"signature\" in input) {\n    // JWS\n    type = \"JWS\";\n    op = function(ks, opts) {\n      return jose.JWS.createVerify(ks).\n             verify(input, opts);\n    };\n    // headers can be (signatures[].protected, signatures[].header, signature.protected, signature.header)\n    headers = input.signatures ||\n              [ {\n                protected: input.protected,\n                header: input.header,\n                signature: input.signature\n              }];\n    headers = headers.map(function(sig) {\n      var all = {};\n      if (sig.header) {\n        all = merge(all, sig.header);\n      }\n\n      var prot;\n      if (sig.protected) {\n        prot = sig.protected;\n        prot = jose.util.base64url.decode(prot, \"utf8\");\n        prot = JSON.parse(prot);\n        all = merge(all, prot);\n      }\n\n      return all;\n    });\n  } else if (\"ciphertext\" in input) {\n    // JWE\n    type = \"JWE\";\n    op = function(ks, opts) {\n      return jose.JWE.createDecrypt(ks).\n             decrypt(input, opts);\n    };\n    // headers can be (protected, unprotected, recipients[].header)\n    var root = {};\n    if (input.protected) {\n      root.protected = input.protected;\n      root.protected = jose.util.base64url.decode(root.protected, \"utf8\");\n      root.protected = JSON.parse(root.protected);\n    }\n    if (input.unprotected) {\n      root.unprotected = input.unprotected;\n    }\n\n    headers = input.recipients || [{}];\n    headers = headers.map(function(rcpt) {\n      var all = {};\n      if (rcpt.header) {\n        all = merge(all, rcpt.header);\n      }\n      if (root.unprotected) {\n        all = merge(all, root.unprotected);\n      }\n      if (root.protected) {\n        all = merge(all, root.protected);\n      }\n\n      return all;\n    });\n  }\n\n  return {\n    type: type,\n    format: \"json\",\n    input: input,\n    all: headers,\n    perform: op\n  };\n}\n\nmodule.exports = parseJSON;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9qc29uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsdUVBQWU7O0FBRW5DO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLCtEQUFRO0FBQ3ZCLE9BQU8sbUJBQU8sQ0FBQywrREFBUTtBQUN2QixRQUFRLG1CQUFPLENBQUMsaUVBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9qc29uLmpzPzZmZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBwYXJzZS9jb21wYWN0LmpzIC0gSk9TRSBKU09OIFNlcmlhbGl6YXRpb24gUGFyc2VyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpO1xuXG52YXIgam9zZSA9IHtcbiAgSldFOiByZXF1aXJlKFwiLi4vandlXCIpLFxuICBKV1M6IHJlcXVpcmUoXCIuLi9qd3NcIiksXG4gIHV0aWw6IHJlcXVpcmUoXCIuLi91dGlsXCIpXG59O1xuXG5mdW5jdGlvbiBwYXJzZUpTT04oaW5wdXQpIHtcbiAgdmFyIHR5cGUsXG4gICAgICBvcCxcbiAgICAgIGhlYWRlcnM7XG5cbiAgaWYgKFwic2lnbmF0dXJlc1wiIGluIGlucHV0IHx8IFwic2lnbmF0dXJlXCIgaW4gaW5wdXQpIHtcbiAgICAvLyBKV1NcbiAgICB0eXBlID0gXCJKV1NcIjtcbiAgICBvcCA9IGZ1bmN0aW9uKGtzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gam9zZS5KV1MuY3JlYXRlVmVyaWZ5KGtzKS5cbiAgICAgICAgICAgICB2ZXJpZnkoaW5wdXQsIG9wdHMpO1xuICAgIH07XG4gICAgLy8gaGVhZGVycyBjYW4gYmUgKHNpZ25hdHVyZXNbXS5wcm90ZWN0ZWQsIHNpZ25hdHVyZXNbXS5oZWFkZXIsIHNpZ25hdHVyZS5wcm90ZWN0ZWQsIHNpZ25hdHVyZS5oZWFkZXIpXG4gICAgaGVhZGVycyA9IGlucHV0LnNpZ25hdHVyZXMgfHxcbiAgICAgICAgICAgICAgWyB7XG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkOiBpbnB1dC5wcm90ZWN0ZWQsXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBpbnB1dC5oZWFkZXIsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBpbnB1dC5zaWduYXR1cmVcbiAgICAgICAgICAgICAgfV07XG4gICAgaGVhZGVycyA9IGhlYWRlcnMubWFwKGZ1bmN0aW9uKHNpZykge1xuICAgICAgdmFyIGFsbCA9IHt9O1xuICAgICAgaWYgKHNpZy5oZWFkZXIpIHtcbiAgICAgICAgYWxsID0gbWVyZ2UoYWxsLCBzaWcuaGVhZGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3Q7XG4gICAgICBpZiAoc2lnLnByb3RlY3RlZCkge1xuICAgICAgICBwcm90ID0gc2lnLnByb3RlY3RlZDtcbiAgICAgICAgcHJvdCA9IGpvc2UudXRpbC5iYXNlNjR1cmwuZGVjb2RlKHByb3QsIFwidXRmOFwiKTtcbiAgICAgICAgcHJvdCA9IEpTT04ucGFyc2UocHJvdCk7XG4gICAgICAgIGFsbCA9IG1lcmdlKGFsbCwgcHJvdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGw7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoXCJjaXBoZXJ0ZXh0XCIgaW4gaW5wdXQpIHtcbiAgICAvLyBKV0VcbiAgICB0eXBlID0gXCJKV0VcIjtcbiAgICBvcCA9IGZ1bmN0aW9uKGtzLCBvcHRzKSB7XG4gICAgICByZXR1cm4gam9zZS5KV0UuY3JlYXRlRGVjcnlwdChrcykuXG4gICAgICAgICAgICAgZGVjcnlwdChpbnB1dCwgb3B0cyk7XG4gICAgfTtcbiAgICAvLyBoZWFkZXJzIGNhbiBiZSAocHJvdGVjdGVkLCB1bnByb3RlY3RlZCwgcmVjaXBpZW50c1tdLmhlYWRlcilcbiAgICB2YXIgcm9vdCA9IHt9O1xuICAgIGlmIChpbnB1dC5wcm90ZWN0ZWQpIHtcbiAgICAgIHJvb3QucHJvdGVjdGVkID0gaW5wdXQucHJvdGVjdGVkO1xuICAgICAgcm9vdC5wcm90ZWN0ZWQgPSBqb3NlLnV0aWwuYmFzZTY0dXJsLmRlY29kZShyb290LnByb3RlY3RlZCwgXCJ1dGY4XCIpO1xuICAgICAgcm9vdC5wcm90ZWN0ZWQgPSBKU09OLnBhcnNlKHJvb3QucHJvdGVjdGVkKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnVucHJvdGVjdGVkKSB7XG4gICAgICByb290LnVucHJvdGVjdGVkID0gaW5wdXQudW5wcm90ZWN0ZWQ7XG4gICAgfVxuXG4gICAgaGVhZGVycyA9IGlucHV0LnJlY2lwaWVudHMgfHwgW3t9XTtcbiAgICBoZWFkZXJzID0gaGVhZGVycy5tYXAoZnVuY3Rpb24ocmNwdCkge1xuICAgICAgdmFyIGFsbCA9IHt9O1xuICAgICAgaWYgKHJjcHQuaGVhZGVyKSB7XG4gICAgICAgIGFsbCA9IG1lcmdlKGFsbCwgcmNwdC5oZWFkZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QudW5wcm90ZWN0ZWQpIHtcbiAgICAgICAgYWxsID0gbWVyZ2UoYWxsLCByb290LnVucHJvdGVjdGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb290LnByb3RlY3RlZCkge1xuICAgICAgICBhbGwgPSBtZXJnZShhbGwsIHJvb3QucHJvdGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBmb3JtYXQ6IFwianNvblwiLFxuICAgIGlucHV0OiBpbnB1dCxcbiAgICBhbGw6IGhlYWRlcnMsXG4gICAgcGVyZm9ybTogb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUpTT047XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/algconfig.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/algconfig.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n * util/algconfig.js - Functions for managing algorithm set options\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction quoteRE(str) {\n  return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n}\n\nfunction makeRE(prefix, wildcard, suffix) {\n  var parts = [];\n\n  parts.push(\"^\");\n  if (prefix) {\n    prefix = quoteRE(prefix);\n    parts.push(prefix);\n  }\n  if (wildcard) {\n    parts.push((prefix || suffix) ? \".*\" : \".+\");\n  }\n  if (suffix) {\n    suffix = quoteRE(suffix);\n    parts.push(suffix);\n  }\n  parts.push(\"$\");\n\n  return parts.join(\"\");\n}\n\nvar AlgConfig = function(algspec) {\n  if (!algspec) {\n    algspec = [];\n  } else if (\"string\" === typeof algspec) {\n    algspec = algspec.split(\" \");\n  }\n\n  var specAllowed = [], specDisallowed = [];\n  var ptnAllowed = [], ptnDisallowed = [];\n  var ptn = /^(!)?([^*]*)(\\*?)([^*]*)$/, fmt;\n  algspec.forEach(function (a) {\n    if (!a) { return; }\n\n    ptn.lastIndex = 0;\n    var parts = ptn.exec(a);\n    if (!parts) { return; }\n\n    fmt = \"(\" + makeRE(parts[2], parts[3], parts[4]) + \")\";\n    if (!parts[1]) {\n      // allowed pattern\n      ptnAllowed.push(fmt);\n      specAllowed.push(parts[0]);\n    } else {\n      // disallowed pattern\n      ptnDisallowed.push(fmt);\n      specDisallowed.push(parts[0]);\n    }\n  });\n\n  ptnAllowed = (ptnAllowed.length) ?\n            new RegExp(ptnAllowed.join(\"|\")) :\n            null;\n  ptnDisallowed = (ptnDisallowed.length) ?\n               new RegExp(ptnDisallowed.join(\"|\")) :\n               null;\n  if (!specAllowed.length) {\n    specAllowed = [\"*\"];\n  }\n\n  Object.defineProperty(this, \"spec\", {\n    value: specAllowed.join(\" \") + \" \" + specDisallowed.join(\" \"),\n    enumerable: true\n  });\n  Object.defineProperty(this, \"match\", {\n    value: function(alg) {\n      var result = Boolean(alg);\n\n      if (result && ptnAllowed) {\n        ptnAllowed.lastIndex = 0;\n        result = ptnAllowed.test(alg);\n      }\n      if (result && ptnDisallowed) {\n        ptnDisallowed.lastIndex = 0;\n        result = !ptnDisallowed.test(alg);\n      }\n\n      return result;\n    }\n  });\n}\n\nmodule.exports = AlgConfig;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2FsZ2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9hbGdjb25maWcuanM/NDhkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHV0aWwvYWxnY29uZmlnLmpzIC0gRnVuY3Rpb25zIGZvciBtYW5hZ2luZyBhbGdvcml0aG0gc2V0IG9wdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gcXVvdGVSRShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2csIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiBtYWtlUkUocHJlZml4LCB3aWxkY2FyZCwgc3VmZml4KSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIHBhcnRzLnB1c2goXCJeXCIpO1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJlZml4ID0gcXVvdGVSRShwcmVmaXgpO1xuICAgIHBhcnRzLnB1c2gocHJlZml4KTtcbiAgfVxuICBpZiAod2lsZGNhcmQpIHtcbiAgICBwYXJ0cy5wdXNoKChwcmVmaXggfHwgc3VmZml4KSA/IFwiLipcIiA6IFwiLitcIik7XG4gIH1cbiAgaWYgKHN1ZmZpeCkge1xuICAgIHN1ZmZpeCA9IHF1b3RlUkUoc3VmZml4KTtcbiAgICBwYXJ0cy5wdXNoKHN1ZmZpeCk7XG4gIH1cbiAgcGFydHMucHVzaChcIiRcIik7XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG59XG5cbnZhciBBbGdDb25maWcgPSBmdW5jdGlvbihhbGdzcGVjKSB7XG4gIGlmICghYWxnc3BlYykge1xuICAgIGFsZ3NwZWMgPSBbXTtcbiAgfSBlbHNlIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgYWxnc3BlYykge1xuICAgIGFsZ3NwZWMgPSBhbGdzcGVjLnNwbGl0KFwiIFwiKTtcbiAgfVxuXG4gIHZhciBzcGVjQWxsb3dlZCA9IFtdLCBzcGVjRGlzYWxsb3dlZCA9IFtdO1xuICB2YXIgcHRuQWxsb3dlZCA9IFtdLCBwdG5EaXNhbGxvd2VkID0gW107XG4gIHZhciBwdG4gPSAvXighKT8oW14qXSopKFxcKj8pKFteKl0qKSQvLCBmbXQ7XG4gIGFsZ3NwZWMuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgIGlmICghYSkgeyByZXR1cm47IH1cblxuICAgIHB0bi5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBwYXJ0cyA9IHB0bi5leGVjKGEpO1xuICAgIGlmICghcGFydHMpIHsgcmV0dXJuOyB9XG5cbiAgICBmbXQgPSBcIihcIiArIG1ha2VSRShwYXJ0c1syXSwgcGFydHNbM10sIHBhcnRzWzRdKSArIFwiKVwiO1xuICAgIGlmICghcGFydHNbMV0pIHtcbiAgICAgIC8vIGFsbG93ZWQgcGF0dGVyblxuICAgICAgcHRuQWxsb3dlZC5wdXNoKGZtdCk7XG4gICAgICBzcGVjQWxsb3dlZC5wdXNoKHBhcnRzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGlzYWxsb3dlZCBwYXR0ZXJuXG4gICAgICBwdG5EaXNhbGxvd2VkLnB1c2goZm10KTtcbiAgICAgIHNwZWNEaXNhbGxvd2VkLnB1c2gocGFydHNbMF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcHRuQWxsb3dlZCA9IChwdG5BbGxvd2VkLmxlbmd0aCkgP1xuICAgICAgICAgICAgbmV3IFJlZ0V4cChwdG5BbGxvd2VkLmpvaW4oXCJ8XCIpKSA6XG4gICAgICAgICAgICBudWxsO1xuICBwdG5EaXNhbGxvd2VkID0gKHB0bkRpc2FsbG93ZWQubGVuZ3RoKSA/XG4gICAgICAgICAgICAgICBuZXcgUmVnRXhwKHB0bkRpc2FsbG93ZWQuam9pbihcInxcIikpIDpcbiAgICAgICAgICAgICAgIG51bGw7XG4gIGlmICghc3BlY0FsbG93ZWQubGVuZ3RoKSB7XG4gICAgc3BlY0FsbG93ZWQgPSBbXCIqXCJdO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3BlY1wiLCB7XG4gICAgdmFsdWU6IHNwZWNBbGxvd2VkLmpvaW4oXCIgXCIpICsgXCIgXCIgKyBzcGVjRGlzYWxsb3dlZC5qb2luKFwiIFwiKSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXRjaFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZykge1xuICAgICAgdmFyIHJlc3VsdCA9IEJvb2xlYW4oYWxnKTtcblxuICAgICAgaWYgKHJlc3VsdCAmJiBwdG5BbGxvd2VkKSB7XG4gICAgICAgIHB0bkFsbG93ZWQubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmVzdWx0ID0gcHRuQWxsb3dlZC50ZXN0KGFsZyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmIHB0bkRpc2FsbG93ZWQpIHtcbiAgICAgICAgcHRuRGlzYWxsb3dlZC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXN1bHQgPSAhcHRuRGlzYWxsb3dlZC50ZXN0KGFsZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBbGdDb25maWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/algconfig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/base64url.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/base64url.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/base64url.js - Implementation of web-safe Base64 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar impl = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n\n/**\n * @namespace base64url\n * @description\n * Provides methods to encode and decode data according to the\n * base64url alphabet.\n */\nvar base64url = {\n  /**\n   * @function\n   * Encodes the input to base64url.\n   *\n   * If {input} is a Buffer, then {encoding} is ignored. Otherwise,\n   * {encoding} can be one of \"binary\", \"base64\", \"hex\", \"utf8\".\n   *\n   * @param {Buffer|String} input The data to encode.\n   * @param {String} [encoding = binary] The input encoding format.\n   * @returns {String} the base64url encoding of {input}.\n   */\n  encode: function encode(buffer, encoding) {\n    if (buffer instanceof ArrayBuffer) {\n      buffer = new Uint8Array(buffer);\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = Buffer.from(buffer, encoding);\n    }\n\n    return impl.encode(buffer);\n  },\n  /**\n   * @function\n   * Decodes the input from base64url.\n   *\n   * @param {String} input The data to decode.\n   * @returns {Buffer|String} the base64url decoding of {input}.\n   */\n  decode: impl.toBuffer\n};\n\nmodule.exports = base64url;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLDBEQUFXOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPLG1CQUFtQixVQUFVO0FBQzdDLE1BQU0sVUFBVTtBQUNoQjtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRLDJCQUEyQixNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsZUFBZSwyQkFBMkIsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9iYXNlNjR1cmwuanM/MTAxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHV0aWwvYmFzZTY0dXJsLmpzIC0gSW1wbGVtZW50YXRpb24gb2Ygd2ViLXNhZmUgQmFzZTY0IEVuY29kZXIvRGVjb2RlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW1wbCA9IHJlcXVpcmUoXCJiYXNlNjR1cmxcIik7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBiYXNlNjR1cmxcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXMgbWV0aG9kcyB0byBlbmNvZGUgYW5kIGRlY29kZSBkYXRhIGFjY29yZGluZyB0byB0aGVcbiAqIGJhc2U2NHVybCBhbHBoYWJldC5cbiAqL1xudmFyIGJhc2U2NHVybCA9IHtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBFbmNvZGVzIHRoZSBpbnB1dCB0byBiYXNlNjR1cmwuXG4gICAqXG4gICAqIElmIHtpbnB1dH0gaXMgYSBCdWZmZXIsIHRoZW4ge2VuY29kaW5nfSBpcyBpZ25vcmVkLiBPdGhlcndpc2UsXG4gICAqIHtlbmNvZGluZ30gY2FuIGJlIG9uZSBvZiBcImJpbmFyeVwiLCBcImJhc2U2NFwiLCBcImhleFwiLCBcInV0ZjhcIi5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBpbnB1dCBUaGUgZGF0YSB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2RpbmcgPSBiaW5hcnldIFRoZSBpbnB1dCBlbmNvZGluZyBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBiYXNlNjR1cmwgZW5jb2Rpbmcgb2Yge2lucHV0fS5cbiAgICovXG4gIGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgZW5jb2RpbmcpIHtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyLCBlbmNvZGluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltcGwuZW5jb2RlKGJ1ZmZlcik7XG4gIH0sXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogRGVjb2RlcyB0aGUgaW5wdXQgZnJvbSBiYXNlNjR1cmwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZGF0YSB0byBkZWNvZGUuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ8U3RyaW5nfSB0aGUgYmFzZTY0dXJsIGRlY29kaW5nIG9mIHtpbnB1dH0uXG4gICAqL1xuICBkZWNvZGU6IGltcGwudG9CdWZmZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZTY0dXJsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/databuffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/databuffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/databuffer.js - Forge-compatible Buffer based on Node.js Buffers\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    base64url = __webpack_require__(/*! ./base64url.js */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\");\n\n/**\n *\n */\nfunction DataBuffer(b, options) {\n  options = options || {};\n\n  // treat (views of) (Array)Buffers special\n  // NOTE: default implementation creates copies, but efficiently\n  //       wherever possible\n  if (Buffer.isBuffer(b)) {\n    this.data = b;\n  } else if (forge.util.isArrayBuffer(b)) {\n    b = new Uint8Array(b);\n    this.data = Buffer.from(b);\n  } else if (forge.util.isArrayBufferView(b)) {\n    b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n    this.data = Buffer.from(b);\n  }\n\n  if (this.data) {\n    this.write = this.data.length;\n    b = undefined;\n  }\n\n  // setup growth rate\n  this.growSize = options.growSize || DataBuffer.DEFAULT_GROW_SIZE;\n\n  // initialize pointers and data\n  this.write = this.write || 0;\n  this.read = this.read || 0;\n  if (b) {\n    this.putBytes(b);\n  } else if (!this.data) {\n    this.accommodate(0);\n  }\n\n  // massage read/write pointers\n  options.readOffset = (\"readOffset\" in options) ?\n                       options.readOffset :\n                       this.read;\n  this.write = (\"writeOffset\" in options) ?\n               options.writeOffset :\n               this.write;\n  this.read = Math.min(options.readOffset, this.write);\n}\nDataBuffer.DEFAULT_GROW_SIZE = 16;\n\nDataBuffer.prototype.length = function() {\n  return this.write - this.read;\n};\nDataBuffer.prototype.available = function() {\n  return this.data.length - this.write;\n};\nDataBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\nDataBuffer.prototype.accommodate = function(length) {\n  if (!this.data) {\n    // initializes a new buffer\n    length = Math.max(this.write + length, this.growSize);\n\n    this.data = Buffer.alloc(length);\n  } else if (this.available() < length) {\n    length = Math.max(length, this.growSize);\n\n    // create a new empty buffer, and copy current one into it\n    var src = this.data;\n    var dst = Buffer.alloc(src.length + length);\n    src.copy(dst, 0);\n\n    // set data as the new buffer\n    this.data = dst;\n  }\n  // ensure the rest is 0\n  this.data.fill(0, this.write);\n\n  return this;\n};\nDataBuffer.prototype.clear = function() {\n  this.read = this.write = 0;\n  this.data = Buffer.alloc(0);\n  return this;\n};\nDataBuffer.prototype.truncate = function(count) {\n  // chop off <count> bytes from the end\n  this.write = this.read + Math.max(0, this.length() - count);\n  // ensure the remainder is 0\n  this.data.fill(0, this.write);\n  return this;\n};\nDataBuffer.prototype.compact = function() {\n  if (this.read > 0) {\n    if (this.write === this.read) {\n      this.read = this.write = 0;\n    } else {\n      this.data.copy(this.data, 0, this.read, this.write);\n      this.write = this.write - this.read;\n      this.read = 0;\n    }\n    // ensure remainder is 0\n    this.data.fill(0, this.write);\n  }\n  return this;\n};\nDataBuffer.prototype.copy = function() {\n  return new DataBuffer(this, {\n    readOffset: this.read,\n    writeOffset: this.write,\n    growSize: this.growSize\n  });\n};\n\nDataBuffer.prototype.equals = function(test) {\n  if (!DataBuffer.isBuffer(test)) {\n    return false;\n  }\n\n  if (test.length() !== this.length()) {\n    return false;\n  }\n\n  var rval = true,\n      delta = this.read - test.read;\n  // constant time\n  for (var idx = test.read; test.write > idx; idx++) {\n    rval = rval && (this.data[idx + delta] === test.data[idx]);\n  }\n  return rval;\n};\nDataBuffer.prototype.at = function(idx) {\n  return this.data[this.read + idx];\n};\nDataBuffer.prototype.setAt = function(idx, b) {\n  this.data[this.read + idx] = b;\n  return this;\n};\nDataBuffer.prototype.last = function() {\n  return this.data[this.write - 1];\n};\nDataBuffer.prototype.bytes = function(count) {\n  var rval;\n  if (undefined === count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = \"\";\n  } else {\n    var begin = this.read,\n        end = begin + count,\n        data = this.data.slice(begin, end);\n    rval = String.fromCharCode.apply(null, data);\n  }\n\n  return rval;\n};\nDataBuffer.prototype.buffer = function(count) {\n  var rval;\n  if (undefined === count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = new ArrayBuffer(0);\n  } else {\n    var begin = this.read,\n        end = begin + count,\n        data = this.data.slice(begin, end);\n    rval = new Uint8Array(end - begin);\n    rval.set(data);\n  }\n\n  return rval;\n};\nDataBuffer.prototype.native = function(count) {\n  var rval;\n  if (\"undefined\" === typeof count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = Buffer.alloc(0);\n  } else {\n    var begin = this.read,\n        end = begin + count;\n    rval = this.data.slice(begin, end);\n  }\n\n  return rval;\n};\n\nDataBuffer.prototype.toHex = function() {\n  return this.toString(\"hex\");\n};\nDataBuffer.prototype.toString = function(encoding) {\n  // short circuit empty string\n  if (0 === this.length()) {\n    return \"\";\n  }\n\n  var view = this.data.slice(this.read, this.write);\n  encoding = encoding || \"utf8\";\n  // special cases, then built-in support\n  switch (encoding) {\n    case \"raw\":\n      return view.toString(\"binary\");\n    case \"base64url\":\n      return base64url.encode(view);\n    case \"utf16\":\n      return view.toString(\"ucs2\");\n    default:\n      return view.toString(encoding);\n  }\n};\n\nDataBuffer.prototype.fillWithByte = function(b, n) {\n  if (!n) {\n    n = this.available();\n  }\n  this.accommodate(n);\n  this.data.fill(b, this.write, this.write + n);\n  this.write += n;\n\n  return this;\n};\n\nDataBuffer.prototype.getBuffer = function(count) {\n  var rval = this.buffer(count);\n  this.read += rval.byteLength;\n\n  return rval;\n};\nDataBuffer.prototype.putBuffer = function(bytes) {\n  return this.putBytes(bytes);\n};\n\nDataBuffer.prototype.getBytes = function(count) {\n  var rval = this.bytes(count);\n  this.read += rval.length;\n  return rval;\n};\nDataBuffer.prototype.putBytes = function(bytes, encoding) {\n  if (\"string\" === typeof bytes) {\n    // fixup encoding\n    encoding = encoding || \"binary\";\n    switch (encoding) {\n      case \"utf16\":\n        // treat as UCS-2/UTF-16BE\n        encoding = \"ucs-2\";\n        break;\n      case \"raw\":\n        encoding = \"binary\";\n        break;\n      case \"base64url\":\n        // NOTE: this returns a Buffer\n        bytes = base64url.decode(bytes);\n        break;\n    }\n\n    // replace bytes with decoded Buffer (if not already)\n    if (!Buffer.isBuffer(bytes)) {\n      bytes = Buffer.from(bytes, encoding);\n    }\n  }\n\n  var src, dst;\n  if (bytes instanceof DataBuffer) {\n    // be slightly more efficient\n    var orig = bytes;\n    bytes = orig.data.slice(orig.read, orig.write);\n    orig.read = orig.write;\n  } else if (bytes instanceof forge.util.ByteStringBuffer) {\n    bytes = bytes.getBytes();\n  }\n\n  // process array\n  if (Buffer.isBuffer(bytes)) {\n    src = bytes;\n  } else if (Array.isArray(bytes)) {\n    src = Buffer.from(bytes);\n  } else if (forge.util.isArrayBuffer(bytes)) {\n    src = new Uint8Array(bytes);\n    src = Buffer.from(src);\n  } else if (forge.util.isArrayBufferView(bytes)) {\n    src = (bytes instanceof Uint8Array) ?\n              bytes :\n              new Uint8Array(bytes.buffer,\n                             bytes.byteOffset,\n                             bytes.byteLength);\n    src = Buffer.from(src);\n  } else {\n    throw new TypeError(\"invalid source type\");\n  }\n\n  this.accommodate(src.length);\n  dst = this.data;\n  src.copy(dst, this.write);\n  this.write += src.length;\n\n  return this;\n};\n\nDataBuffer.prototype.getNative = function(count) {\n  var rval = this.native(count);\n  this.read += rval.length;\n  return rval;\n};\nDataBuffer.prototype.putNative = DataBuffer.prototype.putBuffer;\n\nDataBuffer.prototype.getByte = function() {\n  var b = this.data[this.read];\n  this.read = Math.min(this.read + 1, this.write);\n  return b;\n};\nDataBuffer.prototype.putByte = function(b) {\n  this.accommodate(1);\n  this.data[this.write] = b & 0xff;\n  this.write++;\n\n  return this;\n};\n\nDataBuffer.prototype.getInt16 = function() {\n  var n = (this.data[this.read] << 8) ^\n          (this.data[this.read + 1]);\n  this.read = Math.min(this.read + 2, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt16 = function(n) {\n  this.accommodate(2);\n  this.data[this.write] = (n >>> 8) & 0xff;\n  this.data[this.write + 1] = n & 0xff;\n  this.write += 2;\n  return this;\n};\n\nDataBuffer.prototype.getInt24 = function() {\n  var n = (this.data[this.read] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read + 2];\n  this.read = Math.min(this.read + 3, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt24 = function(n) {\n  this.accommodate(3);\n  this.data[this.write] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write + 2] = n & 0xff;\n  this.write += 3;\n  return this;\n};\n\nDataBuffer.prototype.getInt32 = function() {\n  var n = (this.data[this.read] << 24) ^\n          (this.data[this.read + 1] << 16) ^\n          (this.data[this.read + 2] << 8) ^\n          this.data[this.read + 3];\n  this.read = Math.min(this.read + 4, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt32 = function(n) {\n  this.accommodate(4);\n  this.data[this.write] = (n >>> 24) & 0xff;\n  this.data[this.write + 1] = (n >>> 16) & 0xff;\n  this.data[this.write + 2] = (n >>> 8) & 0xff;\n  this.data[this.write + 3] = n & 0xff;\n  this.write += 4;\n  return this;\n};\n\nDataBuffer.prototype.getInt16Le = function() {\n  var n = (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 2, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt16Le = function(n) {\n  this.accommodate(2);\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 2;\n  return this;\n};\n\nDataBuffer.prototype.getInt24Le = function() {\n  var n = (this.data[this.read + 2] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 3, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt24Le = function(n) {\n  this.accommodate(3);\n  this.data[this.write + 2] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 3;\n  return this;\n};\nDataBuffer.prototype.getInt32Le = function() {\n  var n = (this.data[this.read + 3] << 24) ^\n          (this.data[this.read + 2] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 4, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt32Le = function(n) {\n  this.accommodate(4);\n  this.data[this.write + 3] = (n >>> 24) & 0xff;\n  this.data[this.write + 2] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 4;\n  return this;\n};\n\nDataBuffer.prototype.getInt = function(bits) {\n  var rval = 0;\n  do {\n    rval = (rval << 8) | this.getByte();\n    bits -= 8;\n  } while (bits > 0);\n  return rval;\n};\nDataBuffer.prototype.putInt = function(n, bits) {\n  this.accommodate(Math.ceil(bits / 8));\n  do {\n    bits -= 8;\n    this.putByte((n >> bits) & 0xff);\n  } while (bits > 0);\n  return this;\n};\n\nDataBuffer.prototype.putSignedInt = function(n, bits) {\n  if (n < 0) {\n    n += 2 << (bits - 1);\n  }\n  return this.putInt(n, bits);\n};\n\nDataBuffer.prototype.putString = function(str) {\n  return this.putBytes(str, \"utf16\");\n};\n\nDataBuffer.isBuffer = function(test) {\n  return (test instanceof DataBuffer);\n};\nDataBuffer.asBuffer = function(orig) {\n  return DataBuffer.isBuffer(orig) ?\n         orig :\n         orig ?\n         new DataBuffer(orig) :\n         new DataBuffer();\n};\n\nmodule.exports = DataBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2RhdGFidWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWdCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9kYXRhYnVmZmVyLmpzPzU3ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiB1dGlsL2RhdGFidWZmZXIuanMgLSBGb3JnZS1jb21wYXRpYmxlIEJ1ZmZlciBiYXNlZCBvbiBOb2RlLmpzIEJ1ZmZlcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgYmFzZTY0dXJsID0gcmVxdWlyZShcIi4vYmFzZTY0dXJsLmpzXCIpO1xuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIERhdGFCdWZmZXIoYiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0cmVhdCAodmlld3Mgb2YpIChBcnJheSlCdWZmZXJzIHNwZWNpYWxcbiAgLy8gTk9URTogZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBjcmVhdGVzIGNvcGllcywgYnV0IGVmZmljaWVudGx5XG4gIC8vICAgICAgIHdoZXJldmVyIHBvc3NpYmxlXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aGlzLmRhdGEgPSBiO1xuICB9IGVsc2UgaWYgKGZvcmdlLnV0aWwuaXNBcnJheUJ1ZmZlcihiKSkge1xuICAgIGIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShiKTtcbiAgfSBlbHNlIGlmIChmb3JnZS51dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGIpKSB7XG4gICAgYiA9IG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCk7XG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYik7XG4gIH1cblxuICBpZiAodGhpcy5kYXRhKSB7XG4gICAgdGhpcy53cml0ZSA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgYiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHNldHVwIGdyb3d0aCByYXRlXG4gIHRoaXMuZ3Jvd1NpemUgPSBvcHRpb25zLmdyb3dTaXplIHx8IERhdGFCdWZmZXIuREVGQVVMVF9HUk9XX1NJWkU7XG5cbiAgLy8gaW5pdGlhbGl6ZSBwb2ludGVycyBhbmQgZGF0YVxuICB0aGlzLndyaXRlID0gdGhpcy53cml0ZSB8fCAwO1xuICB0aGlzLnJlYWQgPSB0aGlzLnJlYWQgfHwgMDtcbiAgaWYgKGIpIHtcbiAgICB0aGlzLnB1dEJ5dGVzKGIpO1xuICB9IGVsc2UgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICB0aGlzLmFjY29tbW9kYXRlKDApO1xuICB9XG5cbiAgLy8gbWFzc2FnZSByZWFkL3dyaXRlIHBvaW50ZXJzXG4gIG9wdGlvbnMucmVhZE9mZnNldCA9IChcInJlYWRPZmZzZXRcIiBpbiBvcHRpb25zKSA/XG4gICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVhZE9mZnNldCA6XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZDtcbiAgdGhpcy53cml0ZSA9IChcIndyaXRlT2Zmc2V0XCIgaW4gb3B0aW9ucykgP1xuICAgICAgICAgICAgICAgb3B0aW9ucy53cml0ZU9mZnNldCA6XG4gICAgICAgICAgICAgICB0aGlzLndyaXRlO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbihvcHRpb25zLnJlYWRPZmZzZXQsIHRoaXMud3JpdGUpO1xufVxuRGF0YUJ1ZmZlci5ERUZBVUxUX0dST1dfU0laRSA9IDE2O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUgLSB0aGlzLnJlYWQ7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoIC0gdGhpcy53cml0ZTtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aCgpIDw9IDA7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5hY2NvbW1vZGF0ZSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICBpZiAoIXRoaXMuZGF0YSkge1xuICAgIC8vIGluaXRpYWxpemVzIGEgbmV3IGJ1ZmZlclxuICAgIGxlbmd0aCA9IE1hdGgubWF4KHRoaXMud3JpdGUgKyBsZW5ndGgsIHRoaXMuZ3Jvd1NpemUpO1xuXG4gICAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAodGhpcy5hdmFpbGFibGUoKSA8IGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IE1hdGgubWF4KGxlbmd0aCwgdGhpcy5ncm93U2l6ZSk7XG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgZW1wdHkgYnVmZmVyLCBhbmQgY29weSBjdXJyZW50IG9uZSBpbnRvIGl0XG4gICAgdmFyIHNyYyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZHN0ID0gQnVmZmVyLmFsbG9jKHNyYy5sZW5ndGggKyBsZW5ndGgpO1xuICAgIHNyYy5jb3B5KGRzdCwgMCk7XG5cbiAgICAvLyBzZXQgZGF0YSBhcyB0aGUgbmV3IGJ1ZmZlclxuICAgIHRoaXMuZGF0YSA9IGRzdDtcbiAgfVxuICAvLyBlbnN1cmUgdGhlIHJlc3QgaXMgMFxuICB0aGlzLmRhdGEuZmlsbCgwLCB0aGlzLndyaXRlKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xuICByZXR1cm4gdGhpcztcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIC8vIGNob3Agb2ZmIDxjb3VudD4gYnl0ZXMgZnJvbSB0aGUgZW5kXG4gIHRoaXMud3JpdGUgPSB0aGlzLnJlYWQgKyBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCgpIC0gY291bnQpO1xuICAvLyBlbnN1cmUgdGhlIHJlbWFpbmRlciBpcyAwXG4gIHRoaXMuZGF0YS5maWxsKDAsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gdGhpcztcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlYWQgPiAwKSB7XG4gICAgaWYgKHRoaXMud3JpdGUgPT09IHRoaXMucmVhZCkge1xuICAgICAgdGhpcy5yZWFkID0gdGhpcy53cml0ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YS5jb3B5KHRoaXMuZGF0YSwgMCwgdGhpcy5yZWFkLCB0aGlzLndyaXRlKTtcbiAgICAgIHRoaXMud3JpdGUgPSB0aGlzLndyaXRlIC0gdGhpcy5yZWFkO1xuICAgICAgdGhpcy5yZWFkID0gMDtcbiAgICB9XG4gICAgLy8gZW5zdXJlIHJlbWFpbmRlciBpcyAwXG4gICAgdGhpcy5kYXRhLmZpbGwoMCwgdGhpcy53cml0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IERhdGFCdWZmZXIodGhpcywge1xuICAgIHJlYWRPZmZzZXQ6IHRoaXMucmVhZCxcbiAgICB3cml0ZU9mZnNldDogdGhpcy53cml0ZSxcbiAgICBncm93U2l6ZTogdGhpcy5ncm93U2l6ZVxuICB9KTtcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgaWYgKCFEYXRhQnVmZmVyLmlzQnVmZmVyKHRlc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRlc3QubGVuZ3RoKCkgIT09IHRoaXMubGVuZ3RoKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcnZhbCA9IHRydWUsXG4gICAgICBkZWx0YSA9IHRoaXMucmVhZCAtIHRlc3QucmVhZDtcbiAgLy8gY29uc3RhbnQgdGltZVxuICBmb3IgKHZhciBpZHggPSB0ZXN0LnJlYWQ7IHRlc3Qud3JpdGUgPiBpZHg7IGlkeCsrKSB7XG4gICAgcnZhbCA9IHJ2YWwgJiYgKHRoaXMuZGF0YVtpZHggKyBkZWx0YV0gPT09IHRlc3QuZGF0YVtpZHhdKTtcbiAgfVxuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKGlkeCkge1xuICByZXR1cm4gdGhpcy5kYXRhW3RoaXMucmVhZCArIGlkeF07XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuc2V0QXQgPSBmdW5jdGlvbihpZHgsIGIpIHtcbiAgdGhpcy5kYXRhW3RoaXMucmVhZCArIGlkeF0gPSBiO1xuICByZXR1cm4gdGhpcztcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmRhdGFbdGhpcy53cml0ZSAtIDFdO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWw7XG4gIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7XG4gICAgY291bnQgPSB0aGlzLmxlbmd0aCgpO1xuICB9IGVsc2UgaWYgKGNvdW50KSB7XG4gICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5sZW5ndGgoKSk7XG4gIH1cblxuICBpZiAoMCA9PT0gY291bnQpIHtcbiAgICBydmFsID0gXCJcIjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmVnaW4gPSB0aGlzLnJlYWQsXG4gICAgICAgIGVuZCA9IGJlZ2luICsgY291bnQsXG4gICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgcnZhbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbDtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gY291bnQpIHtcbiAgICBjb3VudCA9IHRoaXMubGVuZ3RoKCk7XG4gIH0gZWxzZSBpZiAoY291bnQpIHtcbiAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCB0aGlzLmxlbmd0aCgpKTtcbiAgfVxuXG4gIGlmICgwID09PSBjb3VudCkge1xuICAgIHJ2YWwgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJlZ2luID0gdGhpcy5yZWFkLFxuICAgICAgICBlbmQgPSBiZWdpbiArIGNvdW50LFxuICAgICAgICBkYXRhID0gdGhpcy5kYXRhLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgIHJ2YWwgPSBuZXcgVWludDhBcnJheShlbmQgLSBiZWdpbik7XG4gICAgcnZhbC5zZXQoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5uYXRpdmUgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbDtcbiAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiBjb3VudCkge1xuICAgIGNvdW50ID0gdGhpcy5sZW5ndGgoKTtcbiAgfSBlbHNlIGlmIChjb3VudCkge1xuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMubGVuZ3RoKCkpO1xuICB9XG5cbiAgaWYgKDAgPT09IGNvdW50KSB7XG4gICAgcnZhbCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmVnaW4gPSB0aGlzLnJlYWQsXG4gICAgICAgIGVuZCA9IGJlZ2luICsgY291bnQ7XG4gICAgcnZhbCA9IHRoaXMuZGF0YS5zbGljZShiZWdpbiwgZW5kKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoXCJoZXhcIik7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICAvLyBzaG9ydCBjaXJjdWl0IGVtcHR5IHN0cmluZ1xuICBpZiAoMCA9PT0gdGhpcy5sZW5ndGgoKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgdmFyIHZpZXcgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy5yZWFkLCB0aGlzLndyaXRlKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcInV0ZjhcIjtcbiAgLy8gc3BlY2lhbCBjYXNlcywgdGhlbiBidWlsdC1pbiBzdXBwb3J0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlIFwicmF3XCI6XG4gICAgICByZXR1cm4gdmlldy50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICByZXR1cm4gYmFzZTY0dXJsLmVuY29kZSh2aWV3KTtcbiAgICBjYXNlIFwidXRmMTZcIjpcbiAgICAgIHJldHVybiB2aWV3LnRvU3RyaW5nKFwidWNzMlwiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZpZXcudG9TdHJpbmcoZW5jb2RpbmcpO1xuICB9XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5maWxsV2l0aEJ5dGUgPSBmdW5jdGlvbihiLCBuKSB7XG4gIGlmICghbikge1xuICAgIG4gPSB0aGlzLmF2YWlsYWJsZSgpO1xuICB9XG4gIHRoaXMuYWNjb21tb2RhdGUobik7XG4gIHRoaXMuZGF0YS5maWxsKGIsIHRoaXMud3JpdGUsIHRoaXMud3JpdGUgKyBuKTtcbiAgdGhpcy53cml0ZSArPSBuO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLmJ1ZmZlcihjb3VudCk7XG4gIHRoaXMucmVhZCArPSBydmFsLmJ5dGVMZW5ndGg7XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoYnl0ZXMpO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbCA9IHRoaXMuYnl0ZXMoY291bnQpO1xuICB0aGlzLnJlYWQgKz0gcnZhbC5sZW5ndGg7XG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMsIGVuY29kaW5nKSB7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgYnl0ZXMpIHtcbiAgICAvLyBmaXh1cCBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgXCJiaW5hcnlcIjtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlIFwidXRmMTZcIjpcbiAgICAgICAgLy8gdHJlYXQgYXMgVUNTLTIvVVRGLTE2QkVcbiAgICAgICAgZW5jb2RpbmcgPSBcInVjcy0yXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJhd1wiOlxuICAgICAgICBlbmNvZGluZyA9IFwiYmluYXJ5XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhc2U2NHVybFwiOlxuICAgICAgICAvLyBOT1RFOiB0aGlzIHJldHVybnMgYSBCdWZmZXJcbiAgICAgICAgYnl0ZXMgPSBiYXNlNjR1cmwuZGVjb2RlKGJ5dGVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBieXRlcyB3aXRoIGRlY29kZWQgQnVmZmVyIChpZiBub3QgYWxyZWFkeSlcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihieXRlcykpIHtcbiAgICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3JjLCBkc3Q7XG4gIGlmIChieXRlcyBpbnN0YW5jZW9mIERhdGFCdWZmZXIpIHtcbiAgICAvLyBiZSBzbGlnaHRseSBtb3JlIGVmZmljaWVudFxuICAgIHZhciBvcmlnID0gYnl0ZXM7XG4gICAgYnl0ZXMgPSBvcmlnLmRhdGEuc2xpY2Uob3JpZy5yZWFkLCBvcmlnLndyaXRlKTtcbiAgICBvcmlnLnJlYWQgPSBvcmlnLndyaXRlO1xuICB9IGVsc2UgaWYgKGJ5dGVzIGluc3RhbmNlb2YgZm9yZ2UudXRpbC5CeXRlU3RyaW5nQnVmZmVyKSB7XG4gICAgYnl0ZXMgPSBieXRlcy5nZXRCeXRlcygpO1xuICB9XG5cbiAgLy8gcHJvY2VzcyBhcnJheVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKSkge1xuICAgIHNyYyA9IGJ5dGVzO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgc3JjID0gQnVmZmVyLmZyb20oYnl0ZXMpO1xuICB9IGVsc2UgaWYgKGZvcmdlLnV0aWwuaXNBcnJheUJ1ZmZlcihieXRlcykpIHtcbiAgICBzcmMgPSBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgc3JjID0gQnVmZmVyLmZyb20oc3JjKTtcbiAgfSBlbHNlIGlmIChmb3JnZS51dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGJ5dGVzKSkge1xuICAgIHNyYyA9IChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpID9cbiAgICAgICAgICAgICAgYnl0ZXMgOlxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShieXRlcy5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgIHNyYyA9IEJ1ZmZlci5mcm9tKHNyYyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgc291cmNlIHR5cGVcIik7XG4gIH1cblxuICB0aGlzLmFjY29tbW9kYXRlKHNyYy5sZW5ndGgpO1xuICBkc3QgPSB0aGlzLmRhdGE7XG4gIHNyYy5jb3B5KGRzdCwgdGhpcy53cml0ZSk7XG4gIHRoaXMud3JpdGUgKz0gc3JjLmxlbmd0aDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldE5hdGl2ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsID0gdGhpcy5uYXRpdmUoY291bnQpO1xuICB0aGlzLnJlYWQgKz0gcnZhbC5sZW5ndGg7XG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dE5hdGl2ZSA9IERhdGFCdWZmZXIucHJvdG90eXBlLnB1dEJ1ZmZlcjtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0Qnl0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYiA9IHRoaXMuZGF0YVt0aGlzLnJlYWRdO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyAxLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIGI7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgxKTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gYiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUrKztcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDE2ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gKHRoaXMuZGF0YVt0aGlzLnJlYWRdIDw8IDgpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDFdKTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgMiwgdGhpcy53cml0ZSk7XG4gIHJldHVybiBuO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDE2ID0gZnVuY3Rpb24obikge1xuICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSAobiA+Pj4gOCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDFdID0gbiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUgKz0gMjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9ICh0aGlzLmRhdGFbdGhpcy5yZWFkXSA8PCAxNikgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMV0gPDwgOCkgXlxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAyXTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgMywgdGhpcy53cml0ZSk7XG4gIHJldHVybiBuO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0ID0gZnVuY3Rpb24obikge1xuICB0aGlzLmFjY29tbW9kYXRlKDMpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSAobiA+Pj4gMTYpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAxXSA9IChuID4+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMl0gPSBuICYgMHhmZjtcbiAgdGhpcy53cml0ZSArPSAzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gKHRoaXMuZGF0YVt0aGlzLnJlYWRdIDw8IDI0KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAxXSA8PCAxNikgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMl0gPDwgOCkgXlxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAzXTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgNCwgdGhpcy53cml0ZSk7XG4gIHJldHVybiBuO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDMyID0gZnVuY3Rpb24obikge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSAobiA+Pj4gMjQpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAxXSA9IChuID4+PiAxNikgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDJdID0gKG4gPj4+IDgpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAzXSA9IG4gJiAweGZmO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTZMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9ICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMV0gPDwgOCkgXlxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnJlYWRdO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyAyLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIG47XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTZMZSA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgyKTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAxXSA9IChuID4+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IG4gJiAweGZmO1xuICB0aGlzLndyaXRlICs9IDI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MjRMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9ICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMl0gPDwgMTYpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDFdIDw8IDgpIF5cbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5yZWFkXTtcbiAgdGhpcy5yZWFkID0gTWF0aC5taW4odGhpcy5yZWFkICsgMywgdGhpcy53cml0ZSk7XG4gIHJldHVybiBuO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludDI0TGUgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMl0gPSAobiA+Pj4gMTYpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAxXSA9IChuID4+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IG4gJiAweGZmO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDMyTGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSAodGhpcy5kYXRhW3RoaXMucmVhZCArIDNdIDw8IDI0KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAyXSA8PCAxNikgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMV0gPDwgOCkgXlxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnJlYWRdO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyA0LCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIG47XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzJMZSA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSg0KTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAzXSA9IChuID4+PiAyNCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDJdID0gKG4gPj4+IDE2KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMV0gPSAobiA+Pj4gOCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSBuICYgMHhmZjtcbiAgdGhpcy53cml0ZSArPSA0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludCA9IGZ1bmN0aW9uKGJpdHMpIHtcbiAgdmFyIHJ2YWwgPSAwO1xuICBkbyB7XG4gICAgcnZhbCA9IChydmFsIDw8IDgpIHwgdGhpcy5nZXRCeXRlKCk7XG4gICAgYml0cyAtPSA4O1xuICB9IHdoaWxlIChiaXRzID4gMCk7XG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dEludCA9IGZ1bmN0aW9uKG4sIGJpdHMpIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZShNYXRoLmNlaWwoYml0cyAvIDgpKTtcbiAgZG8ge1xuICAgIGJpdHMgLT0gODtcbiAgICB0aGlzLnB1dEJ5dGUoKG4gPj4gYml0cykgJiAweGZmKTtcbiAgfSB3aGlsZSAoYml0cyA+IDApO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLnB1dFNpZ25lZEludCA9IGZ1bmN0aW9uKG4sIGJpdHMpIHtcbiAgaWYgKG4gPCAwKSB7XG4gICAgbiArPSAyIDw8IChiaXRzIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMucHV0SW50KG4sIGJpdHMpO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiB0aGlzLnB1dEJ5dGVzKHN0ciwgXCJ1dGYxNlwiKTtcbn07XG5cbkRhdGFCdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gIHJldHVybiAodGVzdCBpbnN0YW5jZW9mIERhdGFCdWZmZXIpO1xufTtcbkRhdGFCdWZmZXIuYXNCdWZmZXIgPSBmdW5jdGlvbihvcmlnKSB7XG4gIHJldHVybiBEYXRhQnVmZmVyLmlzQnVmZmVyKG9yaWcpID9cbiAgICAgICAgIG9yaWcgOlxuICAgICAgICAgb3JpZyA/XG4gICAgICAgICBuZXcgRGF0YUJ1ZmZlcihvcmlnKSA6XG4gICAgICAgICBuZXcgRGF0YUJ1ZmZlcigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhQnVmZmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/databuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/index.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/util/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/index.js - Utilities Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\");\n\nvar util;\n\nfunction asBuffer(input, encoding) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n\n  if (\"string\" === typeof input) {\n    encoding = encoding || \"binary\";\n    if (\"base64url\" === encoding) {\n      return util.base64url.decode(input);\n    }\n    return Buffer.from(input, encoding);\n  }\n\n  // assume input is an Array, ArrayBuffer, or ArrayBufferView\n  if (forge.util.isArrayBufferView(input)) {\n    input = (input instanceof Uint8Array) ?\n            input :\n            new Uint8Array(input.buffer, input.byteOffset, input.byteOffset + input.byteLength);\n  } else if (forge.util.isArrayBuffer(input)) {\n    input = new Uint8Array(input);\n  }\n\n  var output;\n  output = Buffer.from(input);\n\n  return output;\n}\n\nfunction randomBytes(len) {\n  return Buffer.from(forge.random.getBytes(len), \"binary\");\n}\n\nutil = {\n  base64url: __webpack_require__(/*! ./base64url.js */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n  utf8: __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/node-jose/lib/util/utf8.js\"),\n  asBuffer: asBuffer,\n  randomBytes: randomBytes\n};\nmodule.exports = util;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDckMsUUFBUSxtQkFBTyxDQUFDLGtFQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3V0aWwvaW5kZXguanM/Y2FhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHV0aWwvaW5kZXguanMgLSBVdGlsaXRpZXMgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIik7XG5cbnZhciB1dGlsO1xuXG5mdW5jdGlvbiBhc0J1ZmZlcihpbnB1dCwgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcImJpbmFyeVwiO1xuICAgIGlmIChcImJhc2U2NHVybFwiID09PSBlbmNvZGluZykge1xuICAgICAgcmV0dXJuIHV0aWwuYmFzZTY0dXJsLmRlY29kZShpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShpbnB1dCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gYXNzdW1lIGlucHV0IGlzIGFuIEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQXJyYXlCdWZmZXJWaWV3XG4gIGlmIChmb3JnZS51dGlsLmlzQXJyYXlCdWZmZXJWaWV3KGlucHV0KSkge1xuICAgIGlucHV0ID0gKGlucHV0IGluc3RhbmNlb2YgVWludDhBcnJheSkgP1xuICAgICAgICAgICAgaW5wdXQgOlxuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoaW5wdXQuYnVmZmVyLCBpbnB1dC5ieXRlT2Zmc2V0LCBpbnB1dC5ieXRlT2Zmc2V0ICsgaW5wdXQuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoZm9yZ2UudXRpbC5pc0FycmF5QnVmZmVyKGlucHV0KSkge1xuICAgIGlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICB9XG5cbiAgdmFyIG91dHB1dDtcbiAgb3V0cHV0ID0gQnVmZmVyLmZyb20oaW5wdXQpO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGxlbikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oZm9yZ2UucmFuZG9tLmdldEJ5dGVzKGxlbiksIFwiYmluYXJ5XCIpO1xufVxuXG51dGlsID0ge1xuICBiYXNlNjR1cmw6IHJlcXVpcmUoXCIuL2Jhc2U2NHVybC5qc1wiKSxcbiAgdXRmODogcmVxdWlyZShcIi4vdXRmOC5qc1wiKSxcbiAgYXNCdWZmZXI6IGFzQnVmZmVyLFxuICByYW5kb21CeXRlczogcmFuZG9tQnl0ZXNcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/util/merge.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/utf8.js - Implementation of UTF-8 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar partialRight = __webpack_require__(/*! lodash/partialRight */ \"(ssr)/./node_modules/lodash/partialRight.js\");\nvar merge = __webpack_require__(/*! lodash/merge */ \"(ssr)/./node_modules/lodash/merge.js\");\n\nvar typedArrayCtors = (function() {\n  var ctors = [];\n  if (\"undefined\" !== typeof Uint8ClampedArray) {\n    ctors.push(Uint8ClampedArray);\n  }\n  if (\"undefined\" !== typeof Uint8Array) {\n    ctors.push(Uint8Array);\n  }\n  if (\"undefined\" !== typeof Uint16Array) {\n    ctors.push(Uint16Array);\n  }\n  if (\"undefined\" !== typeof Uint32Array) {\n    ctors.push(Uint32Array);\n  }\n  if (\"undefined\" !== typeof Float32Array) {\n    ctors.push(Float32Array);\n  }\n  if (\"undefined\" !== typeof Float64Array) {\n    ctors.push(Float64Array);\n  }\n  return ctors;\n})();\n\nfunction findTypedArrayFor(ta) {\n  var ctor;\n  for (var idx = 0; !ctor && typedArrayCtors.length > idx; idx++) {\n    if (ta instanceof typedArrayCtors[idx]) {\n      ctor = typedArrayCtors[idx];\n    }\n  }\n  return ctor;\n}\n\nfunction mergeBuffer(a, b) {\n  // TODO: should this be a copy, or the reference itself?\n  if (Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  } else {\n    var Ctor = findTypedArrayFor(b);\n    b = Ctor ?\n        new Ctor(b, b.byteOffset, b.byteLength) :\n        undefined;\n  }\n\n  // TODO: QUESTION: create a merged <whatever-a-is>??\n  // for now, a is b\n  a = b;\n\n  return b;\n}\n\nmodule.exports = partialRight(merge, mergeBuffer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL21lcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDaEQsWUFBWSxtQkFBTyxDQUFDLDBEQUFjOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3V0aWwvbWVyZ2UuanM/OTQwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHV0aWwvdXRmOC5qcyAtIEltcGxlbWVudGF0aW9uIG9mIFVURi04IEVuY29kZXIvRGVjb2RlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcGFydGlhbFJpZ2h0ID0gcmVxdWlyZShcImxvZGFzaC9wYXJ0aWFsUmlnaHRcIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwibG9kYXNoL21lcmdlXCIpO1xuXG52YXIgdHlwZWRBcnJheUN0b3JzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY3RvcnMgPSBbXTtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIGN0b3JzLnB1c2goVWludDhDbGFtcGVkQXJyYXkpO1xuICB9XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgVWludDhBcnJheSkge1xuICAgIGN0b3JzLnB1c2goVWludDhBcnJheSk7XG4gIH1cbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBVaW50MTZBcnJheSkge1xuICAgIGN0b3JzLnB1c2goVWludDE2QXJyYXkpO1xuICB9XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgVWludDMyQXJyYXkpIHtcbiAgICBjdG9ycy5wdXNoKFVpbnQzMkFycmF5KTtcbiAgfVxuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIEZsb2F0MzJBcnJheSkge1xuICAgIGN0b3JzLnB1c2goRmxvYXQzMkFycmF5KTtcbiAgfVxuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIEZsb2F0NjRBcnJheSkge1xuICAgIGN0b3JzLnB1c2goRmxvYXQ2NEFycmF5KTtcbiAgfVxuICByZXR1cm4gY3RvcnM7XG59KSgpO1xuXG5mdW5jdGlvbiBmaW5kVHlwZWRBcnJheUZvcih0YSkge1xuICB2YXIgY3RvcjtcbiAgZm9yICh2YXIgaWR4ID0gMDsgIWN0b3IgJiYgdHlwZWRBcnJheUN0b3JzLmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICBpZiAodGEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q3RvcnNbaWR4XSkge1xuICAgICAgY3RvciA9IHR5cGVkQXJyYXlDdG9yc1tpZHhdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3Rvcjtcbn1cblxuZnVuY3Rpb24gbWVyZ2VCdWZmZXIoYSwgYikge1xuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBhIGNvcHksIG9yIHRoZSByZWZlcmVuY2UgaXRzZWxmP1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgYiA9IEJ1ZmZlci5mcm9tKGIpO1xuICB9IGVsc2Uge1xuICAgIHZhciBDdG9yID0gZmluZFR5cGVkQXJyYXlGb3IoYik7XG4gICAgYiA9IEN0b3IgP1xuICAgICAgICBuZXcgQ3RvcihiLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkgOlxuICAgICAgICB1bmRlZmluZWQ7XG4gIH1cblxuICAvLyBUT0RPOiBRVUVTVElPTjogY3JlYXRlIGEgbWVyZ2VkIDx3aGF0ZXZlci1hLWlzPj8/XG4gIC8vIGZvciBub3csIGEgaXMgYlxuICBhID0gYjtcblxuICByZXR1cm4gYjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJ0aWFsUmlnaHQobWVyZ2UsIG1lcmdlQnVmZmVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/merge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/utf8.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/util/utf8.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * util/utf8.js - Implementation of UTF-8 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar utf8 = exports;\n\nutf8.encode = function(input) {\n  var output = encodeURIComponent(input || \"\");\n  output = output.replace(/%([0-9a-fA-F]{2})/g, function(m, code) {\n    code = parseInt(code, 16);\n    return String.fromCharCode(code);\n  });\n\n  return output;\n};\nutf8.decode = function(input) {\n  var output = (input || \"\").replace(/[\\u0080-\\u00ff]/g, function(m) {\n    var code = (0x100 | m.charCodeAt(0)).toString(16).substring(1);\n    return \"%\" + code;\n  });\n  output = decodeURIComponent(output);\n\n  return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL3V0ZjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL3V0ZjguanM/ZGRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHV0aWwvdXRmOC5qcyAtIEltcGxlbWVudGF0aW9uIG9mIFVURi04IEVuY29kZXIvRGVjb2RlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdXRmOCA9IGV4cG9ydHM7XG5cbnV0ZjguZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCB8fCBcIlwiKTtcbiAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLyUoWzAtOWEtZkEtRl17Mn0pL2csIGZ1bmN0aW9uKG0sIGNvZGUpIHtcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSwgMTYpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcbnV0ZjguZGVjb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IChpbnB1dCB8fCBcIlwiKS5yZXBsYWNlKC9bXFx1MDA4MC1cXHUwMGZmXS9nLCBmdW5jdGlvbihtKSB7XG4gICAgdmFyIGNvZGUgPSAoMHgxMDAgfCBtLmNoYXJDb2RlQXQoMCkpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIFwiJVwiICsgY29kZTtcbiAgfSk7XG4gIG91dHB1dCA9IGRlY29kZVVSSUNvbXBvbmVudChvdXRwdXQpO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL2luZGV4LmpzPzZlNTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2YWxpZGF0ZSB9IGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsU0FBUyx3REFBaUI7QUFDMUI7O0FBRUEsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzP2U0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4Jyk7XG4gIH1cblxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1QixpRUFBZTtBQUNmLGNBQWMsMERBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25hdGl2ZS5qcz82NjA1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRDogY3J5cHRvLnJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL25pbC5qcz9lMWVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3BhcnNlLmpzP2JlZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgbGV0IHY7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JlZ2V4LmpzP2NmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1Qix1Q0FBdUM7O0FBRXZDO0FBQ2U7QUFDZjtBQUNBLElBQUksNERBQXFCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzPzQ5NzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuY29uc3Qgcm5kczhQb29sID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTsgLy8gIyBvZiByYW5kb20gdmFsdWVzIHRvIHByZS1hbGxvY2F0ZVxuXG5sZXQgcG9vbFB0ciA9IHJuZHM4UG9vbC5sZW5ndGg7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIGlmIChwb29sUHRyID4gcm5kczhQb29sLmxlbmd0aCAtIDE2KSB7XG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKHJuZHM4UG9vbCk7XG4gICAgcG9vbFB0ciA9IDA7XG4gIH1cblxuICByZXR1cm4gcm5kczhQb29sLnNsaWNlKHBvb2xQdHIsIHBvb2xQdHIgKz0gMTYpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3NoYTEuanM/ODQ2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIGJ5dGVzID0gQnVmZmVyLmZyb20oYnl0ZXMsICd1dGY4Jyk7XG4gIH1cblxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9zaC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2Uvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/YWVlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiBieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCLENBQUM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7OztBQUdmO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsK0NBQUc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFOztBQUVBLDRFQUE0RTs7QUFFNUUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG9DQUFvQzs7QUFFcEMsOEJBQThCOztBQUU5QixrQ0FBa0M7O0FBRWxDLDRCQUE0Qjs7QUFFNUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxnQkFBZ0IsOERBQWU7QUFDL0I7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanM/OWNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG5sZXQgX25vZGVJZDtcblxubGV0IF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxubGV0IF9sYXN0TVNlY3MgPSAwO1xubGV0IF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBsZXQgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgY29uc3QgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgbGV0IGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTsgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgY29uc3Qgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIGxldCBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgbGV0IG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgY29uc3QgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICBjb25zdCB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICBjb25zdCB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHVuc2FmZVN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3YzLmpzPzQ1YmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbmNvbnN0IHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyw4REFBZTtBQUMxQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21vc2gvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzPzNhZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgY29uc3QgYnl0ZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgY29uc3QgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgY29uc3QgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2MzUobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgdmFyIF9uYW1lc3BhY2U7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKCgoX25hbWVzcGFjZSA9IG5hbWVzcGFjZSkgPT09IG51bGwgfHwgX25hbWVzcGFjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25hbWVzcGFjZS5sZW5ndGgpICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCOztBQUVqRDtBQUNBLE1BQU0sa0RBQU07QUFDWixXQUFXLGtEQUFNO0FBQ2pCOztBQUVBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDhEQUFlO0FBQ3hCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y0LmpzPzA2NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3Y1LmpzPzQ0ODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xuY29uc3QgdjUgPSB2MzUoJ3Y1JywgMHg1MCwgc2hhMSk7XG5leHBvcnQgZGVmYXVsdCB2NTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzPzk0NjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb3NoLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZlcnNpb24uanM/ODFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxNSksIDE2KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmVyc2lvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js\n");

/***/ })

};
;